/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (input) => {
                to.set(arg3(input));
            };
            onDestroy = arg4;
        }
        else {
            handler = (input) => {
                to.set(input);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(this.updateValue.bind(this, index)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(mapFunc, ...args) {
        let equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            equalityFunc = args.shift();
        }
        else {
            equalityFunc = MappedSubject.DEFAULT_EQUALITY_FUNC;
        }
        if (typeof args[0] === 'function') {
            mutateFunc = args.shift();
            initialVal = args.shift();
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Updates an input value, then re-maps this subject's value, and notifies subscribers if this results in a change to
     * the mapped value according to this subject's equality function.
     * @param index The index of the input value to update.
     */
    updateValue(index) {
        this.inputValues[index] = this.inputs[index].get();
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscribers that this subscribable's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`MappedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    /**
     * Destroys the subscription to the parent subscribable.
     */
    destroy() {
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return new MappedSubject(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : MappedSubject.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
MappedSubject.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(this.obj, key, this.obj[key], oldValue);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === 'Fragment') {
                let childNodes = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (childNodes !== null && childNodes.length > 0 && Array.isArray(childNodes[0])) {
                    childNodes = childNodes[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: childNodes
                };
            }
            else {
                let instance;
                try {
                    instance = type(props);
                }
                catch (_a) {
                    instance = new type(props);
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
                insertNode(node, position, element);
            }
            else {
                if (position === RenderPosition.After) {
                    for (let i = node.children.length - 1; i >= 0; i--) {
                        if (node.children[i] === undefined || node.children[i] === null) {
                            continue;
                        }
                        insertNode(node.children[i], position, element);
                    }
                }
                else {
                    for (let i = 0; i < node.children.length; i++) {
                        if (node.children[i] === undefined || node.children[i] === null) {
                            continue;
                        }
                        insertNode(node.children[i], position, element);
                    }
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                componentInstance.onAfterRender(node);
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     * @returns True if the visitation should break, or false otherwise.
     */
    function visitNodes(node, visitor) {
        const stopVisitation = visitor(node);
        if (node !== undefined && node !== null && !stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                visitNodes(node.children[i], visitor);
            }
        }
        return true;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString) {
        return classString.split(' ').filter(str => str !== '');
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set; these reserved classes may be freely added to and removed from the bound set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClasses An iterable of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class AbstractSubscribableArray {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        const array = this.getArray();
        if (index > array.length - 1) {
            throw new Error('Index out of range');
        }
        return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(index, type, modifiedItem, this.getArray());
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ArraySubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const array = this.getArray();
        sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject extends AbstractSubscribableArray {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        super();
        this.array = arr;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
        return this.array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index = -1) {
        if (index === -1 || index > this.array.length - 1) {
            this.array.push(item);
        }
        else {
            this.array.splice(index, 0, item);
        }
        this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this.array.splice(index, 0, ...arr);
        this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this.array.splice(index, 1);
        this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this.array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this.array.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this.array;
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.rawValue = value;
        this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this.rawValue = value;
        const compValue = this.computeFn(value);
        if (compValue !== this.value) {
            this.value = compValue;
            this.notify();
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ComputedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An event which can be emitted with optional data to subscribers.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Subscribes to this event.
     * @param handler A function to be called when an event is emitted.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /**
     * Unsubscribes a callback function from this event.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Clears all subscriptions to this event.
     */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /**
     * Emits an event to subscribers.
     * @param sender The source of the event.
     * @param data Data associated with the event.
     */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        const diff = this.number - converted;
        return Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one pound of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665)], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);

/**
 * A Subject which provides a NumberUnitInterface value.
 */
class NumberUnitSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns a NumberUnitSubject.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = sinTheta * Math.cos(phi);
        vec[1] = sinTheta * Math.sin(phi);
        vec[2] = Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1.length === vec2.length && vec1.every((element, index) => element === vec2[index]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = x === this.value[0] && y === this.value[1];
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (array[i] !== this.value[i]) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
class Transform2D {
    constructor() {
        this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
        let scaleX = arg1;
        if (arg1 instanceof Transform2D) {
            [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewX;
        array[2] = translateX;
        array[3] = skewY;
        array[4] = scaleY;
        array[5] = translateY;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[4] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y) {
        this.array[0] = x;
        this.array[4] = y;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value) {
        this.array[1] = value;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[2] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y) {
        this.array[2] = x;
        this.array[5] = y;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_10 = array[3];
        const e_11 = array[4];
        const e_12 = array[5];
        const i_00 = e_11;
        const i_01 = -e_10;
        const i_10 = -e_01;
        const i_11 = e_00;
        const i_20 = e_01 * e_12 - e_02 * e_11;
        const i_21 = -(e_00 * e_12 - e_02 * e_10);
        const det = e_00 * i_00 + e_01 * i_01;
        return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform2D().set(this);
    }
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
        const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
        return Vec2Math.set(x, y, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y) {
        return Transform2D.concat(this, Transform2D.transformCache[2].toTranslation(-x, -y), this, Transform2D.transformCache[3].toTranslation(x, y));
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y) {
        return this.set(1, 0, x, 0, 1, y);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, originX, originY) {
        this.set(x, 0, 0, 0, y, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, originX, originY) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toReflection(theta, originX, originY) {
        const sin = Math.sin(2 * theta);
        const cos = Math.cos(2 * theta);
        this.set(cos, sin, 0, sin, -cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, ...transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform2D.transformCache[0];
        const newTransform = Transform2D.transformCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform2D.transformCache = [new Transform2D(), new Transform2D(), new Transform2D(), new Transform2D()];

/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
class Transform3D {
    constructor() {
        this.array = new Float64Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0
        ]);
    }
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
        let scaleX = arg1;
        if (arg1 instanceof Transform3D) {
            [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewXY;
        array[2] = skewXZ;
        array[3] = translateX;
        array[4] = skewYX;
        array[5] = scaleY;
        array[6] = skewYZ;
        array[7] = translateY;
        array[8] = skewZX;
        array[9] = skewZY;
        array[10] = scaleZ;
        array[11] = translateZ;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value) {
        this.array[10] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y, z) {
        this.array[0] = x;
        this.array[5] = y;
        this.array[10] = z;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y, z) {
        this.array[1] = y;
        this.array[2] = z;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x, z) {
        this.array[4] = x;
        this.array[6] = z;
        return this;
    }
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x, y) {
        this.array[8] = x;
        this.array[9] = y;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[7] = value;
        return this;
    }
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value) {
        this.array[11] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y, z) {
        this.array[3] = x;
        this.array[7] = y;
        this.array[11] = z;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_03 = array[3];
        const e_10 = array[4];
        const e_11 = array[5];
        const e_12 = array[6];
        const e_13 = array[7];
        const e_20 = array[8];
        const e_21 = array[9];
        const e_22 = array[10];
        const e_23 = array[11];
        const c_00 = e_11 * e_22 - e_12 * e_21;
        const c_01 = e_12 * e_21 - e_10 * e_22;
        const c_02 = e_10 * e_21 - e_11 * e_20;
        const c_10 = e_02 * e_21 - e_01 * e_22;
        const c_11 = e_00 * e_22 - e_02 * e_20;
        const c_12 = e_01 * e_20 - e_00 * e_21;
        const c_20 = e_01 * e_12 - e_02 * e_11;
        const c_21 = e_02 * e_10 - e_00 * e_12;
        const c_22 = e_00 * e_11 - e_01 * e_10;
        const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
        if (det === 0) {
            throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
        }
        const i_00 = c_00 / det;
        const i_01 = c_10 / det;
        const i_02 = c_20 / det;
        const i_10 = c_01 / det;
        const i_11 = c_11 / det;
        const i_12 = c_21 / det;
        const i_20 = c_02 / det;
        const i_21 = c_12 / det;
        const i_22 = c_22 / det;
        const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
        const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
        const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
        return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform3D().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
        const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
        const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
        return Vec3Math.set(x, y, z, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y, z) {
        return Transform3D.concat(this, Transform3D.transformCache[2].toTranslation(-x, -y, -z), this, Transform3D.transformCache[3].toTranslation(x, y, z));
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 0, z);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, z, originX, originY, originZ) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, 1, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationX(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationY(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationZ(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
        const abs = Math.hypot(axisX, axisY, axisZ);
        const ux = axisX / abs;
        const uy = axisY / abs;
        const uz = axisZ / abs;
        const ux_uy = ux * uy;
        const ux_uz = ux * uz;
        const uy_uz = uy * uz;
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        const cosCompl = 1 - cos;
        this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, ...transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform3D.transformCache[0];
        const newTransform = Transform3D.transformCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    newArray[j * 4 + i] =
                        oldArray[i] * nextArray[j * 4]
                            + oldArray[4 + i] * nextArray[j * 4 + 1]
                            + oldArray[8 + i] * nextArray[j * 4 + 2]
                            + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform3D.transformCache = [new Transform3D(), new Transform3D(), new Transform3D(), new Transform3D()];

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws {Error} if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws {Error} If argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
        if (other) {
            return this.distance(other) <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1 * Avionics.Utils.DEG2RAD;
                lon1 = arg2 * Avionics.Utils.DEG2RAD;
                lat2 = arg3 * Avionics.Utils.DEG2RAD;
                lon2 = arg4 * Avionics.Utils.DEG2RAD;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns the length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return Math.sin(this._radius) * angle;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        return isArcGreaterThanSemi ? 2 * Math.PI - angularDistance : angularDistance;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this.arcLength(this.angleAlong(start, end, tolerance));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane.
     * @param radius The airplane turn radius.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="msfstypes/Coherent/Facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a GeoPointInterface value.
 */
class GeoPointSubject extends Subject {
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns a GeoPointSubject.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal, Subject.DEFAULT_EQUALITY_FUNC);
    }
}

/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
class AbstractGeoProjection {
    constructor() {
        this.center = new GeoPoint(0, 0);
        this.centerTranslation = new Float64Array(2);
        this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE); // 1 pixel = 1 nautical mile
        this.preRotation = new Float64Array(3);
        this.translation = new Float64Array(2);
        this.postRotation = 0;
        this.rotationSin = 0;
        this.rotationCos = 1;
        this.reflectY = 1;
        this.preRotationForwardTransform = new Transform3D();
        this.preRotationReverseTransform = new Transform3D();
    }
    /** @inheritdoc */
    getCenter() {
        return this.center.readonly;
    }
    /** @inheritdoc */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /** @inheritdoc */
    getPreRotation() {
        return this.preRotation;
    }
    /** @inheritdoc */
    getTranslation() {
        return this.translation;
    }
    /** @inheritdoc */
    getPostRotation() {
        return this.postRotation;
    }
    /** @inheritdoc */
    getReflectY() {
        return this.reflectY === -1;
    }
    /** @inheritdoc */
    setCenter(point) {
        this.center.set(point);
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setScaleFactor(factor) {
        this.scaleFactor = factor;
        return this;
    }
    /** @inheritdoc */
    setPreRotation(vec) {
        this.preRotation.set(vec);
        this.updatePreRotationTransforms();
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setTranslation(vec) {
        this.translation.set(vec);
        return this;
    }
    /** @inheritdoc */
    setPostRotation(rotation) {
        this.postRotation = rotation;
        this.rotationCos = Math.cos(rotation);
        this.rotationSin = Math.sin(rotation);
        return this;
    }
    /** @inheritdoc */
    setReflectY(val) {
        this.reflectY = val ? -1 : 1;
        return this;
    }
    /** @inheritdoc */
    copyParametersFrom(other) {
        return this.setCenter(other.getCenter())
            .setPreRotation(other.getPreRotation())
            .setScaleFactor(other.getScaleFactor())
            .setTranslation(other.getTranslation())
            .setPostRotation(other.getPostRotation())
            .setReflectY(other.getReflectY());
    }
    /**
     * Updates the pre-rotation transformation matrices.
     */
    updatePreRotationTransforms() {
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        const phiRotation = AbstractGeoProjection.transformCache[1].toRotationY(-phi);
        const gammaRotation = AbstractGeoProjection.transformCache[0].toRotationX(gamma);
        Transform3D.concat(this.preRotationForwardTransform, gammaRotation, phiRotation);
        this.preRotationReverseTransform.set(this.preRotationForwardTransform);
        this.preRotationReverseTransform.invert();
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
        const centerArray = AbstractGeoProjection.vec2Cache[0];
        centerArray[0] = this.center.lon;
        centerArray[1] = this.center.lat;
        this.preRotateForward(centerArray, centerArray);
        this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        if (phi === 0 && gamma === 0) {
            return Vec2Math.set(rotatedLon, lat, out);
        }
        const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
        const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
        return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        let rotatedLat = lat;
        let rotatedLon = lon;
        if (phi !== 0 || gamma !== 0) {
            const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
            const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
            const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
            rotatedLat = unrotated.lat;
            rotatedLon = unrotated.lon;
        }
        rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /** @inheritdoc */
    project(point, out) {
        if (point instanceof Float64Array) {
            out.set(point);
        }
        else {
            out[0] = point.lon;
            out[1] = point.lat;
        }
        this.preRotateForward(out, out);
        this.projectRaw(out, out);
        // translate projected center point to origin
        out[0] -= this.centerTranslation[0];
        out[1] -= this.centerTranslation[1];
        // apply y-reflection
        out[1] *= this.reflectY;
        // apply scale factor
        out[0] *= this.scaleFactor;
        out[1] *= this.scaleFactor;
        // apply post-projection rotation
        const x = out[0];
        const y = out[1];
        out[0] = x * this.rotationCos - y * this.rotationSin;
        out[1] = x * this.rotationSin + y * this.rotationCos;
        // apply post-projection translation
        out[0] += this.translation[0];
        out[1] += this.translation[1];
        return out;
    }
    /** @inheritdoc */
    invert(vec, out) {
        const projected = AbstractGeoProjection.vec2Cache[0];
        projected.set(vec);
        // invert post-projection translation
        projected[0] -= this.translation[0];
        projected[1] -= this.translation[1];
        // invert post-projection rotation
        const x = projected[0];
        const y = projected[1];
        projected[0] = x * this.rotationCos + y * this.rotationSin;
        projected[1] = -x * this.rotationSin + y * this.rotationCos;
        // invert scale factor
        projected[0] /= this.scaleFactor;
        projected[1] /= this.scaleFactor;
        // invert y-reflection
        projected[1] *= this.reflectY;
        // translate projected center point to default projected position
        projected[0] += this.centerTranslation[0];
        projected[1] += this.centerTranslation[1];
        const inverted = this.invertRaw(projected, projected);
        this.preRotateReverse(inverted, inverted);
        if (out instanceof Float64Array) {
            out.set(inverted);
            return out;
        }
        else {
            return out.set(inverted[1], inverted[0]);
        }
    }
}
AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
AbstractGeoProjection.transformCache = [new Transform3D(), new Transform3D()];
/**
 * A Mercator projection.
 */
class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.DEG2RAD;
        out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
        return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.RAD2DEG;
        out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
        return out;
    }
}

/**
 * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
 */
class GeoCircleResampler {
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
        this.minDistance = minDistance;
        this.dpTolerance = dpTolerance;
        this.maxDepth = maxDepth;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.startVector = {
            type: 'start',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.lineVector = {
            type: 'line',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.arcVector = {
            type: 'arc',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            projectedArcCenter: new Float64Array(2),
            projectedArcRadius: 0,
            projectedArcStartAngle: 0,
            projectedArcEndAngle: 0,
            index: 0
        };
        this.state = {
            index: 0,
            prevX: 0,
            prevY: 0,
            vectorType: 'line',
            arcCenterX: 0,
            arcCenterY: 0,
            arcRadius: 0,
            isArcCounterClockwise: false
        };
        this.cosMinDistance = Math.cos(minDistance);
        this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection, circle, start, end, handler) {
        let startPoint, startVec, endPoint, endVec;
        if (start instanceof Float64Array) {
            startPoint = this.geoPointCache[0].setFromCartesian(start);
            startVec = start;
        }
        else {
            startPoint = start;
            startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
        }
        if (end instanceof Float64Array) {
            endPoint = this.geoPointCache[0].setFromCartesian(end);
            endVec = end;
        }
        else {
            endPoint = end;
            endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
        }
        const startLat = startPoint.lat;
        const startLon = startPoint.lon;
        const endLat = endPoint.lat;
        const endLon = endPoint.lon;
        const startProjected = projection.project(start, this.vec2Cache[0]);
        const endProjected = projection.project(end, this.vec2Cache[1]);
        const startX = startProjected[0];
        const startY = startProjected[1];
        const endX = endProjected[0];
        const endY = endProjected[1];
        this.startVector.point.set(startLat, startLon);
        Vec2Math.copy(startProjected, this.startVector.projected);
        handler(this.startVector);
        this.state.index = 1;
        this.state.prevX = startX;
        this.state.prevY = startY;
        this.state.vectorType = 'line';
        const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
        this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
        if (depth >= this.maxDepth) {
            return state;
        }
        const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
        const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
        const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
        if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
            return state;
        }
        const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
        const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
        const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
        const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
        const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
        const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
        const midProjected = projection.project(midPoint, this.vec2Cache[2]);
        const lat0 = midPoint.lat;
        const lon0 = midPoint.lon;
        const x0 = midVec[0];
        const y0 = midVec[1];
        const z0 = midVec[2];
        const projX0 = midProjected[0];
        const projY0 = midProjected[1];
        const A = projX2 - projX1;
        const B = projY2 - projY1;
        const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
        const D = projX0 - projX1;
        const E = projY0 - projY1;
        const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
        // Calculate the Douglas-Peucker metric
        const det = 2 * (A * E - B * D);
        const dpDisSq = (det * det / 4) / deltaProjectedDot;
        if (dpDisSq > this.dpTolSq) {
            // Attempt to model the projected path with an arc
            // Find the center of circle containing the arc passing through the projected start, end, and mid points.
            const arcCenterX = (B * F - C * E) / det;
            const arcCenterY = (C * D - A * F) / det;
            const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
            const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
            const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
            const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
            state.vectorType = 'arc';
            state.arcCenterX = arcCenterX;
            state.arcCenterY = arcCenterY;
            state.arcRadius = arcRadius;
            state.isArcCounterClockwise = cross[2] > 0;
        }
        else {
            state.vectorType = 'line';
        }
        const cosDistance = Vec3Math.dot(startVec, midVec);
        if (cosDistance > this.cosMinDistance) { // cosine of distance increases with decreasing distance
            // We are below the minimum distance required to continue resampling -> decide if we need to continue or if
            // the path can satisfactorily be modeled as either a straight line or a circular arc.
            if (state.vectorType === 'line') {
                // The path can be modeled as a line.
                return state;
            }
            // To find whether the path can be modeled as an arc, we need to project the one-quarter and three-quarter points
            // along the path and find the projected points' distances from the arc modeled above. If the distances are
            // within the D-P tolerance, then the path can be modeled as an arc.
            const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
            const projectedQuery = projection.project(query, this.vec2Cache[0]);
            let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
            if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
                projection.project(query, projectedQuery);
                distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
                if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                    return state;
                }
            }
        }
        state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
        this.callHandler(handler, lat0, lon0, projX0, projY0, state);
        state.index++;
        state.prevX = projX0;
        state.prevY = projY0;
        return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    callHandler(handler, lat, lon, projX, projY, state) {
        let vector;
        if (state.vectorType === 'line') {
            vector = this.lineVector;
        }
        else {
            vector = this.arcVector;
            Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
            vector.projectedArcRadius = state.arcRadius;
            vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
            vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
            if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
                vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
            }
        }
        vector.point.set(lat, lon);
        Vec2Math.set(projX, projY, vector.projected);
        vector.index = state.index;
        handler(vector);
    }
}

/**
 * The possible reference norths for navigation angle units.
 */
var NavAngleUnitReferenceNorth;
(function (NavAngleUnitReferenceNorth) {
    NavAngleUnitReferenceNorth["True"] = "true";
    NavAngleUnitReferenceNorth["Magnetic"] = "magnetic";
})(NavAngleUnitReferenceNorth || (NavAngleUnitReferenceNorth = {}));
/**
 * A navigation angle unit, which is a measure of angular degrees relative to either true or magnetic north.
 *
 * Unlike most other unit types, each instance of navigation angle unit contains state specific to that instance,
 * namely the location used to retrieve magnetic variation for conversions. Therefore, it is generally recommended
 * not to re-use the same NavAngleUnit instance to instantiate multiple NumberUnits.
 *
 * Conversions use the location of the NavAngleUnit instance whose conversion method is called; this also means that
 * when using `NumberUnit.asUnit()`, the location of the unit of the NumberUnit whose `asUnit()` method was called
 * will be used.
 */
class NavAngleUnit extends AbstractUnit {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(type, arg1, arg2) {
        super(type === NavAngleUnitReferenceNorth.True ? 'true bearing' : 'magnetic bearing');
        /** @inheritdoc */
        this.family = NavAngleUnit.FAMILY;
        /** This location used to retrieve magnetic variation for conversions related to this unit. */
        this.location = new GeoPoint(0, 0);
        typeof arg1 === 'number' ? this.location.set(arg1, arg2) : this.location.set(arg1);
    }
    /**
     * Checks whether this nav angle unit is relative to magnetic north.
     * @returns Whether this nav angle unit is relative to magnetic north.
     */
    isMagnetic() {
        return this.name === 'magnetic bearing';
    }
    /**
     * Converts a value of this unit to another unit. This unit's location is used for the conversion.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        if (!isFinite(value)) {
            return NaN;
        }
        if (toUnit.name === this.name) {
            return value;
        }
        return this.isMagnetic() ? MagVar.magneticToTrue(value, this.location) : MagVar.trueToMagnetic(value, this.location);
    }
    /**
     * Converts a value of another unit to this unit. This unit's location is used for the conversion.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        if (!isFinite(value)) {
            return NaN;
        }
        if (fromUnit.name === this.name) {
            return value;
        }
        return this.isMagnetic() ? MagVar.trueToMagnetic(value, this.location) : MagVar.magneticToTrue(value, this.location);
    }
    /** @inheritdoc */
    equals(other) {
        return other instanceof NavAngleUnit && this.name === other.name && this.location.equals(other.location);
    }
    /**
     * Creates an instance of NavAngleUnit. The location of the unit is initialized to {0 N, 0 E}.
     * @param isMagnetic Whether the new unit is relative to magnetic north.
     * @returns An instance of NavAngleUnit.
     */
    static create(isMagnetic) {
        return new NavAngleUnit(isMagnetic ? NavAngleUnitReferenceNorth.Magnetic : NavAngleUnitReferenceNorth.True, 0, 0);
    }
}
NavAngleUnit.FAMILY = 'navangle';

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/**
 * An event bus consumer for a specific topic.
 */
class Consumer {
    /**
     * Creates an instance of a Consumer.
     * @param bus The event bus to subscribe to.
     * @param topic The topic of the subscription.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(bus, topic, state = {}, currentHandler) {
        this.bus = bus;
        this.topic = topic;
        this.state = state;
        this.currentHandler = currentHandler;
        this.activeSubs = new Map();
    }
    /**
     * Handles an event using the provided event handler.
     * @param handler The event handler for the event.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns A new subscription for the provided handler.
     */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.bus.on(this.topic, activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /**
     * Disables handling of the event.
     * @param handler The handler to disable.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.handle()` to manage subscriptions.
     */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /**
     * Caps the event subscription to a specified frequency, in Hz.
     * @param frequency The frequency, in Hz, to cap to.
     * @param immediateFirstPublish Whether to fire once immediately before throttling.
     * @returns A new consumer with the applied frequency filter.
     */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new Consumer(this.bus, this.topic, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /**
     * Quantizes the numerical event data to consume only at the specified decimal precision.
     * @param precision The decimal precision to snap to.
     * @returns A new consumer with the applied precision filter.
     */
    withPrecision(precision) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (currentValueAtPrecision !== state.lastValue) {
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /**
     * Filter the subscription to consume only when the value has changed by a minimum amount.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChangedBy(amount) {
        return new Consumer(this.bus, this.topic, { lastValue: 0 }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (diff >= amount) {
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /**
     * Filter the subscription to consume only if the value has changed. At all.  Really only
     * useful for strings or other events that don't change much.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChanged() {
        return new Consumer(this.bus, this.topic, { lastValue: '' }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (state.lastValue !== data) {
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /**
     * Filters events by time such that events will not be consumed until a minimum duration
     * has passed since the previous event.
     * @param deltaTime The minimum delta time between events.
     * @returns A new consumer with the applied change threshold filter.
     */
    onlyAfter(deltaTime) {
        return new Consumer(this.bus, this.topic, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link Consumer}.
 */
class ConsumerSubscription {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new Consumer(this.bus, topic);
    }
}

/// <reference types="msfstypes/JS/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useCoherentEventSync Whether or not to use coherent event sync (optional, default false)
     */
    constructor(useCoherentEventSync) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        const syncFunc = useCoherentEventSync ? EventBusCoherentSync : EventBusFlowEventSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        this.syncEvent('event_bus', 'resync_request', false);
        this.on('event_bus', (data) => {
            if (data == 'resync_request') {
                this.resyncEvents();
            }
        });
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubsciberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 100),
                    data: this.dataPackageQueue
                };
                this.executeSync(syncDataPackage);
                this.dataPackageQueue.length = 0;
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? JSON.parse(data.data) : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = JSON.stringify(data);
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';

/**
 * A PublishPacer that only allows publishing on an interval.
 */
/**
 * A PublishPacer that only allows publishing when a value has changed
 * by a specifed amount from the prior publish.
 */
class DeltaPacer {
    /**
     * Create a DeltaPacer.
     * @param delta The difference required for publishing to be allowed.
     */
    constructor(delta) {
        this.lastPublished = new Map();
        this.delta = delta;
    }
    /**
     * Determine whether the data can be published based on its delta from the
     * pror publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canPublish(topic, data) {
        const prior = this.lastPublished.get(topic);
        if (prior && Math.abs(data - prior) < this.delta) {
            return false;
        }
        this.lastPublished.set(topic, data);
        return true;
    }
}

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced via local storage.
     * @param isCached Whether or not the event should be cached.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer = undefined) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const simvar of this.simvars.keys()) {
            if (bus.getTopicSubsciberCount(simvar)) {
                this.subscribed.add(simvar);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.simvars.get(event)) {
                this.subscribed.add(event);
            }
        });
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Read the value of a given simvar by its key.
     * @param key The key of the simvar in simVarMap
     * @returns The value returned by SimVar.GetSimVarValue()
     */
    getValue(key) {
        const simvar = this.simvars.get(key);
        if (simvar === undefined) {
            return undefined;
        }
        return SimVar.GetSimVarValue(simvar.name, simvar.type);
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const data of this.subscribed.values()) {
            const value = this.getValue(data);
            if (value !== undefined) {
                this.publish(data, value);
            }
        }
    }
    /**
     * Change the simvar read for a given key.
     * @param key The key of the simvar in simVarMap
     * @param value The new value to set the simvar to.
     */
    updateSimVarSource(key, value) {
        this.simvars.set(key, value);
    }
}

/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Bool"] = "Bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["String"] = "string";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["Volts"] = "Volts";
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["Enum"] = "Enum";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
})(SimVarValueType || (SimVarValueType = {}));

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** The kind of data to return. */
var CompositeLogicXMLValueType;
(function (CompositeLogicXMLValueType) {
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"] = 0] = "Any";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"] = 1] = "Number";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"] = 2] = "String";
})(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
/**
 *
 */
class CompositeLogicXMLHost {
    constructor() {
        this.anyHandlers = new Array();
        this.stringHandlers = new Array();
        this.numberHandlers = new Array();
        this.anyResultCache = new Array();
        this.stringResultCache = new Array();
        this.numberResultCache = new Array();
        this.context = new LogicXMLContext();
        this.isPaused = false;
    }
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused) {
        this.isPaused = isPaused;
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
        this.anyHandlers.push({ logic: logic, handler: handler });
        return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision, smoothFactor) {
        this.numberHandlers.push({ logic: logic, handler: handler, precision: precision, smoothFactor: smoothFactor });
        return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
        this.stringHandlers.push({ logic: logic, handler: handler });
        return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
        const func = new LogicXMLFunction();
        func.name = funcSpec.name;
        func.callback = funcSpec.logic;
        this.context.addFunction(func);
        return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime) {
        if (!this.isPaused) {
            for (let i = 0; i < this.anyHandlers.length; i++) {
                const newVal = this.anyHandlers[i].logic.getValue(this.context);
                if (newVal !== this.anyResultCache[i]) {
                    this.anyResultCache[i] = newVal;
                    this.anyHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.stringHandlers.length; i++) {
                const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
                if (newVal !== this.stringResultCache[i]) {
                    this.stringResultCache[i] = newVal;
                    this.stringHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.numberHandlers.length; i++) {
                let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
                let precision = this.numberHandlers[i].precision;
                if (precision !== undefined) {
                    precision = Math.pow(10, precision);
                    newVal = Math.round(newVal * precision) / precision;
                }
                if (this.numberHandlers[i].smoothFactor !== undefined && this.numberHandlers[i].smoothFactor !== 0) {
                    // A smoothFactor of 0 means no smoothing.  We don't trigger this update if the factor is
                    // undefined or 0, but typescript still thinks is could be undefined due to the array indexing.
                    // The 'or-0' here is just to get around that without having to do a temporary assignment.
                    newVal = Utils.SmoothLinear(this.numberResultCache[i], newVal, this.numberHandlers[i].smoothFactor || 0, deltaTime);
                }
                if (newVal !== this.numberResultCache[i]) {
                    this.numberResultCache[i] = newVal;
                    this.numberHandlers[i].handler(newVal);
                }
            }
            this.context.update();
        }
    }
}

/// <reference types="msfstypes/JS/dataStorage" />
/* eslint-disable no-inner-declarations */
// eslint-disable-next-line @typescript-eslint/no-namespace
var DataStore;
(function (DataStore) {
    /**
     * Writes a keyed value to the data store.
     * @param key A key.
     * @param value The value to set.
     */
    function set(key, value) {
        SetStoredData(key, JSON.stringify(value));
    }
    DataStore.set = set;
    /**
     * Retrieves a keyed value from the data store.
     * @param key A key.
     * @returns the value stored under the key, or undefined if one could not be retrieved.
     */
    function get(key) {
        try {
            const string = GetStoredData(key);
            return JSON.parse(string);
        }
        catch (e) {
            return undefined;
        }
    }
    DataStore.get = get;
    /**
     * Removes a key from the data store.
     * @param key The key to remove.
     */
    function remove(key) {
        DeleteStoredData(key);
    }
    DataStore.remove = remove;
})(DataStore || (DataStore = {}));

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isDestroyed = true;
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                this.gameState.set(GameState[attribute]);
                return;
            }
        }
        this.gameState.set(undefined);B
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/// <reference types="msfstypes/JS/Simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Gets whether an icao is a facility type.
     * @param icao The icao to get the facility type for.
     * @returns a bool whether or not this icao is a facility type.
     */
    static isFacility(icao) {
        switch (icao[0]) {
            case 'A':
            case 'W':
            case 'V':
            case 'N':
            case 'U':
            case 'R':
            case 'S':
                return true;
        }
        return false;
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            startThresholdLength: 0,
            endThresholdLength: 0
        };
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                startThresholdLength,
                endThresholdLength
            });
        }
        return splitRunways;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        return `R  ${airport.icao.substr(7, 4)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway based on its surface type.
     * @param runway An {@link AirportRunway}.
     * @returns The surface category of that runway.
     */
    static getSurfaceCategory(runway) {
        if (this.SURFACES_HARD.includes(runway.surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(runway.surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(runway.surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * Types of airspaces.
 */
var AirspaceType;
(function (AirspaceType) {
    AirspaceType[AirspaceType["None"] = 0] = "None";
    AirspaceType[AirspaceType["Center"] = 1] = "Center";
    AirspaceType[AirspaceType["ClassA"] = 2] = "ClassA";
    AirspaceType[AirspaceType["ClassB"] = 3] = "ClassB";
    AirspaceType[AirspaceType["ClassC"] = 4] = "ClassC";
    AirspaceType[AirspaceType["ClassD"] = 5] = "ClassD";
    AirspaceType[AirspaceType["ClassE"] = 6] = "ClassE";
    AirspaceType[AirspaceType["ClassF"] = 7] = "ClassF";
    AirspaceType[AirspaceType["ClassG"] = 8] = "ClassG";
    AirspaceType[AirspaceType["Tower"] = 9] = "Tower";
    AirspaceType[AirspaceType["Clearance"] = 10] = "Clearance";
    AirspaceType[AirspaceType["Ground"] = 11] = "Ground";
    AirspaceType[AirspaceType["Departure"] = 12] = "Departure";
    AirspaceType[AirspaceType["Approach"] = 13] = "Approach";
    AirspaceType[AirspaceType["MOA"] = 14] = "MOA";
    AirspaceType[AirspaceType["Restricted"] = 15] = "Restricted";
    AirspaceType[AirspaceType["Prohibited"] = 16] = "Prohibited";
    AirspaceType[AirspaceType["Warning"] = 17] = "Warning";
    AirspaceType[AirspaceType["Alert"] = 18] = "Alert";
    AirspaceType[AirspaceType["Danger"] = 19] = "Danger";
    AirspaceType[AirspaceType["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType[AirspaceType["ModeC"] = 21] = "ModeC";
    AirspaceType[AirspaceType["Radar"] = 22] = "Radar";
    AirspaceType[AirspaceType["Training"] = 23] = "Training";
    AirspaceType[AirspaceType["Max"] = 24] = "Max";
})(AirspaceType || (AirspaceType = {}));

/**
 * A viewlistener that gets autopilot mode information.
 */
var MSFSAPStates;
(function (MSFSAPStates) {
    MSFSAPStates[MSFSAPStates["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates[MSFSAPStates["APOn"] = 2] = "APOn";
    MSFSAPStates[MSFSAPStates["FDOn"] = 4] = "FDOn";
    MSFSAPStates[MSFSAPStates["FLC"] = 8] = "FLC";
    MSFSAPStates[MSFSAPStates["Alt"] = 16] = "Alt";
    MSFSAPStates[MSFSAPStates["AltArm"] = 32] = "AltArm";
    MSFSAPStates[MSFSAPStates["GS"] = 64] = "GS";
    MSFSAPStates[MSFSAPStates["GSArm"] = 128] = "GSArm";
    MSFSAPStates[MSFSAPStates["Pitch"] = 256] = "Pitch";
    MSFSAPStates[MSFSAPStates["VS"] = 512] = "VS";
    MSFSAPStates[MSFSAPStates["Heading"] = 1024] = "Heading";
    MSFSAPStates[MSFSAPStates["Nav"] = 2048] = "Nav";
    MSFSAPStates[MSFSAPStates["NavArm"] = 4096] = "NavArm";
    MSFSAPStates[MSFSAPStates["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates[MSFSAPStates["Attitude"] = 16384] = "Attitude";
    MSFSAPStates[MSFSAPStates["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates[MSFSAPStates["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates[MSFSAPStates["ATArm"] = 131072] = "ATArm";
    MSFSAPStates[MSFSAPStates["YD"] = 262144] = "YD";
    MSFSAPStates[MSFSAPStates["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates[MSFSAPStates["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates[MSFSAPStates["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates[MSFSAPStates["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates[MSFSAPStates["Bank"] = 8388608] = "Bank";
    MSFSAPStates[MSFSAPStates["FBW"] = 16777216] = "FBW";
    MSFSAPStates[MSFSAPStates["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates[MSFSAPStates["None"] = -2147483648] = "None";
})(MSFSAPStates || (MSFSAPStates = {}));

/// <reference types="msfstypes/JS/common" />
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => this.onInitialized(), 2000);
            }, true);
        }
        else {
            setTimeout(() => this.onInitialized(), 2000);
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        const currentTime = Date.now();
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                const cachedFac = cache.get(icao);
                if (cachedFac === undefined) {
                    Coherent.call(type, icao).then((isValid) => {
                        if (!isValid) {
                            rejection(`Facility ${icao} could not be found.`);
                            FacilityLoader.requestQueue.delete(icao);
                        }
                    });
                }
                else {
                    resolve(cachedFac);
                }
            });
            if (request) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            FacilityLoader.requestQueue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
                return this.startRepoNearestSearchSession(type);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestUserFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The max number of matches to return.
     * @returns A collection of matched ICAOs.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        const results = await Coherent.call('SEARCH_BY_IDENT', ident, filter, maxItems);
        if (filter === FacilitySearchType.User || filter === FacilitySearchType.All) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, FacilityLoader.facRepositorySearchTypes);
        }
        return results;
    }
    /** Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The max number of matches to return.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const request = FacilityLoader.requestQueue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W');
            FacilityLoader.requestQueue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = [FacilityType.USR];
FacilityLoader.repoSearchSessionId = -1;
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
}
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask);
    }
}
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest user facilities.
 */
class NearestUserFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    get(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    first() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    last() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A k-dimensional search tree.
 */
class KdTree {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            const indexInArray = array.indexOf(index);
            if (indexInArray > 0) {
                array[indexInArray] = array[array.length - 1];
                array.length--;
            }
        }
        return true;
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        if (this.size === 0) {
            return;
        }
        // clear the tree structure
        this.nodes.length = 0;
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
class SortedMappedSubscribableArray extends AbstractSubscribableArray {
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(source, comparatorFunc, equalityFunc) {
        super();
        this.source = source;
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this.sorted = new SortedArray(this.comparatorFunc, this.equalityFunc);
        this.sourceSub = source.sub(this.onSourceChanged.bind(this), true);
    }
    /** @inheritdoc */
    get length() {
        return this.sorted.length;
    }
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, comparatorFunc, equalityFunc) {
        return new SortedMappedSubscribableArray(source, comparatorFunc, equalityFunc);
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
        switch (type) {
            case SubscribableArrayEventType.Cleared:
                if (this.sorted.length !== 0) {
                    this.sorted.clear();
                    this.notify(0, SubscribableArrayEventType.Cleared);
                }
                break;
            case SubscribableArrayEventType.Added:
                if (item) {
                    this.insert(item);
                }
                break;
            case SubscribableArrayEventType.Removed:
                if (item) {
                    this.remove(item);
                }
                break;
        }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
        if (this.sorted.length === 0) {
            // since we know all elements will be added to one contiguous index range, we can do a small optimization here
            // with notifications
            elements instanceof Array ? this.sorted.insertAll(elements) : this.sorted.insert(elements);
            this.notify(0, SubscribableArrayEventType.Added, elements instanceof Array ? this.sorted.array : elements);
        }
        else {
            const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
            const len = sorted.length;
            for (let i = 0; i < len; i++) {
                const toInsert = sorted[i];
                this.notify(this.sorted.insert(toInsert), SubscribableArrayEventType.Added, toInsert);
            }
        }
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
        const sorted = elements instanceof Array ? Array.from(elements).sort(this.comparatorFunc) : [elements];
        const len = sorted.length;
        for (let i = 0; i < len; i++) {
            const toRemove = sorted[i];
            const removedIndex = this.sorted.remove(toRemove);
            if (removedIndex >= 0) {
                this.notify(removedIndex, SubscribableArrayEventType.Removed, toRemove);
            }
        }
    }
    /** @inheritdoc */
    getArray() {
        return this.sorted.array;
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
        this.sourceSub.destroy();
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType[FacilityRepositorySyncType["Add"] = 0] = "Add";
    FacilityRepositorySyncType[FacilityRepositorySyncType["Remove"] = 1] = "Remove";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpRequest"] = 2] = "DumpRequest";
    FacilityRepositorySyncType[FacilityRepositorySyncType["DumpResponse"] = 3] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.repos = {};
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc)
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        this.pubSyncEvent(FacilityRepositorySyncType.DumpRequest);
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos[ICAO.getFacilityType(icao)]) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one.
     * @param fac The facility to add.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.addToRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Add, [fac]);
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove.
     */
    remove(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            return;
        }
        this.removeFromRepo(fac);
        this.pubSyncEvent(FacilityRepositorySyncType.Remove, [fac]);
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        const keys = types !== null && types !== void 0 ? types : Object.keys(this.repos);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            (_a = this.repos[keys[i]]) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        var _a;
        var _b;
        const facilityType = ICAO.getFacilityType(fac.icao);
        ((_a = (_b = this.repos)[facilityType]) !== null && _a !== void 0 ? _a : (_b[facilityType] = new Map())).set(fac.icao, fac);
        if (facilityType !== FacilityType.USR) {
            return;
        }
        this.trees[facilityType].insert(fac);
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove.
     */
    removeFromRepo(fac) {
        var _a;
        const facilityType = ICAO.getFacilityType(fac.icao);
        (_a = this.repos[ICAO.getFacilityType(fac.icao)]) === null || _a === void 0 ? void 0 : _a.delete(fac.icao);
        if (facilityType !== FacilityType.USR) {
            return;
        }
        this.trees[facilityType].remove(fac);
    }
    /**
     * Publishes a sync event over the event bus.
     * @param type The type of sync event.
     * @param facs The event's user facilities.
     */
    pubSyncEvent(type, facs) {
        this.ignoreSync = true;
        this.bus.pub(FacilityRepository.SYNC_TOPIC, { type, facs }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.Add:
            case FacilityRepositorySyncType.DumpResponse:
                data.facs.forEach(fac => this.addToRepo(fac));
                break;
            case FacilityRepositorySyncType.Remove:
                data.facs.forEach(fac => this.removeFromRepo(fac));
                break;
            case FacilityRepositorySyncType.DumpRequest:
                {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent(FacilityRepositorySyncType.DumpResponse, facs);
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A type map of search type to concrete facility loader query type.
 */
new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
]);
/**
 * A wrapper for a {@link NearestSearchSession} that automatically adjusts the number of
 * search results requested from the sim to minimize search load while still attempting to
 * provide the total number of results needed by the user.
 */
class AdaptiveNearestSubscription extends AbstractSubscribableArray {
    /**
     * Creates an instance of AdaptiveNearestSubscription.
     * @param subscription A {@link NearestSubscription} to use as our inner search.
     * @param absoluteMaxItems The maximum number of results to request in any search.
     */
    constructor(subscription, absoluteMaxItems) {
        super();
        this.subscription = subscription;
        this.absoluteMaxItems = absoluteMaxItems;
        /** The array that holds the results of our latest search. */
        this.facilities = ArraySubject.create();
        /**
         * This array provides a backing store for what is essentially a "virtual" array
         * representing the aggregate of our search results to the client. Since we need to
         * limit the number of results returned we will carefully manage notifications when
         * anything changes to only expose the requested number of elements.
         */
        this.shadowFacilities = SortedMappedSubscribableArray.create(this.facilities, (a, b) => this.pos.distance(a) - this.pos.distance(b), (a, b) => a.icao === b.icao);
        /** The number of items requested on the last call to update. */
        this.lastMaxRequested = 0;
        /** The number of items we are requesting from the inner search to meet current demands. */
        this.derivedMaxItems = 0;
        /** Whether we have a search in progress already. */
        this.searchInProgress = false;
        /** A reusable GeoPoint for sorting by distance. */
        this.pos = new GeoPoint(0, 0);
        // When the search updates, this will cause our facilities array to be updated.
        this.subscription.sub(this.onSourceChanged.bind(this));
        // And this responds in changes to the facilities array via the mapping between the
        // two to send any managed notifications needed to our subscribers.
        this.shadowFacilities.sub(this.notifySubscribers.bind(this));
    }
    /** @inheritdoc */
    get length() {
        return this.shadowFacilities.length;
    }
    /** @inheritdoc */
    getArray() {
        return this.shadowFacilities.getArray();
    }
    /**
     * Whether or not the inner search has started.
     * @returns True if started, false otherwise.
     */
    get started() {
        return this.subscription.started;
    }
    /**
     * Start the inner search subscription.
     */
    async start() {
        return this.subscription.start();
    }
    /**
     * Cause the inner subscription to update.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    async update(lat, lon, radius, maxItems) {
        if (this.searchInProgress) {
            return;
        }
        this.searchInProgress = true;
        this.pos.set(lat, lon);
        // It would be unexpected for the max requested number of items to change, but the API
        // supports it so we're going to handle it anyway.  If it changes we need to automatically
        // grow or shrink the size of the virtual array we show our subscribers before further
        // processing search results.
        if (maxItems < this.lastMaxRequested) {
            // Remove existing results from the end to avoid indices shifting around.
            for (let i = this.shadowFacilities.length - 1; i >= maxItems; i--) {
                this.notify(i, SubscribableArrayEventType.Removed, this.shadowFacilities.get(i));
            }
        }
        else if (maxItems > this.lastMaxRequested) {
            // Be careful not to overflow shadowFacilities when adding new items.
            for (let i = this.lastMaxRequested; i < Math.min(maxItems, this.shadowFacilities.length); i++) {
                this.notify(i, SubscribableArrayEventType.Added, this.shadowFacilities.get(i));
            }
        }
        this.lastMaxRequested = maxItems;
        if (maxItems > this.derivedMaxItems) {
            this.derivedMaxItems = maxItems;
        }
        // When the subscription updates, any changes from airports added or removed cause
        // onSourceChanged below to trigger.   That will update our facilites store, because
        // it means the airport is no longer in the raw search data.
        await this.subscription.update(lat, lon, radius, this.derivedMaxItems);
        // If we have more returned facilities in our search than the user has asked for we
        // can begin a ramp-down of our search size.  Ramp down is less aggressive than
        // ramp up to avoid flapping between the two states.
        if (this.facilities.length > maxItems) {
            this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - (this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR)), maxItems);
        }
        else {
            // We have either exactly enough or too few facilities.  If we have too few, ramp
            // up our search size until we either have enough or hit the maximum allowed search
            // quantity.
            while (this.facilities.length < maxItems && this.derivedMaxItems < this.absoluteMaxItems) {
                this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), this.absoluteMaxItems);
                await this.subscription.update(lat, lon, radius, this.derivedMaxItems);
            }
        }
        this.searchInProgress = false;
    }
    /**
     * Responds to changes in our inner search and updates our facilities store accordingly.
     * @param index The index of the changed item.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
        if (type === SubscribableArrayEventType.Cleared) {
            this.facilities.clear();
            this.notify(0, SubscribableArrayEventType.Cleared);
            return;
        }
        if (item === undefined) {
            return;
        }
        // SubscribableArrayHandler uses a compound type for T, but NearestWaypointSubscription
        // should only ever send us a single item to add or remove.  We'll treat it as if that
        // were the only expected case to simplify the processing.
        if (item instanceof Array) {
            console.warn('AdaptiveNearestSubscription received unexpected type.');
            return;
        }
        switch (type) {
            case SubscribableArrayEventType.Added:
                this.facilities.insert(item);
                break;
            case SubscribableArrayEventType.Removed:
                this.facilities.removeItem(item);
                break;
        }
    }
    /**
     * Notify our subscribers of changes to the virtual search results.
     * @param index The index of the changed item.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    notifySubscribers(index, type, item) {
        // The subscriber doesn't care if the change is at an index above what they should see.
        if (index >= this.lastMaxRequested || item === undefined) {
            return;
        }
        // Since we iterate over individal items in onSourceChanged we should never have an array here.
        if (item instanceof Array && type !== SubscribableArrayEventType.Cleared) {
            console.warn('AdaptiveNearestSubscription: received array of items in a single notification');
        }
        this.notify(index, type, item);
        switch (type) {
            case SubscribableArrayEventType.Cleared:
                // NOOP
                break;
            case SubscribableArrayEventType.Added:
                // We've just added something.  If it's within the range of the virtual array, it will pop the last
                // item off the end of the array if one exists, so we send a remove notificaiton for that.
                if (index < this.lastMaxRequested && this.shadowFacilities.tryGet(this.lastMaxRequested) !== undefined) {
                    this.notify(this.lastMaxRequested, SubscribableArrayEventType.Removed, this.shadowFacilities.get(this.lastMaxRequested));
                }
                break;
            case SubscribableArrayEventType.Removed:
                // If we've removed an item within the range of the virtual array it will leave a vacant spot at the
                // end.  If there's something we can put there we need to do that.
                if (index < this.lastMaxRequested && this.shadowFacilities.tryGet(this.lastMaxRequested - 1) !== undefined) {
                    this.notify(this.lastMaxRequested - 1, SubscribableArrayEventType.Added, this.shadowFacilities.get(this.lastMaxRequested - 1));
                }
        }
    }
}
AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;

[new GeoCircle(new Float64Array(3), 0)];
new BinaryHeap((a, b) => b.distanceToFarthestVector - a.distanceToFarthestVector);

/**
 * A task queue backed by an array.
 */
class ArrayTaskQueue {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
        this.tasks = tasks;
        this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
        return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
        return this.tasks[this.head++];
    }
}

/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
class ThrottledTaskQueueProcess {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
        this.queue = queue;
        this.handler = handler;
        this._hasStarted = false;
        this._hasEnded = false;
        this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
        return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
        return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
        this._hasStarted = true;
        this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
        let dispatchCount = 0;
        const t0 = performance.now();
        while (!this._shouldAbort && this.queue.hasNext()) {
            if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
                const task = this.queue.next();
                task();
                dispatchCount++;
            }
            else {
                break;
            }
        }
        if (this._shouldAbort) {
            return;
        }
        if (!this.queue.hasNext()) {
            this.handler.onFinished(elapsedFrameCount);
            this._hasEnded = true;
        }
        else {
            this.handler.onPaused(elapsedFrameCount);
            requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
        }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
        if (this._hasStarted && !this._hasEnded) {
            this.handler.onAborted();
            this._shouldAbort = true;
            this._hasEnded = true;
        }
    }
}

/**
 * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
 */
class NearestLodBoundarySearchSession {
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache, session, frameBudget) {
        this.cache = cache;
        this.session = session;
        this.frameBudget = frameBudget;
    }
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    async searchNearest(lat, lon, radius, maxItems) {
        const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
        const results = { added: [], removed: facilityResults.removed };
        const tasks = facilityResults.added.map((fac, index) => () => { results.added[index] = this.cache.get(fac); });
        await new Promise(resolve => {
            const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
            taskQueue.start();
        });
        return results;
    }
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask) {
        this.session.setBoundaryFilter(classMask);
    }
}
/**
 * A throttled task queue handler for retrieving and creating new LodBoundary objects in response to a nearest search.
 */
class NearestLodBoundarySearchTaskQueueHandler {
    /**
     * Constructor.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     * @param resolve The Promise resolve function this handler will call when the task queue is finished.
     */
    constructor(frameBudget, resolve) {
        this.frameBudget = frameBudget;
        this.resolve = resolve;
    }
    /** @inheritdoc */
    onStarted() {
        // noop
    }
    /** @inheritdoc */
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
        return timeElapsed < this.frameBudget;
    }
    /** @inheritdoc */
    onPaused() {
        // noop
    }
    /** @inheritdoc */
    onFinished() {
        this.resolve();
    }
    /** @inheritdoc */
    onAborted() {
        // noop
    }
}

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 4] = "HoldInboundLeg";
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 8] = "HoldOutboundLeg";
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 16] = "HoldDirectEntry";
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 32] = "HoldTeardropEntry";
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 64] = "HoldParallelEntry";
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 128] = "CourseReversal";
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 256] = "LegToLegTurn";
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 512] = "AnticipatedTurn";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction */
        this.originRunway = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /**
         * The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction
         */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
var SpeedType;
(function (SpeedType) {
    SpeedType[SpeedType["IAS"] = 0] = "IAS";
    SpeedType[SpeedType["MACH"] = 1] = "MACH";
})(SpeedType || (SpeedType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (typeof end === 'number') {
            if (Math.abs(end) >= MathUtils.TWO_PI - tolerance) {
                return true;
            }
            let angle = circle.angleAlong(start, pos, Math.PI);
            if (angle > MathUtils.TWO_PI - tolerance) {
                angle = 0;
            }
            return (angle - end) * (end >= 0 ? 1 : -1) < tolerance;
        }
        else {
            const alongArcNorm = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, pos, tolerance);
            return isFinite(alongArcNorm) && alongArcNorm >= -tolerance && alongArcNorm <= 1 + tolerance;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const vectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[1].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            if (!ingressEnd.equals(vectorEnd)) {
                const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
                FlightPathUtils.setCircleVector((_a = vectors[vectorIndex]) !== null && _a !== void 0 ? _a : (vectors[vectorIndex] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
                vectorIndex++;
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_b = vectors[vectorIndex]) !== null && _b !== void 0 ? _b : (vectors[vectorIndex] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            vectorIndex++;
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                if (!egressStart.equals(egressJoinVectorStart)) {
                    const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                    FlightPathUtils.setCircleVector((_c = vectors[vectorIndex]) !== null && _c !== void 0 ? _c : (vectors[vectorIndex] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    vectorIndex++;
                }
            }
            else {
                Object.assign((_d = vectors[vectorIndex]) !== null && _d !== void 0 ? _d : (vectors[vectorIndex] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                vectorIndex++;
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths to connect two geo circles.
 */
class ConnectCirclesBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @param fromCircleVectorFlags The flags to set on the vector along `fromCircle`. Defaults to none (0).
     * @param toCircleVectorFlags The flags to set on the vector along the `toCircle`. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector connecting `fromCircle` to `toCircle`. Defaults to none
     * (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, fromCircle, toCircle, radius, from, to, fromCircleVectorFlags = 0, toCircleVectorFlags = 0, connectVectorFlags = 0) {
        if (radius === 0) {
            return 0;
        }
        const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
        if ((angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius)
            || (Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE)) {
            return 0;
        }
        if (from && !(from instanceof Float64Array)) {
            from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
        }
        if (to && !(to instanceof Float64Array)) {
            to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
        }
        const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
        const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
        if (!joinCircle) {
            return 0;
        }
        let vectorIndex = index;
        const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
        const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
        if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart, fromCircleVectorFlags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd, connectVectorFlags);
        if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to, toCircleVectorFlags);
        }
        return vectorIndex - index;
    }
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
        /*
         * Theory: the locus of all centers of circle of radius r tangent to circle with center C and radius R is
         * equivalent to the set of circles S(C) with center C and positive radius |r +/- R|. If we further restrict the
         * set of tangent circles to those where both the original and tangent circle run in the same direction at the
         * tangent point, the locus of centers can be further reduced to the single circle Sd(C) with center C and
         * positive radius |r - R|. Therefore, to find the centers of the circles of radius r connecting the circles C1 and
         * C2, we need only find the intersections of Sd(C1) and Sd(C2).
         */
        const solutions = [];
        const intersections = ConnectCirclesBuilder.intersectionCache;
        const leftTurnRadius = radius;
        let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
        let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
        let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
        let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
        const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numLeftTurnSolutions === 1) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        }
        else if (numLeftTurnSolutions === 2) {
            solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
            solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
        }
        if (radius !== Math.PI / 2) {
            const rightTurnRadius = Math.PI - radius;
            fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
            toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
            fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
            toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
            const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
            if (numRightTurnSolutions === 1) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
            }
            else if (numRightTurnSolutions === 2) {
                solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
                solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
            }
        }
        if (solutions.length === 0) {
            return null;
        }
        else if (solutions.length === 1) {
            return out.set(solutions[0].center, solutions[0].radius);
        }
        else {
            // choose the solution that results in the shortest path from fromVec to toVec
            let circle = solutions[0];
            let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
            for (let i = 1; i < solutions.length; i++) {
                const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
                if (distance < minDistance) {
                    circle = solutions[i];
                    minDistance = distance;
                }
            }
            return out.set(circle.center, circle.radius);
        }
    }
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
        let distance = 0;
        const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
        const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
        if (from) {
            distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
        }
        distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
        if (to) {
            distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
        }
        return distance;
    }
}
ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great circle paths to final great circle paths via a turn starting at the start
 * point and a turn ending at the end point, connected by a great-circle path.
 */
class TurnToJoinGreatCircleAtPointBuilder {
    constructor() {
        this.connectCirclesBuilder = new ConnectCirclesBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * connects with another turn via a great-circle path to terminate at a defined end point and final course.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters.
     * @param endTurnDirection The direction of the final turn.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector along the great-circle path connecting the turns.
     * Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, end, endPath, endTurnRadius, endTurnDirection, startTurnVectorFlags = 0, endTurnVectorFlags = 0, connectVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[1]);
        }
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        const startTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
        const startTurnCircleRadiusRad = startTurnDirection === 'left' ? startTurnRadiusRad : Math.PI - startTurnRadiusRad;
        const startTurnCircleCenter = startTurnOffsetPath.offsetDistanceAlong(start, startTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
        const startTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].set(startTurnCircleCenter, startTurnCircleRadiusRad);
        const endTurnRadiusRad = UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        const endTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
        const endTurnCircleRadiusRad = endTurnDirection === 'left' ? endTurnRadiusRad : Math.PI - endTurnRadiusRad;
        const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
        const endTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
        return this.connectCirclesBuilder.build(vectors, index, startTurnCircle, endTurnCircle, undefined, start, end, startTurnVectorFlags, endTurnVectorFlags, connectVectorFlags);
    }
}
TurnToJoinGreatCircleAtPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleAtPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.connectCirclesBuilder = new ConnectCirclesBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.turnToJoinGreatCircleAtPointBuilder = new TurnToJoinGreatCircleAtPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. False by default.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, intersection, flags = 0, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoPoint.EQUALITY_TOLERANCE ? -1
            : intersectionToStartDot > GeoPoint.EQUALITY_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoPoint.EQUALITY_TOLERANCE ? -1
            : intersectionToEndDot > GeoPoint.EQUALITY_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn || desiredTurnDirection === towardEndPointTurnDirection;
                    needCalculateOneTurnPath = !needCalculateTwoTurnPath;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoPoint.EQUALITY_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoPoint.EQUALITY_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else if (!preferSingleTurn) {
                        // The start point lies after the required turn start point to minimize the flight path distance, so we
                        // will make a turn immediately and connect it with another turn to join the final path at the end point.
                        vectorIndex += this.turnToJoinGreatCircleAtPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, desiredTurnDirection, end, endPath, minTurnRadius, desiredTurnDirection, 0, turnFlags);
                    }
                    else {
                        needCalculateOneTurnPath = true;
                    }
                }
                else {
                    // The start and end paths intersect at an angle > 90 degrees.
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            if ((desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection)
                && intersectionStartOffset <= GeoPoint.EQUALITY_TOLERANCE
                && !preferSingleTurn) {
                // Attempt a "side step".
                const endTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(end, endPath.center);
                const endTurnCircleRadiusRad = towardEndPointTurnDirection === 'right' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
                const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                const endTurnCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
                const startTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[2].setAsGreatCircle(start, startPath.center);
                const startTurnCenter = startTurnOffsetPath.offsetDistanceAlong(start, minTurnRadiusRad * (towardEndPointTurnDirection === 'left' ? 1 : -1), JoinGreatCircleToPointBuilder.vec3Cache[4]);
                if (Math.abs(endTurnCircle.distance(startTurnCenter)) >= minTurnRadiusRad - GeoPoint.EQUALITY_TOLERANCE) {
                    const startTurnCircle = FlightPathUtils.getTurnCircle(startTurnCenter, minTurnRadiusRad, towardEndPointTurnDirection, JoinGreatCircleToPointBuilder.geoCircleCache[2]);
                    vectorIndex += this.connectCirclesBuilder.build(vectors, vectorIndex, startTurnCircle, endTurnCircle, undefined, start, end, flags, turnFlags, flags);
                }
                else {
                    needCalculateTwoTurnPath = true;
                }
            }
            else if (desiredTurnDirection !== undefined && desiredTurnDirection !== towardEndPointTurnDirection) {
                needCalculateTwoTurnPath = true;
            }
            else {
                needCalculateTwoTurnPath = !preferSingleTurn;
                needCalculateOneTurnPath = preferSingleTurn;
            }
        }
        if (needCalculateTwoTurnPath) {
            // Calculate a flight path which begins with an initial turn from the start path connected by a great-circle
            // path to a final turn to join the end path at the end point.
            desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (desiredTurnDirection = towardEndPointTurnDirection);
            let turnStartIntersectionOffset = 0;
            let endTurnDirection;
            let needMoveStartTurn = false;
            if (isEndForwardOfIntersection && desiredTurnDirection === towardEndPointTurnDirection) {
                endTurnDirection = towardEndPointTurnDirection === 'left' ? 'right' : 'left';
                turnStartIntersectionOffset = intersectionStartOffset;
                needMoveStartTurn = intersectionEndOffset < minD;
            }
            else {
                // Attempt to place the start of the first turn at either the start point or the intersection point between
                // the start and end paths, whichever one is farther along the start path.
                turnStartIntersectionOffset = Math.max(0, intersectionStartOffset);
                const isStartTurnInEndPathDirection = (desiredTurnDirection === towardEndPointTurnDirection) === isEndForwardOfIntersection;
                // Redefine minD to be the distance from the start/end path intersection point to the start of the minimum-radius
                // starting turn that is tangent to the end path.
                if (isStartTurnInEndPathDirection) {
                    minD = Math.asin(Math.tan(minTurnRadiusRad) * tanHalfTheta);
                    if (isNaN(minD)) {
                        minD = Infinity;
                    }
                }
                const endTurnDirectionThreshold = minD * (desiredTurnDirection === towardEndPointTurnDirection ? -1 : 1);
                endTurnDirection = ((towardEndPointTurnDirection === 'left')
                    === (turnStartIntersectionOffset < endTurnDirectionThreshold)
                    === isEndForwardOfIntersection)
                    ? 'left'
                    : 'right';
            }
            const endTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[0].setAsGreatCircle(end, endPath.center);
            const endTurnCircleRadiusRad = endTurnDirection === 'left' ? minTurnRadiusRad : Math.PI - minTurnRadiusRad;
            const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, JoinGreatCircleToPointBuilder.vec3Cache[3]);
            const endTurnCircle = JoinGreatCircleToPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
            const startTurnStart = turnStartIntersectionOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE
                ? startPath.offsetDistanceAlong(intersection, turnStartIntersectionOffset, JoinGreatCircleToPointBuilder.vec3Cache[3])
                : Vec3Math.copy(start, JoinGreatCircleToPointBuilder.vec3Cache[3]);
            const startTurnOffsetPath = JoinGreatCircleToPointBuilder.geoCircleCache[2].setAsGreatCircle(startTurnStart, startPath.center);
            const startTurnCenter = startTurnOffsetPath.offsetDistanceAlong(startTurnStart, minTurnRadiusRad * (desiredTurnDirection === 'left' ? 1 : -1), JoinGreatCircleToPointBuilder.vec3Cache[4]);
            if (!needMoveStartTurn) {
                if (Math.abs(endTurnCircle.distance(startTurnCenter)) < minTurnRadiusRad - GeoPoint.EQUALITY_TOLERANCE) {
                    // Start and end turn circles are secant.
                    if (desiredTurnDirection === endTurnDirection) {
                        // If start and end turns have the same direction, they can still be joined by a great-circle path,
                        // however we need to exclude cases in which this will lead to a sub-optimal path.
                        const turnCirclePathIntersections = JoinGreatCircleToPointBuilder.intersectionCache;
                        const numEndTurnCircleStartPathIntersections = endTurnCircle.intersection(startPath, turnCirclePathIntersections);
                        if (numEndTurnCircleStartPathIntersections > 1) {
                            // End turn circle is secant to the start path.
                            // choose the intersection farthest from the start/end path intersection.
                            let farIntersection = turnCirclePathIntersections[endTurnDirection === 'left' ? 1 : 0];
                            if (startPath.distanceAlong(intersection, farIntersection, Math.PI) > turnStartIntersectionOffset) {
                                // The start of the starting turn lies closer to the start/end path intersection than the farthest of the
                                // start path/end turn circle intersections.
                                const startTurnCircle = FlightPathUtils.getTurnCircle(startTurnCenter, minTurnRadiusRad, desiredTurnDirection, JoinGreatCircleToPointBuilder.geoCircleCache[2]);
                                const numStartTurnCircleEndPathIntersections = startTurnCircle.intersection(endPath, turnCirclePathIntersections);
                                if (numStartTurnCircleEndPathIntersections > 1) {
                                    // Start turn circle is secant to the end path.
                                    // choose the intersection farthest from the start/end path intersection.
                                    farIntersection = turnCirclePathIntersections[desiredTurnDirection === 'left' ? 0 : 1];
                                    if (endPath.distanceAlong(farIntersection, intersection, Math.PI) > intersectionEndDistance) {
                                        // The end of the ending turn lies closer to the start/end path intersection than the farthest of the
                                        // end path/start turn circle intersections.
                                        // In this case the path from start to end will involve a series of turns that total >360 degrees
                                        // unless we move the starting turn to be tangent to the ending turn. We can also reduce the total
                                        // length of the path by reversing the direction of the ending turn.
                                        const newEndTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, Math.PI - endTurnCircle.radius, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                                        endTurnCircle.set(newEndTurnCircleCenter, Math.PI - endTurnCircle.radius);
                                        needMoveStartTurn = true;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        // If start and end circles have different directions, they cannot be joined by a great-circle path.
                        needMoveStartTurn = true;
                    }
                }
            }
            if (needMoveStartTurn) {
                // We need to shift the start turn forward (with respect to the direction of the start path) until the
                // start and end turn circles are tangent.
                const endTurnOffsetCircle = JoinGreatCircleToPointBuilder.geoCircleCache[2].set(FlightPathUtils.getTurnCenterFromCircle(endTurnCircle, JoinGreatCircleToPointBuilder.vec3Cache[5]), minTurnRadiusRad * 2);
                const startPathOffsetCircle = JoinGreatCircleToPointBuilder.geoCircleCache[3].set(startPath.center, startPath.radius + minTurnRadiusRad * (desiredTurnDirection === 'left' ? -1 : 1));
                const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
                const numSolutions = startPathOffsetCircle.intersection(endTurnOffsetCircle, intersections);
                if (numSolutions > 0) {
                    Vec3Math.copy(intersections[0], startTurnCenter);
                    startPath.closest(startTurnCenter, startTurnStart);
                    const turnCircleTangent = endTurnCircle.closest(startTurnCenter, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                    if (Math.acos(Vec3Math.dot(startTurnStart, start)) > GeoPoint.EQUALITY_TOLERANCE) {
                        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, startTurnStart, flags);
                    }
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, desiredTurnDirection, minTurnRadius, startTurnCenter, startTurnStart, turnCircleTangent, flags);
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, turnCircleTangent, end, turnFlags);
                }
            }
            else {
                const startTurnCircle = FlightPathUtils.getTurnCircle(startTurnCenter, minTurnRadiusRad, desiredTurnDirection, JoinGreatCircleToPointBuilder.geoCircleCache[2]);
                if (Math.acos(Vec3Math.dot(startTurnStart, start)) > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, startTurnStart, flags);
                }
                vectorIndex += this.connectCirclesBuilder.build(vectors, vectorIndex, startTurnCircle, endTurnCircle, undefined, startTurnStart, end, flags, turnFlags, flags);
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            minD = Math.min(minD, Math.PI / 2);
            const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
            const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
            const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
            const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
            if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
            }
            vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
            if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
            }
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path which consists of an optional turn from an initial point and
     * course toward an end point followed by an optional great-circle path terminating at the end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction. If undefined, a turn direction will be chosen such that
     * the initial turn is always toward the end point.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[0].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the true course for a flight plan leg. If the leg defines an origin or fix VOR facility, then the magnetic
     * variation defined at the VOR is used to adjust magnetic course, otherwise the computed magnetic variation for the
     * specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns the true course for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao) && ICAO.getFacilityType(leg.originIcao) === FacilityType.VOR) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao) && ICAO.getFacilityType(leg.fixIcao) === FacilityType.VOR) ? leg.fixIcao
                : undefined;
        const facility = facIcao ? this.facilityCache.get(facIcao) : undefined;
        const magVar = facility
            ? -facility.magneticVariation
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: []
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            return calcs;
        }
        try {
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for discontinuity legs.
 */
class DiscontinuityLegCalculator extends AbstractFlightPathLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        const initialCourse = leg.course !== 0
            ? leg.course % 360
            : (_b = state.currentCourse) !== null && _b !== void 0 ? _b : state.planeHeading;
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    // eslint-disable-next-line jsdoc/require-jsdoc
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.turnBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const startPath = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, startCourse);
        const interceptPath = this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, course);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const firstHandleInvalidInterceptResult = this.handleInvalidIntercept(vectors, vectorIndex, initialVec, startPath, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, state.desiredTurnRadius.asUnit(UnitType.METER), includeInitialTurn);
        if (firstHandleInvalidInterceptResult !== undefined) {
            vectorIndex += firstHandleInvalidInterceptResult;
            if (vectorIndex > 0) {
                const lastVector = vectors[vectorIndex - 1];
                state.currentPosition.set(lastVector.endLat, lastVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            }
            vectors.length = vectorIndex;
            return;
        }
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            const turnVector = vectors[vectorIndex - 1];
            // Check if the turn circle intercepts the path to intercept
            const turnCircle = FlightPathUtils.setGeoCircleFromVector(turnVector, this.geoCircleCache[0]);
            const turnEndVec = GeoPoint.sphericalToCartesian(turnVector.endLat, turnVector.endLon, this.vec3Cache[3]);
            const intersections = this.intersectionCache;
            const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
            if (numIntersections > 1) {
                // Order intersections such that the one closer to the turn start is at index 0.
                if (interceptInfo.circle.radius > MathUtils.HALF_PI === interceptInfo.circle.encircles(initialVec)) {
                    const temp = intersections[0];
                    intersections[0] = intersections[1];
                    intersections[1] = temp;
                }
            }
            for (let i = 0; i < numIntersections; i++) {
                const intersection = intersections[i];
                if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, turnEndVec, intersection)
                    && (!effectiveInterceptPathStartVec
                        || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                    // End the turn early at the intercept point
                    const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                    if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                        const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                        turnVector.distance = distance;
                        turnVector.endLat = intersectionPoint.lat;
                        turnVector.endLon = intersectionPoint.lon;
                    }
                    else {
                        vectorIndex--;
                    }
                    if (vectorIndex > 0) {
                        const lastVector = vectors[vectorIndex - 1];
                        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
                        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
                    }
                    vectors.length = vectorIndex;
                    return;
                }
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
            interceptPath.setAsGreatCircle(state.currentPosition, course);
            const secondHandleInvalidInterceptResult = this.handleInvalidIntercept(vectors, vectorIndex, turnEndVec, interceptPath, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, state.desiredTurnRadius.asUnit(UnitType.METER), false);
            if (secondHandleInvalidInterceptResult !== undefined) {
                vectorIndex += secondHandleInvalidInterceptResult;
                if (secondHandleInvalidInterceptResult > 0) {
                    const lastVector = vectors[vectorIndex - 1];
                    state.currentPosition.set(lastVector.endLat, lastVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
                }
                vectors.length = vectorIndex;
                return;
            }
        }
        else {
            state.currentCourse = course;
        }
        const numVectorsAdded = this.interceptBuilder.build(vectors, vectorIndex, state.currentPosition, course, interceptInfo.circle);
        if (numVectorsAdded > 0) {
            vectorIndex += numVectorsAdded;
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Handles cases where the path to intercept cannot be intercepted from a defined starting point and intercept
     * course. Under these cases, vectors will be added to the flight path vector sequence to define a path from the
     * starting point to a point on the path to intercept which does not follow the defined intercept course.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @returns The number of vectors added to the sequence, or undefined if the case was not handled.
     */
    handleInvalidIntercept(vectors, index, start, startPath, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, desiredTurnRadius, onlyHandleInitialPointPastIntercept) {
        let vectorIndex = index;
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return vectorIndex - index;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleInterceptInBounds = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleInterceptInBounds = true;
        }
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept
            if (needHandleInterceptInBounds) {
                // The initial position is past the path to intercept or the original intercept course does not intersect the
                // path to intercept -> execute a turn to join the course tangent to the path to intercept at the desired
                // intercept point.
                let tangentPath;
                if (pathToInterceptCircle.isGreatCircle()) {
                    tangentPath = pathToInterceptCircle;
                }
                else {
                    const norm = Vec3Math.cross(pathToInterceptCircle.center, desiredIntersection, this.handleInvalidInterceptCache.vec3[1]);
                    tangentPath = this.handleInvalidInterceptCache.geoCircle[0].set(Vec3Math.cross(desiredIntersection, norm, this.handleInvalidInterceptCache.vec3[2]), MathUtils.HALF_PI);
                }
                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, desiredIntersection, tangentPath, undefined, desiredTurnRadius);
            }
            else {
                return undefined;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            if (distanceFromStart <= distanceFromEnd) {
                // Desired intercept point is closer to the start of the path to intercept -> calculate a direct path from the
                // initial position to the start of the path to intercept.
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, pathToInterceptStart, desiredTurnRadius);
            }
            else {
                // Desired intercept point is closer to the end of the path to intercept -> execute a turn to join the course
                // tangent to the path to intercept at its end.
                let tangentPath;
                if (pathToInterceptCircle.isGreatCircle()) {
                    tangentPath = pathToInterceptCircle;
                }
                else {
                    const norm = Vec3Math.cross(pathToInterceptCircle.center, pathToInterceptEnd, this.handleInvalidInterceptCache.vec3[1]);
                    tangentPath = this.handleInvalidInterceptCache.geoCircle[0].set(Vec3Math.cross(pathToInterceptEnd, norm, this.handleInvalidInterceptCache.vec3[2]), MathUtils.HALF_PI);
                }
                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, pathToInterceptEnd, tangentPath, undefined, desiredTurnRadius);
            }
        }
        return vectorIndex - index;
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDMELegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const startFacility = this.facilityCache.get(leg.fixIcao);
        return startFacility ? this.getLegTrueCourse(leg, startFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.vectorBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const fixIcaoPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const startPoint = fixIcaoPoint !== null && fixIcaoPoint !== void 0 ? fixIcaoPoint : state.currentPosition;
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(startPoint, course);
        vectorIndex += this.vectorBuilder.build(vectors, vectorIndex, startPoint, path, leg.distance);
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
            // Begins at a discontinuity OR previous leg is a manual termination leg.
            // Default to a track with start arbitrarily placed 5 NM from the terminator fix.
            const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        }
        else {
            const startVec = startPoint.toCartesian(this.vec3Cache[0]);
            const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
            const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
            const startToEndPath = this.geoCircleCache[2].setAsGreatCircle(startVec, endVec);
            const isStartEqualToEnd = startPoint.equals(endPoint);
            const pathDot = Vec3Math.dot(startPath.center, endPath.center);
            if (-pathDot > 1 - GeoCircle.ANGULAR_TOLERANCE) {
                // The start and end paths are anti-parallel, which means we need to execute a procedure turn to do a 180.
                // Favor right turn unless we are explicitly told to turn left.
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
                vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, currentCourse, endCourse);
            }
            else if ((endPath.angleAlong(startVec, endVec, Math.PI) + GeoCircle.ANGULAR_TOLERANCE) % (2 * Math.PI) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                && (pathDot > 1 - GeoCircle.ANGULAR_TOLERANCE
                    || (!isStartEqualToEnd
                        && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                            || (((_b = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                /*
                 * The start and end paths are parallel, so we can just connect the start and end with a track.
                 *
                 * OR the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                 * least one calculated vector. In this case we will simply create a track from the start to end and let turn
                 * anticipation handle the initial turn into the final course.
                 */
                if (!isStartEqualToEnd) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                }
            }
            else {
                const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                    : leg.turnDirection === LegTurnDirection.Right ? 'right'
                        : undefined;
                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, state.desiredTurnRadius.asUnit(UnitType.METER));
            }
        }
        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(endPoint);
        state.currentCourse = endCourse;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                ingressVectorIndex += this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = (_e = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _e !== void 0 ? _e : outboundCourse;
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            ingressVectorIndex += this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            const turnVector = ingress[ingressVectorIndex - 1];
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
            state.currentCourse = (_f = FlightPathUtils.getVectorFinalCourse(turnVector)) !== null && _f !== void 0 ? _f : parallelCourse;
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius) {
        var _a, _b, _c, _d, _e, _f;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
            const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
            if (fromLegCalc && toLegCalc) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
            return toIndex;
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        // define the circles
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
        const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // arc circle and track path are tangent
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                this.setEmptyTurn(fromLegCalc, toLegCalc);
                return toIndex;
            }
            else {
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90
                : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
            // if the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius))
                : Infinity;
            const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
            const trackLimitPoint = isArcFirst
                ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4])
                : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, (isArcFirst === isInside ? -1 : 1), FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === 'left') ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            const arcAngularWidth = ((arcDirection === 'left' ? (arcStartRadial - arcEndRadial) : (arcEndRadial - arcStartRadial)) + 360) % 360;
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === 'left' ? -1 : 1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
                        arcTurnRadiusLimit = (arcRadius - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
        return toIndex;
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
        var _a, _b;
        var _c, _d;
        const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_c[0] = FlightPathUtils.createEmptyCircleVector());
        const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : (_d[0] = FlightPathUtils.createEmptyCircleVector());
        fromLegCalc.egress.length = 1;
        toLegCalc.ingress.length = 1;
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        const flags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn;
        FlightPathUtils.setCircleVector(egress, circle, start, middle, flags);
        FlightPathUtils.setCircleVector(ingress, circle, middle, end, flags);
        fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
        toLegCalc.ingressJoinIndex = 0;
    }
}
FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     */
    constructor(facilityLoader, options) {
        this.facilityLoader = facilityLoader;
        this.options = options;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDMELegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDMELegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new DiscontinuityLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan and/or procedure.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg to start at.
     * @param count The number of legs to calculate.
     */
    async calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        initialIndex = Math.max(0, initialIndex);
        count = Math.max(0, Math.min(legs.length - initialIndex, count));
        this.state.updatePlaneState(this.options);
        await this.loadFacilities(legs, initialIndex, count);
        this.initCurrentLatLon(legs, initialIndex);
        this.initCurrentCourse(legs, initialIndex);
        this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
        this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER));
        this.resolveLegsIngressToEgress(legs, initialIndex, count);
        this.updateLegDistances(legs, initialIndex, count);
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (icao !== ICAO.emptyIcao && !this.facilityCache.has(icao)) {
            let facilityType;
            try {
                facilityType = ICAO.getFacilityType(icao);
            }
            catch (err) {
                //console.log(err);
            }
            if (facilityType !== undefined) {
                try {
                    facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                        .then(facility => {
                        this.facilityCache.set(icao, facility);
                        return true;
                    })
                        .catch(() => false));
                }
                catch (err) {
                    //console.log(err);
                }
            }
        }
    }
}
/**
 *
 */
class FlightPathStateClass {
    constructor() {
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     */
    updatePlaneState(options) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        this._desiredTurnRadius.set(NavMath.turnRadius(this._planeSpeed.asUnit(UnitType.KNOT), options.bankAngle));
    }
}

var PlanChangeType;
(function (PlanChangeType) {
    PlanChangeType["Added"] = "Added";
    PlanChangeType["Inserted"] = "Inserted";
    PlanChangeType["Removed"] = "Removed";
    PlanChangeType["Changed"] = "Changed";
    PlanChangeType["Cleared"] = "Cleared";
})(PlanChangeType || (PlanChangeType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg with which to start. Defaults to 0 if `reverse` is false or
     * `this.length` if `reverse` is true.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex) {
        return reverse ? this._legsReverse(startIndex) : this._legs(startIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg with which to start. Defaults to 0.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex) {
        startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                for (let l = Math.max(0, startIndex - segment.offset); l < segment.legs.length; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg with which to start. Defaults to `this.length - 1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex) {
        startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = this.length);
        for (let i = this.planSegments.length - 1; i >= 0; i--) {
            const segment = this.planSegments[i];
            if (segment) {
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l >= 0; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        throw new Error(`Flight plan segment with segment index ${segmentIndex} could not be found.`);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0
            }
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, PlanChangeType.Added, legDefinition);
        return legDefinition;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, PlanChangeType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        Object.assign(this.procedureDetails, details);
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, PlanChangeType.Changed, leg);
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, PlanChangeType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @returns The copied flight plan.
     */
    copy(planIndex) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.setProcedureDetails(this.procedureDetails, false);
        newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
        for (const segment of this.segments()) {
            newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
            for (const leg of segment.legs) {
                const newLeg = newPlan.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                const legIndex = newPlan.getLegIndexFromLeg(newLeg);
                newPlan.setLegVerticalData(legIndex, leg.verticalData);
            }
        }
        if (this.originAirport !== undefined) {
            newPlan.setOriginAirport(this.originAirport, false);
        }
        if (this.destinationAirport !== undefined) {
            newPlan.setDestinationAirport(this.destinationAirport, false);
        }
        newPlan.setLateralLeg(this.activeLateralLeg);
        newPlan.setVerticalLeg(this.activeVerticalLeg);
        newPlan.setCalculatingLeg(this.activeCalculatingLeg);
        for (const key in this.userData) {
            newPlan.setUserData(key, this.userData[key], false);
        }
        return newPlan;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
}, partial);

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
        this.bus = bus;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(() => !this.ignoreSync && this.onFlightPlanRequest());
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     */
    onFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', {}, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        for (let i = 0; i < data.flightPlans.length; i++) {
            const newPlan = Object.assign(new FlightPlan(i, this.calculator, this.onLegNameRequested), data.flightPlans[i]);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        this.setActivePlanIndex(data.planIndex);
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     */
    sendPlanCopied(planIndex, targetPlanIndex) {
        const data = { planIndex, targetPlanIndex };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        var _a;
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg = undefined;
        switch (data.type) {
            case PlanChangeType.Added:
                localLeg = data.leg && plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            case PlanChangeType.Removed:
                localLeg = (_a = plan.removeLeg(data.segmentIndex, data.legIndex, false)) !== null && _a !== void 0 ? _a : undefined;
                break;
            case PlanChangeType.Changed:
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_b) {
                    // noop
                }
                data.leg && data.leg.verticalData && plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case PlanChangeType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case PlanChangeType.Removed:
                try {
                    localSegment = plan.getSegment(data.segmentIndex);
                }
                catch (_a) {
                    // noop
                }
                plan.removeSegment(data.segmentIndex, false);
                break;
            case PlanChangeType.Changed:
                data.segment && plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setProcedureDetails(data.details, false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested));
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}

/**
 * A collection of unique string waypoint type keys.
 */
var WaypointTypes;
(function (WaypointTypes) {
    WaypointTypes["Custom"] = "Custom";
    WaypointTypes["Airport"] = "Airport";
    WaypointTypes["NDB"] = "NDB";
    WaypointTypes["VOR"] = "VOR";
    WaypointTypes["Intersection"] = "Intersection";
    WaypointTypes["Runway"] = "Runway";
    WaypointTypes["User"] = "User";
    WaypointTypes["Visual"] = "Visual";
    WaypointTypes["FlightPlan"] = "FlightPlan";
    WaypointTypes["VNAV"] = "VNAV";
})(WaypointTypes || (WaypointTypes = {}));
/**
 * An abstract implementation of Waypoint.
 */
class AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
        return this.uid === other.uid;
    }
}
/**
 * A waypoint with custom defined lat/lon coordinates.
 */
class CustomWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param uidPrefix The prefix of this waypoint's UID.
     */
    constructor(lat, lon, uidPrefix) {
        super();
        this._location = new GeoPoint(lat, lon);
        this._uid = `${uidPrefix}[${this.location.lat},${this.location.lon}]`;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
    /** @inheritdoc */
    get type() {
        return WaypointTypes.Custom;
    }
}
/**
 * A waypoint associated with a facility.
 */
class FacilityWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     */
    constructor(facility) {
        super();
        this.facility = facility;
        this._location = new GeoPoint(facility.lat, facility.lon);
        this._type = ICAO.getFacilityType(facility.icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this.facility.icao;
    }
    /** @inheritdoc */
    get type() {
        switch (this._type) {
            case FacilityType.Airport:
                return WaypointTypes.Airport;
            case FacilityType.Intersection:
                return WaypointTypes.Intersection;
            case FacilityType.NDB:
                return WaypointTypes.NDB;
            case FacilityType.RWY:
                return WaypointTypes.Runway;
            case FacilityType.USR:
                return WaypointTypes.User;
            case FacilityType.VIS:
                return WaypointTypes.Visual;
            case FacilityType.VOR:
                return WaypointTypes.VOR;
            default:
                return WaypointTypes.User;
        }
    }
}
/**
 * A flight path waypoint.
 */
class FlightPathWaypoint extends CustomWaypoint {
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat, lon, ident) {
        super(lat, lon, `${FlightPathWaypoint.UID_PREFIX}_${ident}`);
        this.ident = ident;
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.FlightPlan; }
}
FlightPathWaypoint.UID_PREFIX = 'FLPTH';
/**
 * A VNAV TOD/BOD waypoint.
 */
class VNavWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param type The type of VNAV leg.
     */
    constructor(leg, distanceFromEnd, type) {
        super();
        this._uid = VNavWaypoint.uidMap[type];
        this._location = this.getWaypointLocation(leg, distanceFromEnd);
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.VNAV; }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd) {
        const out = new GeoPoint(0, 0);
        if (leg.calculated !== undefined) {
            const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
            let vectorIndex = vectors.length - 1;
            while (vectorIndex >= 0) {
                const vector = vectors[vectorIndex];
                const start = VNavWaypoint.vec3Cache[0];
                const end = VNavWaypoint.vec3Cache[1];
                GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, end);
                GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, start);
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]);
                const vectorDistance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end), UnitType.METER);
                if (vectorDistance >= distanceFromEnd) {
                    return circle.offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out);
                }
                else {
                    distanceFromEnd -= vectorDistance;
                }
                vectorIndex--;
            }
            if (vectors.length > 0) {
                out.set(vectors[0].startLat, vectors[0].startLon);
            }
        }
        return out;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get location() {
        return this._location.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get uid() {
        return this._uid;
    }
}
VNavWaypoint.uidMap = { 'tod': 'vnav-tod', 'bod': 'vnav-bod' };
VNavWaypoint.vec3Cache = [new Float64Array(3), new Float64Array(3)];
VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A default implementation of {@link FacilityWaypointCache}.
 */
class DefaultFacilityWaypointCache {
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     */
    constructor(size) {
        this.size = size;
        this.cache = new Map();
    }
    /** @inheritdoc */
    get(facility) {
        let existing = this.cache.get(facility);
        if (!existing) {
            existing = new FacilityWaypoint(facility);
            this.addToCache(facility, existing);
        }
        return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param facility The facility associated with the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(facility, waypoint) {
        this.cache.set(facility, waypoint);
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache() {
        var _a;
        return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(1000));
    }
}

var IcaoSearchFilter;
(function (IcaoSearchFilter) {
    IcaoSearchFilter[IcaoSearchFilter["ALL"] = 0] = "ALL";
    IcaoSearchFilter[IcaoSearchFilter["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter[IcaoSearchFilter["VOR"] = 2] = "VOR";
    IcaoSearchFilter[IcaoSearchFilter["NDB"] = 3] = "NDB";
    IcaoSearchFilter[IcaoSearchFilter["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter[IcaoSearchFilter["USR"] = 5] = "USR";
})(IcaoSearchFilter || (IcaoSearchFilter = {}));

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for basic ADC/AHRS information.
 */
class ADCPublisher extends SimVarPublisher {
    /**
     * Create an ADCPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ADCPublisher.simvars, bus, pacer);
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((key) => {
            if (key === 'mach_to_kias_factor') {
                this.subscribed.add('mach_to_kias_factor');
            }
        });
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('mach_to_kias_factor')) {
            this.publish('mach_to_kias_factor', Simplane.getMachToKias(1), false, true);
        }
    }
}
ADCPublisher.simvars = new Map([
    ['ias', { name: 'AIRSPEED INDICATED', type: SimVarValueType.Knots }],
    ['tas', { name: 'AIRSPEED TRUE', type: SimVarValueType.Knots }],
    ['alt', { name: 'INDICATED ALTITUDE', type: SimVarValueType.Feet }],
    ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
    ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
    ['vs', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
    ['hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
    ['pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
    ['roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
    ['hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
    ['kohlsman_setting_hg_1', { name: 'KOHLSMAN SETTING HG', type: SimVarValueType.InHG }],
    ['kohlsman_setting_hg_1_preselect', { name: 'L:XMLVAR_Baro1_SavedPressure', type: SimVarValueType.MB }],
    ['baro_std_1', { name: 'L:XMLVAR_Baro1_ForcedToSTD', type: SimVarValueType.Bool }],
    ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
    ['delta_heading_rate', { name: 'DELTA HEADING RATE', type: SimVarValueType.Degree }],
    ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
    ['ambient_press_in', { name: 'AMBIENT PRESSURE', type: SimVarValueType.InHG }],
    ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
    ['rat_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
    ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
    ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
    ['kohlsman_setting_mb_1', { name: 'KOHLSMAN SETTING MB', type: SimVarValueType.MB }],
    ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
    ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
    ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
    ['mach_number', { name: 'AIRSPEED MACH', type: SimVarValueType.Mach }],
]);

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param publisher - a publisher extending BasePublisher
     */
    addPublisher(name, publisher) {
        this.publishers.set(name, publisher);
    }
    /**
     * Add an instrument to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param instrument - an instrument implementing Instrment
     */
    addInstrument(name, instrument) {
        this.instruments.set(name, instrument);
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="msfstypes/JS/SimPlane" />
/**
 * A publisher for basic GNSS information.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    /**
     * A callback called when the publisher updates.
     */
    onUpdate() {
        this.publishPosition();
        this.publishTime();
        this.publishTrack();
        this.publishGroundSpeed();
        this.publishMagVar();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    publishTime() {
        const zuluTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
        const timeOfDay = SimVar.GetSimVarValue('E:TIME OF DAY', 'number');
        this.publish('zulu_time', zuluTime);
        this.publish('time_of_day', timeOfDay);
    }
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    publishTrack() {
        const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Math.atan2(velocityEW, velocityNS), UnitType.DEGREE));
        }
        const magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        const magneticTrack = NavMath.normalizeHeading(track - magvar);
        this.publish('track_deg_true', track);
        this.publish('track_deg_magnetic', magneticTrack);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishGroundSpeed() {
        const gs = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots);
        this.publish('ground_speed', gs);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishMagVar() {
        const magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        this.publish('magvar', magvar);
    }
}

// Common definitions relevant to all radio types.
/** The basic radio types. */
var RadioType;
(function (RadioType) {
    RadioType["Com"] = "COM";
    RadioType["Nav"] = "NAV";
    RadioType["Adf"] = "ADF";
})(RadioType || (RadioType = {}));
/** The two frequency "banks", active and standby. */
var FrequencyBank;
(function (FrequencyBank) {
    FrequencyBank[FrequencyBank["Active"] = 0] = "Active";
    FrequencyBank[FrequencyBank["Standby"] = 1] = "Standby";
})(FrequencyBank || (FrequencyBank = {}));
/** COM frequency spacing on COM radios. */
var ComSpacing;
(function (ComSpacing) {
    /** 25Khz spacing */
    ComSpacing[ComSpacing["Spacing25Khz"] = 0] = "Spacing25Khz";
    /** 8.33Khz spacing */
    ComSpacing[ComSpacing["Spacing833Khz"] = 1] = "Spacing833Khz";
})(ComSpacing || (ComSpacing = {}));

/// <reference types="msfstypes/JS/simvar" />
/** Publish simvars for ourselves */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ['nav_obs_1', { name: 'NAV OBS:1', type: SimVarValueType.Degree }],
    ['nav_cdi_1', { name: 'NAV CDI:1', type: SimVarValueType.Number }],
    ['nav_dme_1', { name: 'NAV DME:1', type: SimVarValueType.NM }],
    ['nav_has_dme_1', { name: 'NAV HAS DME:1', type: SimVarValueType.Bool }],
    ['nav_has_nav_1', { name: 'NAV HAS NAV:1', type: SimVarValueType.Bool }],
    ['nav_radial_1', { name: 'NAV RADIAL:1', type: SimVarValueType.Radians }],
    ['nav_signal_1', { name: 'NAV SIGNAL:1', type: SimVarValueType.Number }],
    ['nav_ident_1', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav_to_from_1', { name: 'NAV TOFROM:1', type: SimVarValueType.Enum }],
    ['nav_localizer_1', { name: 'NAV HAS LOCALIZER:1', type: SimVarValueType.Bool }],
    ['nav_localizer_crs_1', { name: 'NAV LOCALIZER:1', type: SimVarValueType.Number }],
    ['nav_glideslope_1', { name: 'NAV HAS GLIDE SLOPE:1', type: SimVarValueType.Bool }],
    ['nav_gs_error_1', { name: 'NAV GLIDE SLOPE ERROR:1', type: SimVarValueType.Degree }],
    ['nav_raw_gs_1', { name: 'NAV RAW GLIDE SLOPE:1', type: SimVarValueType.Degree }],
    ['nav_gs_lla_1', { name: 'NAV GS LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav_lla_1', { name: 'NAV VOR LATLONALT:1', type: SimVarValueType.LLA }],
    ['nav_magvar_1', { name: 'NAV MAGVAR:1', type: SimVarValueType.Degree }],
    ['nav_obs_2', { name: 'NAV OBS:2', type: SimVarValueType.Degree }],
    ['nav_cdi_2', { name: 'NAV CDI:2', type: SimVarValueType.Number }],
    ['nav_dme_2', { name: 'NAV DME:2', type: SimVarValueType.NM }],
    ['nav_has_dme_2', { name: 'NAV HAS DME:2', type: SimVarValueType.Bool }],
    ['nav_has_nav_2', { name: 'NAV HAS NAV:2', type: SimVarValueType.Bool }],
    ['nav_radial_2', { name: 'NAV RADIAL:2', type: SimVarValueType.Radians }],
    ['nav_signal_2', { name: 'NAV SIGNAL:2', type: SimVarValueType.Number }],
    ['nav_ident_2', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['nav_to_from_2', { name: 'NAV TOFROM:2', type: SimVarValueType.Enum }],
    ['nav_localizer_2', { name: 'NAV HAS LOCALIZER:2', type: SimVarValueType.Bool }],
    ['nav_localizer_crs_2', { name: 'NAV LOCALIZER:2', type: SimVarValueType.Number }],
    ['nav_glideslope_2', { name: 'NAV HAS GLIDE SLOPE:2', type: SimVarValueType.Bool }],
    ['nav_gs_error_2', { name: 'NAV GLIDE SLOPE ERROR:2', type: SimVarValueType.Degree }],
    ['nav_raw_gs_2', { name: 'NAV RAW GLIDE SLOPE:2', type: SimVarValueType.Degree }],
    ['nav_gs_lla_2', { name: 'NAV GS LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav_lla_2', { name: 'NAV VOR LATLONALT:2', type: SimVarValueType.LLA }],
    ['nav_magvar_2', { name: 'NAV MAGVAR:2', type: SimVarValueType.Degree }],
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.String }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['adf_bearing_1', { name: 'ADF RADIAL:1', type: SimVarValueType.Radians }],
    ['adf_signal_1', { name: 'ADF SIGNAL:1', type: SimVarValueType.Number }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));
//* ENUM for VOR To/From Flag */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));

/** A publisher to poll and publish nav/com simvars. */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavComSimVarPublisher.simvars, bus, pacer);
    }
}
NavComSimVarPublisher.simvars = new Map([
    ['nav_active_frequency_1', { name: 'NAV ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav_standby_frequency_1', { name: 'NAV STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['nav_ident_1', { name: 'NAV IDENT:1', type: SimVarValueType.String }],
    ['nav_signal_1', { name: 'NAV SIGNAL:1', type: SimVarValueType.Number }],
    ['nav_active_frequency_2', { name: 'NAV ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav_standby_frequency_2', { name: 'NAV STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['nav_ident_2', { name: 'NAV IDENT:2', type: SimVarValueType.String }],
    ['nav_signal_2', { name: 'NAV SIGNAL:2', type: SimVarValueType.Number }],
    ['com_active_frequency_1', { name: 'COM ACTIVE FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com_standby_frequency_1', { name: 'COM STANDBY FREQUENCY:1', type: SimVarValueType.MHz }],
    ['com_active_frequency_2', { name: 'COM ACTIVE FREQUENCY:2', type: SimVarValueType.MHz }],
    ['com_standby_frequency_2', { name: 'COM STANDBY FREQUENCY:2', type: SimVarValueType.MHz }],
    ['adf_standby_frequency_1', { name: 'ADF STANDBY FREQUENCY:1', type: SimVarValueType.KHz }],
    ['adf_active_frequency_1', { name: 'ADF ACTIVE FREQUENCY:1', type: SimVarValueType.KHz }]
]);

/// <reference types="msfstypes/JS/simvar" />
var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    // TODO extend the next two to handle multiple APs?
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:1', type: SimVarValueType.Degree }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:1', type: SimVarValueType.Feet }],
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:1', type: SimVarValueType.FPM }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR', type: SimVarValueType.Knots }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR', type: SimVarValueType.Number }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['kap_140_installed', { name: 'L:WT1000_AP_KAP140_INSTALLED', type: SimVarValueType.Bool }]
]);

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for Engine information.
 */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map(EISPublisher.simvars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (let i = 1; i <= engineCount; i++) {
            simvars.set(`fuel_flow_${i}`, { name: `ENG FUEL FLOW GPH:${i}`, type: SimVarValueType.GPH });
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}
EISPublisher.simvars = new Map([
    ['rpm_1', { name: 'GENERAL ENG RPM:1', type: SimVarValueType.RPM }],
    ['rpm_2', { name: 'GENERAL ENG RPM:2', type: SimVarValueType.RPM }],
    ['n1_1', { name: 'TURB ENG CORRECTED N1:1', type: SimVarValueType.Percent }],
    ['n1_2', { name: 'TURB ENG CORRECTED N1:2', type: SimVarValueType.Percent }],
    ['n2_1', { name: 'TURB ENG CORRECTED N2:1', type: SimVarValueType.Percent }],
    ['n2_2', { name: 'TURB ENG CORRECTED N2:2', type: SimVarValueType.Percent }],
    ['recip_ff_1', { name: 'RECIP ENG FUEL FLOW:1', type: SimVarValueType.PPH }],
    ['recip_ff_2', { name: 'RECIP ENG FUEL FLOW:2', type: SimVarValueType.PPH }],
    ['oil_press_1', { name: 'ENG OIL PRESSURE:1', type: SimVarValueType.PSI }],
    ['oil_press_2', { name: 'ENG OIL PRESSURE:2', type: SimVarValueType.PSI }],
    ['oil_temp_1', { name: 'ENG OIL TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['oil_temp_2', { name: 'ENG OIL TEMPERATURE:2', type: SimVarValueType.Farenheit }],
    ['itt_1', { name: 'TURB ENG1 ITT', type: SimVarValueType.Celsius }],
    ['itt_2', { name: 'TURB ENG2 ITT', type: SimVarValueType.Celsius }],
    ['egt_1', { name: 'ENG EXHAUST GAS TEMPERATURE:1', type: SimVarValueType.Farenheit }],
    ['egt_2', { name: 'ENG EXHAUST GAS TEMPERATURE:2', type: SimVarValueType.Farenheit }],
    ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
    ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL }],
    ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
    ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
    ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
    ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
    ['eng_hyd_press_1', { name: 'ENG HYDRAULIC PRESSURE:1', type: SimVarValueType.PSI }],
    ['eng_hyd_press_2', { name: 'ENG HYDRAULIC PRESSURE:2', type: SimVarValueType.PSI }],
    ['eng_starter_1', { name: 'GENERAL ENG STARTER:1', type: SimVarValueType.Number }],
    ['eng_starter_2', { name: 'GENERAL ENG STARTER:2', type: SimVarValueType.Number }],
    ['eng_combustion_1', { name: 'GENERAL ENG COMBUSTION:1', type: SimVarValueType.Number }],
    ['eng_combustion_2', { name: 'GENERAL ENG COMBUSTION:2', type: SimVarValueType.Number }],
    ['eng_manual_ignition_1', { name: 'TURB ENG IGNITION SWITCH EX1:1', type: SimVarValueType.Number }],
    ['eng_manual_ignition_2', { name: 'TURB ENG IGNITION SWITCH EX1:2', type: SimVarValueType.Number }]
]);

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdate() {
        this.publish('realTime', Date.now());
        this.publish('simTime', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds')));
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));

// eslint-disable-next-line @typescript-eslint/no-namespace
var Wait;
(function (Wait) {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    Wait.awaitDelay = awaitDelay;
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    // eslint-disable-next-line no-inner-declarations
    function awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    Wait.awaitCondition = awaitCondition;
})(Wait || (Wait = {}));

new GeoPoint(0, 0);

/**
 * A publisher for control surfaces information.
 */
class ControlSurfacesPublisher extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ControlSurfacesPublisher.simvars, bus, pacer);
    }
}
ControlSurfacesPublisher.simvars = new Map([
    ['flaps_handle_index', { name: 'FLAPS HANDLE INDEX', type: SimVarValueType.Number }],
    ['flaps_angle', { name: 'TRAILING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
    ['elevator_trim_pct', { name: 'ELEVATOR TRIM PCT', type: SimVarValueType.Percent }],
    ['elevator_trim_neutral_pct', { name: 'AIRCRAFT ELEVATOR TRIM NEUTRAL', type: SimVarValueType.Percent }],
    ['aileron_trim_pct', { name: 'AILERON TRIM PCT', type: SimVarValueType.Percent }],
    ['rudder_trim_pct', { name: 'RUDDER TRIM PCT', type: SimVarValueType.Percent }],
    ['gear_position_index', { name: 'GEAR POSITION', type: SimVarValueType.Number }],
]);

/// <reference types="msfstypes/JS/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubsciberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Called when the flight has started and electrical data is valid.
     * @param started True if the flight has started
     */
    setFlightStarted(started) {
        this.flightStarted = started;
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY', type: SimVarValueType.Bool }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD', type: SimVarValueType.Amps }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE', type: SimVarValueType.Volts }]
]);

/**
 * A publisher for Pressurization information.
 */
class PressurizationPublisher extends SimVarPublisher {
    /**
     * Create an PressurizationPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(PressurizationPublisher.simvars, bus, pacer);
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
        super.onUpdate();
    }
}
PressurizationPublisher.simvars = new Map([
    ['cabin_altitude', { name: 'PRESSURIZATION CABIN ALTITUDE', type: SimVarValueType.Feet }],
    ['cabin_altitude_rate', { name: 'PRESSURIZATION CABIN ALTITUDE RATE', type: SimVarValueType.FPM }],
    ['pressure_diff', { name: 'PRESSURIZATION PRESSURE DIFFERENTIAL', type: SimVarValueType.PSI }]
]);

/** A publisher for DH/DA simvar events. */
class DHSimVarPublisher extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
        super(DHSimVarPublisher.simvars, bus);
    }
}
DHSimVarPublisher.simvars = new Map([
    ['decision_height_feet', { name: 'DECISION HEIGHT', type: SimVarValueType.Feet }],
    ['decision_altitude_feet', { name: 'DECISION ALTITUDE MSL', type: SimVarValueType.Feet }]
]);

/**
 * Utility Methods for the FMS.
 */
class FmsUtils {
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        const leg = FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: oneWayRunway.elevation
        });
        return leg;
    }
    /**
     * Utility method to return a one-way runway leg from an approach runway leg definition
     * @param airport is the facility associated with the arrival
     * @param runwayIcao is the icao string for the runway waypoint in the final legs
     * @returns a leg object for the runway
     */
    static buildRunwayLegForApproach(airport, runwayIcao) {
        for (let i = 0; i < airport.runways.length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation == ICAO.getIdent(runwayIcao));
            });
            if (match) {
                const leg = FlightPlan.createLeg({
                    lat: match.latitude,
                    lon: match.longitude,
                    type: LegType.TF,
                    fixIcao: runwayIcao
                });
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param initialLegDistance is the distance from the final leg to place the iaf leg in NM.
     * @param name is the optional name for the approach.
     * @param finalLegIdent is the optional name for the faf leg.
     * @param initialLegIdent is the optional name for the iaf leg.
     * @returns an approach procedure.
     */
    static buildVisualApproach(airport, runway, finalLegDistance, initialLegDistance, name, finalLegIdent, initialLegIdent) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, FmsUtils.vec3Cache[0]);
        const approachPath = FmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const iafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-(initialLegDistance + finalLegDistance), UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        initialLegIdent !== null && initialLegIdent !== void 0 ? initialLegIdent : (initialLegIdent = 'STRGHT');
        const iafLeg = FlightPlan.createLeg({
            type: LegType.IF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${initialLegIdent}`,
            lat: iafLatLon.lat,
            lon: iafLatLon.lon,
        });
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
        finalLegIdent !== null && finalLegIdent !== void 0 ? finalLegIdent : (finalLegIdent = ' FINAL');
        const fafLeg = FlightPlan.createLeg({
            type: LegType.CF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + 110,
        });
        const runwayLeg = FmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.altitude1 += 15; //Runway leg altitude should be 50 feet above threshold
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(iafLeg);
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        const missedLegLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN), FmsUtils.geoPointCache[0]);
        const missedLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}MANSEQ`,
            lat: missedLegLatLon.lat,
            lon: missedLegLatLon.lon,
        });
        const missedLegs = [];
        missedLegs.push(missedLeg);
        const proc = {
            name: name !== null && name !== void 0 ? name : `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [{ name: 'STRAIGHT', legs: [] }],
            finalLegs: finalLegs,
            missedLegs: missedLegs,
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
        return proc;
    }
    /**
     * Utility method to return a single RnavTypeFlag from multiple possible flags.
     * @param rnavTypeFlags The input RnavTypeFlags.
     * @returns A single RnavTypeFlag
     */
    static getBestRnavType(rnavTypeFlags) {
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approach The approach procedure
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a a tunable localizer.
     * @param approach The approach procedure
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets an approach procedure from a flight plan.
     * @param plan A flight plan.
     * @param destination The detsination airport of the flight plan.
     * @returns The approach procedure from the flight plan, or undefined if the plan has no approach.
     */
    static getApproachFromPlan(plan, destination) {
        let approach = destination.approaches[plan.procedureDetails.approachIndex];
        if (!approach) {
            const visualRwyDesignation = plan.getUserData('visual_approach');
            if (visualRwyDesignation && plan.destinationAirport) {
                const runway = RunwayUtils.matchOneWayRunwayFromDesignation(destination, visualRwyDesignation);
                if (runway) {
                    approach = {
                        name: `VISUAL ${visualRwyDesignation}`,
                        runway: runway.designation,
                        icaos: [],
                        transitions: [],
                        finalLegs: [],
                        missedLegs: [],
                        approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                        approachSuffix: '',
                        runwayDesignator: runway.runwayDesignator,
                        runwayNumber: runway.direction,
                        rnavTypeFlags: RnavTypeFlags.None
                    };
                }
            }
        }
        return approach;
    }
    /**
     * Checks whether a flight plan has an approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has an approach loaded.
     */
    static isApproachLoaded(plan) {
        return plan.procedureDetails.approachIndex >= 0 || (plan.getUserData('visual_approach') !== undefined && plan.destinationAirport !== undefined);
    }
    /**
     * Checks whether a plan has a vectors-to-final approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has a vectors-to-final approach loaded.
     */
    static isVtfApproachLoaded(plan) {
        return !!FmsUtils.getApproachVtfLeg(plan);
    }
    /**
     * Gets the vectors-to-final leg of a flight plan.
     * @param plan A flight plan.
     * @returns The vectors-to-final leg of the flight plan, or undefined if one could not be found.
     */
    static getApproachVtfLeg(plan) {
        if (!FmsUtils.isApproachLoaded(plan) || plan.procedureDetails.approachTransitionIndex >= 0) {
            return undefined;
        }
        // There should only be one approach segment
        for (const approachSegment of plan.segmentsOfType(FlightPlanSegmentType.Approach)) {
            return approachSegment.legs.find(leg => BitFlags.isAll(leg.flags, LegDefinitionFlags.VectorsToFinal) && BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.FAF));
        }
        return undefined;
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param departure A departure procedure definition.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    static getDepartureNameAsString(airport, departure, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        if (runway) {
            name += `RW${runway.designation}.`;
        }
        const transition = departure.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        }
        else if (departure.commonLegs.length > 0) {
            name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        }
        else {
            name += `${departure.name}`;
        }
        return name;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param arrival An arrival procedure definition.
     * @param transitionIndex The index of the arrival enroute transition.
     * @param runway The runway of the arrival, if any.
     * @returns The name of the arrival procedure.
     */
    static getArrivalNameAsString(airport, arrival, transitionIndex, runway) {
        let name = `${ICAO.getIdent(airport.icao)}–`;
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            name += `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else if (arrival.commonLegs.length > 0) {
            name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            name += `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        if (runway) {
            name += `.RW${runway.designation}`;
        }
        return name;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc) {
        let type;
        let subtype;
        let rnavType;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR/DME';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB/DME';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNAV';
                subtype = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'LOC BC';
                break;
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        const approachIsCircling = !proc.runway ? true : false;
        if (proc.approachType === ApproachType.APPROACH_TYPE_RNAV) {
            switch (FmsUtils.getBestRnavType(proc.rnavTypeFlags)) {
                case RnavTypeFlags.LNAV:
                    rnavType = approachIsCircling ? 'LNAV' : 'LNAV+V';
                    break;
                case RnavTypeFlags.LP:
                    rnavType = approachIsCircling ? 'LP' : 'LP+V';
                    break;
                case RnavTypeFlags.LNAVVNAV:
                    rnavType = 'LNAV/VNAV';
                    break;
                case RnavTypeFlags.LPV:
                    rnavType = 'LPV';
                    break;
            }
        }
        return {
            type: type,
            subtype: subtype,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            flags: rnavType
        };
    }
    /**
     * Utility method that takes an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param approach The approach as an ApproaceProcedure
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(approach) {
        const parts = FmsUtils.getApproachNameAsParts(approach);
        let name = parts.type;
        parts.subtype && (name += `${parts.subtype}`);
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Gets an approach frequency from the facility record.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     * @returns The FacilityFrequency or undefined
     */
    static getApproachFrequency(facility, approachIndex) {
        const approach = facility === null || facility === void 0 ? void 0 : facility.approaches[approachIndex !== null && approachIndex !== void 0 ? approachIndex : -1];
        if (approach && (approach.approachType === ApproachType.APPROACH_TYPE_ILS
            || approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER
            || approach.approachType === ApproachType.APPROACH_TYPE_LDA
            || approach.approachType === ApproachType.APPROACH_TYPE_SDF)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const freq = RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            return freq;
        }
        else {
            return undefined;
        }
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
}
FmsUtils.vec3Cache = [new Float64Array(3)];
FmsUtils.geoPointCache = [new GeoPoint(0, 0)];
FmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
FmsUtils.DTO_LEG_OFFSET = 3;

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
    DirectToState[DirectToState["TORANDOM"] = 2] = "TORANDOM";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A fms menu system tracker.
 */
class Fms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param verticalPathCalculator is the optional Vertical Path Calculator.
     */
    constructor(bus, flightPlanner, verticalPathCalculator) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.ppos = new GeoPoint(0, 0);
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.calculator = new FlightPathCalculator(this.facLoader, { defaultClimbRate: 300, defaultSpeed: 85, bankAngle: 15 });
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false,
            approachIsCircling: false
        };
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        this.insertApproachOpId = 0;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
            }
        };
        const sub = this.bus.getSubscriber();
        sub.on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        sub.on('cdi_select').handle(source => this.cdiSource = source);
        sub.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        sub.on('fplLoaded').handle(() => this.checkApproachState());
        const obsCourse = ConsumerSubject.create(sub.on('gps_obs_value'), 0);
        let obsWasActive = false;
        sub.on('gps_obs_active').whenChanged().handle(isActive => {
            if (isActive) {
                obsWasActive = true;
            }
            else {
                if (obsWasActive) {
                    this.convertObsToDirectTo(obsCourse.get());
                }
                obsWasActive = false;
            }
        });
        this.navActiveFreqs = {
            1: ConsumerSubject.create(sub.on('nav_active_frequency_1'), 0),
            2: ConsumerSubject.create(sub.on('nav_active_frequency_2'), 0)
        };
        this.approachFrequency.sub((v) => {
            if (v !== this._lastApproachFrequencyEventValue) {
                this.bus.getPublisher().pub('approach_freq_set', v, true);
            }
        });
        sub.on('approach_freq_set').handle((v) => {
            this._lastApproachFrequencyEventValue = v;
            this.approachFrequency.set(v);
        });
        sub.on('activate_missed_approach').handle(v => {
            this.missedApproachActive = v;
            if (this.missedApproachActive) {
                this.bus.getPublisher().pub('suspend_sequencing', false, true);
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
        });
        sub.on('approach_details_set').handle(this.onApproachDetailsSet);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        this.flightPlanner.createFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        await this.emptyPrimaryFlightPlan();
    }
    /**
     * Checks whether an indexed flight plan exists.
     * @param index A flight plan index.
     * @returns Whether a flight plan at the specified index exists.
     */
    hasFlightPlan(index) {
        return this.flightPlanner.hasFlightPlan(index);
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = Fms.PRIMARY_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Gets the primary flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
    }
    /**
     * Checks whether the Direct To Random flight plan exists.
     * @returns Whether the Direct To Random flight plan exists.
     */
    hasDirectToFlightPlan() {
        return this.flightPlanner.hasFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Gets the Direct To Random flight plan.
     * @returns The Direct To Random flight plan.
     * @throws Error if the Direct To Random flight plan does not exist.
     */
    getDirectToFlightPlan() {
        return this.flightPlanner.getFlightPlan(Fms.DTO_RANDOM_PLAN_INDEX);
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length > 0 && !this.missedApproachActive) {
                const activeSegment = activePlan.getSegment(activePlan.getSegmentIndex(Math.max(0, activePlan.activeLateralLeg)));
                if (activeSegment.segmentType === FlightPlanSegmentType.Approach && activePlan.activeLateralLeg - activeSegment.offset > 0) {
                    this.setApproachDetails(undefined, undefined, undefined, true);
                }
                else {
                    this.setApproachDetails(undefined, undefined, undefined, false);
                }
            }
            else {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            if (!this.missedApproachActive
                && activePlan.activeLateralLeg < activePlan.length - 1
                && BitFlags.isAll(activePlan.getLeg(activePlan.activeLateralLeg).flags, LegDefinitionFlags.MissedApproach)) {
                this.bus.getPublisher().pub('activate_missed_approach', true, true);
            }
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        let approachIsCircling = false;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach') !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = FmsUtils.getBestRnavType(approach.rnavTypeFlags);
                    approachIsCircling = !approach.runway;
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(lateralLegIndex) {
        const plan = this.getFlightPlan();
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setCalculatingLeg(adjustedActivateIndex);
            plan.setLateralLeg(adjustedActivateIndex);
            plan.calculate(0);
        }
    }
    /**
     * Checks whether a leg in the primary flight plan can be manually activated.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg can be manually activated.
     */
    canActivateLeg(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo) || leg === plan.getLeg(0)) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CF:
            case LegType.FC:
            case LegType.FD:
                return true;
            case LegType.CI:
            case LegType.VI:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.VM:
                return false;
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        switch (prevLeg.leg.type) {
            case LegType.VA:
            case LegType.CA:
            case LegType.VM:
            case LegType.Discontinuity:
                return false;
        }
        return true;
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     * @throws Error if a leg could not be found at the specified location.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @returns the DirectToState.
     */
    getDirectToState() {
        if (this.flightPlanner.activePlanIndex == 1) {
            const plan = this.getDirectToFlightPlan();
            if (plan.segmentCount > 0 && plan.getSegment(0).segmentType === FlightPlanSegmentType.RandomDirectTo) {
                return DirectToState.TORANDOM;
            }
        }
        else {
            const plan = this.getPrimaryFlightPlan();
            const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
            if (directDataExists && plan.segmentCount >= plan.directToData.segmentIndex
                && plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]) === plan.activeLateralLeg - 3) {
                return DirectToState.TOEXISTING;
            }
        }
        return DirectToState.NONE;
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TORANDOM: {
                const plan = this.getDirectToFlightPlan();
                return plan.getSegment(0).legs[2].leg;
            }
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param facility is the new facility to add a leg to.
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(segmentIndex, facility, legIndex) {
        var _a, _b;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            return false;
        }
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            legIndex !== null && legIndex !== void 0 ? legIndex : (legIndex = segment.legs.length - 1);
            // Get the displaced legs from the airway segment
            const legsToMove = [];
            const legsLength = segment.legs.length;
            for (let i = legIndex; i < legsLength; i++) {
                legsToMove.push(segment.legs[i].leg);
            }
            // Save the airway name
            const airway = (_b = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0]) !== null && _b !== void 0 ? _b : '';
            const nextSegment = plan.getSegment(segmentIndex + 1);
            const needFirstAirwaySegment = legIndex > 0; // We don't need to keep the original airway segment around if we've displaced all of its enroute waypoints.
            const needSecondAirwaySegment = legsToMove.length > 2; // Only create a second airway segment if we've displaced at least three waypoints in the original airway
            const needNewEnrouteSegment = needFirstAirwaySegment && (needSecondAirwaySegment || nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute);
            const firstAirwaySegmentIndex = needFirstAirwaySegment ? segmentIndex : -1;
            const enrouteSegmentIndex = needFirstAirwaySegment ? segmentIndex + 1 : segmentIndex - 1;
            const secondAirwaySegmentIndex = needSecondAirwaySegment ? enrouteSegmentIndex + 1 : -1;
            if (needNewEnrouteSegment) {
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            }
            if (needSecondAirwaySegment) {
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            }
            // Add the inserted leg to its enroute segment
            this.planAddLeg(enrouteSegmentIndex, leg);
            if (!needFirstAirwaySegment) {
                this.planRemoveSegment(segmentIndex);
            }
            else {
                for (let i = legsLength - 1; i >= legIndex; i--) {
                    this.planRemoveLeg(segmentIndex, i, true, true);
                }
            }
            if (legsToMove.length > 0) {
                this.planAddLeg(enrouteSegmentIndex, legsToMove[0]); // Always add first displaced waypoint to the enroute segment in case it is an airway entry
                const toAddSegmentIndex = secondAirwaySegmentIndex < 0 ? enrouteSegmentIndex : secondAirwaySegmentIndex;
                for (let i = 1; i < legsToMove.length; i++) {
                    this.planAddLeg(toAddSegmentIndex, legsToMove[i]);
                }
            }
            // Update names of the airway segments as appropriate.
            if (firstAirwaySegmentIndex >= 0) {
                segment.airway = airway + '.' + segment.legs[legIndex - 1].name;
                plan.setAirway(firstAirwaySegmentIndex, segment.airway);
            }
            if (secondAirwaySegmentIndex >= 0) {
                const newAirwaySegment = plan.getSegment(secondAirwaySegmentIndex);
                newAirwaySegment.airway = airway + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name;
                plan.setAirway(secondAirwaySegmentIndex, newAirwaySegment.airway);
            }
            return true;
        }
        this.planAddLeg(segmentIndex, leg, legIndex);
        return true;
    }
    /**
     * Removes a leg to a waypoint from the primary flight plan.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @returns Whether the waypoint was successfully removed.
     */
    removeWaypoint(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP)) {
            return false;
        }
        const legDeleted = this.planRemoveLeg(segmentIndex, segmentLegIndex);
        const nextLeg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (legDeleted && nextLeg && (nextLeg.leg.type === LegType.HA || nextLeg.leg.type === LegType.HM || nextLeg.leg.type === LegType.HF)) {
            if (plan.tryGetLeg(segmentIndex, segmentLegIndex)) {
                this.planRemoveLeg(segmentIndex, segmentLegIndex, true, true, true);
            }
        }
        return legDeleted;
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            plan.setOriginAirport(airport.icao);
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getFlightPlan();
        const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
            const hasArrival = plan.procedureDetails.arrivalIndex > -1;
            const hasApproach = plan.procedureDetails.approachIndex > -1;
            if (!hasArrival && !hasApproach) {
                this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, runway);
            }
        }
        else {
            plan.removeDestinationAirport();
            this.planClearSegment(destSegmentIndex, FlightPlanSegmentType.Destination);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove runway or airport legs from segments where they shouldn't exist.
     */
    removeDestLegFromSegments() {
        const plan = this.getFlightPlan();
        const destination = plan.destinationAirport;
        const hasArrival = plan.procedureDetails.arrivalIndex > -1;
        const hasApproach = plan.procedureDetails.approachIndex > -1 || plan.getUserData('visual_approach');
        const destinationSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
        const destinationSegment = plan.getSegment(destinationSegmentIndex);
        if (hasApproach && destination) {
            if (hasArrival) {
                const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
                const arrival = plan.getSegment(arrivalSegmentIndex);
                const lastArrivalLegIcao = arrival.legs[arrival.legs.length - 1].leg.fixIcao;
                if (lastArrivalLegIcao === destination || lastArrivalLegIcao.search('R') === 0) {
                    this.planRemoveLeg(arrivalSegmentIndex, arrival.legs.length - 1);
                }
            }
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
        else if (hasArrival && destination) {
            if (destinationSegment.legs.length > 0) {
                this.planClearSegment(destinationSegmentIndex, FlightPlanSegmentType.Destination);
            }
        }
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getFlightPlan();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     */
    invertFlightplan() {
        var _a;
        const plan = this.getFlightPlan();
        const activeLegIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        if (!Simplane.getIsGrounded() && activeLegIcao) {
            this.createDirectToRandom(activeLegIcao);
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyPrimaryFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyPrimaryFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyPrimaryFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.calculate(0);
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (oneWayRunway) {
            plan.setOriginAirport(facility.icao);
            plan.setOriginRunway(oneWayRunway);
        }
        else if (plan.originAirport == facility.icao && plan.procedureDetails.originRunway) {
            const originLeg = FmsUtils.buildRunwayLeg(facility, plan.procedureDetails.originRunway, true);
            insertProcedureObject.procedureLegs.splice(0, 1, originLeg);
        }
        else {
            plan.setOriginAirport(facility.icao);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        this.setVerticalData(plan, segmentIndex);
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = FmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            runwayTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getFlightPlan();
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                if (plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport && plan.destinationAirport !== facility.icao && plan.activeLateralLeg === plan.length - 1) {
                    const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                    const newDestinationLeg = FlightPlan.createLeg({ fixIcao: plan.destinationAirport, type: LegType.TF });
                    this.planAddLeg(lastEnrouteSegmentIndex, newDestinationLeg);
                }
            }
        }
        if (plan.procedureDetails.approachIndex < 0) {
            plan.setDestinationAirport(facility.icao);
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState();
        if (plan.procedureDetails.approachIndex > -1) {
            insertProcedureObject.procedureLegs.pop();
        }
        else if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                insertProcedureObject.procedureLegs.pop();
                handleDirectToDestination = true;
            }
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        this.removeDestLegFromSegments();
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        else if (directToState === DirectToState.TOEXISTING && directTargetLeg && directTargetLeg.fixIcao === plan.destinationAirport) {
            this.removeDirectToExisting();
            this.createDirectToRandom(plan.destinationAirport);
        }
        this.setVerticalData(plan, segmentIndex);
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            enRouteTransition.legs.forEach((leg) => {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            });
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        const destinationLeg = oneWayRunway
            ? FmsUtils.buildRunwayLeg(facility, oneWayRunway, false)
            : FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.TF,
                fixIcao: facility.icao
            });
        insertProcedureObject.procedureLegs.push(destinationLeg);
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        if (this.getDirectToState() === DirectToState.TOEXISTING) {
            const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
            if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
                const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
                const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
                const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
                plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
                plan.addLeg(directTargetSegmentIndex, destinationLeg);
                plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, LegDefinitionFlags.DirectTo);
                plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, LegDefinitionFlags.DirectTo);
                const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, LegDefinitionFlags.DirectTo);
                const newActiveLegIndex = plan.getLegIndexFromLeg(newActiveLeg);
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
                plan.planIndex !== this.flightPlanner.activePlanIndex && plan.calculate(newActiveLegIndex);
                return true;
            }
        }
        return false;
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method manage the destination leg in the last enroute segment.
     * @param plan is the flight plan.
     * @param currentDestination is the currently set destination airport icao.
     */
    manageAirportLeg(plan, currentDestination) {
        if (plan.procedureDetails.arrivalIndex > -1 || !currentDestination || Simplane.getIsGrounded()) {
            //if we don't have a destination set, or an arrival is selected, don't add the airport to enroute
            return;
        }
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const segment = plan.getSegment(lastEnrouteSegmentIndex);
        const lastLegIndex = segment.legs.length - 1;
        if (currentDestination && (lastLegIndex < 0 || segment.legs[lastLegIndex].leg.fixIcao !== currentDestination)) {
            //if a destination is set, AND either (a) the last enroute segment is empty OR (b) the last enroute segment isn't empty and
            //the last leg of the last enroute segment is not already the current destination
            this.planAddLeg(lastEnrouteSegmentIndex, FlightPlan.createLeg({ fixIcao: currentDestination, type: LegType.TF }));
        }
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param approachIndex is the index of the approach procedure.
     * @param approachTransitionIndex is the index of the approach transition.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex is the starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal. False by default.
     * @param skipAutotune Whether to skip autotuning of the approach frequency, if one exists, to the nav radios. False
     * by default.
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    async insertApproach(facility, approachIndex, approachTransitionIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex, skipCourseReversal = false, skipAutotune = false) {
        var _a;
        const plan = this.getFlightPlan();
        let visualRunway;
        if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
            if (!visualRunway) {
                return false;
            }
        }
        const opId = ++this.insertApproachOpId;
        const insertProcedureObject = await this.buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal);
        if (opId !== this.insertApproachOpId) {
            return false;
        }
        let skipDestinationLegCheck = false;
        const approachRunway = insertProcedureObject.runway;
        const approachRunwayIcao = approachRunway ? RunwayUtils.getRunwayFacilityIcao(facility, approachRunway) : undefined;
        const isDtoExistingToRunwayActive = approachRunway
            && this.getDirectToState() === DirectToState.TOEXISTING
            && plan.getLeg(plan.activeLateralLeg).leg.fixIcao[0] === 'R';
        const isDtoExistingToApproachRunway = isDtoExistingToRunwayActive && approachRunway && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === approachRunwayIcao;
        let dtoExistingToRunwayIcao = '';
        let dtoExistingToRunwayCourse = undefined;
        if (isDtoExistingToRunwayActive) {
            const dtoLeg = plan.getLeg(plan.activeLateralLeg);
            dtoExistingToRunwayIcao = dtoLeg.leg.fixIcao;
            dtoExistingToRunwayCourse = dtoLeg.leg.type === LegType.DF ? undefined : dtoLeg.leg.course;
            // Do not remove the destination runway leg if it is part of an arrival and the target of a direct to existing
            skipDestinationLegCheck = plan.getSegment(plan.directToData.segmentIndex).segmentType === FlightPlanSegmentType.Arrival;
        }
        if (visualRunway) {
            plan.setUserData('visual_approach', `${visualRunway.designation}`);
        }
        else if (plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.setApproach(facility.icao, approachIndex, approachTransitionIndex);
        if (plan.procedureDetails.arrivalIndex < 0) {
            if (!this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute)) {
                this.manageAirportLeg(plan, plan.destinationAirport);
            }
            else {
                skipDestinationLegCheck = true;
            }
        }
        plan.setDestinationAirport(facility.icao);
        if (!skipDestinationLegCheck) {
            this.removeDestLegFromSegments();
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
        }
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            var _a;
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            let flags = (_a = l.legDefinitionFlags) !== null && _a !== void 0 ? _a : LegDefinitionFlags.None;
            if (isMissedLeg) {
                flags |= LegDefinitionFlags.MissedApproach;
            }
            this.planAddLeg(segmentIndex, l, undefined, flags);
        });
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = plan.getSegment(segmentIndex).legs[0];
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_a = facility.approaches[approachIndex].missedLegs) !== null && _a !== void 0 ? _a : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, LegDefinitionFlags.MissedApproach);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, LegDefinitionFlags.MissedApproach);
                    }
                }
            }
        }
        const approachType = visualRunway ? AdditionalApproachType.APPROACH_TYPE_VISUAL : facility.approaches[approachIndex].approachType;
        const rnavTypeFlag = visualRunway ? RnavTypeFlags.None : FmsUtils.getBestRnavType(facility.approaches[approachIndex].rnavTypeFlags);
        const approachIsCircling = !visualRunway && !facility.approaches[approachIndex].runway ? true : false;
        this.setApproachDetails(true, approachType, rnavTypeFlag, false, approachIsCircling);
        this.setVerticalData(plan, segmentIndex);
        this.loadApproachFrequency(facility, approachIndex);
        if (!skipAutotune) {
            this.setLocFrequency(1);
            this.setLocFrequency(2);
        }
        await plan.calculate();
        if (opId !== this.insertApproachOpId) {
            return false;
        }
        if (isDtoExistingToRunwayActive && this.getDirectToState() !== DirectToState.TOEXISTING) {
            // Direct To Existing to the destination runway was canceled as a result of adding the approach
            if (isDtoExistingToApproachRunway) {
                // DTO target runway matches the runway of the loaded approach -> need to reactivate DTO to the new runway leg
                // in the approach
                const runwayLegIndex = plan.getSegment(segmentIndex).legs.findIndex(leg => leg.leg.fixIcao === approachRunwayIcao);
                if (runwayLegIndex >= 0) {
                    this.createDirectToExisting(segmentIndex, runwayLegIndex, dtoExistingToRunwayCourse);
                }
            }
            else {
                // DTO target runway does not match the runway of the loaded approach (or the approach is circling only) ->
                // activate DTO random to the old runway
                this.createDirectToRandom(dtoExistingToRunwayIcao, dtoExistingToRunwayCourse);
            }
        }
        return true;
    }
    /**
     * Method to insert the approach legs.
     * @param facility The facility to build legs from.
     * @param approachIndex The approach procedure index to build legs from.
     * @param approachTransitionIndex The transition index to build legs from.
     * @param visualRunway If this is a visual approach, the visual approach one way runway object.
     * @param transStartIndex The starting leg index for the transition, if any.
     * @param skipCourseReversal Whether to skip the course reversal.
     * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
     * into the flight plan.
     */
    async buildApproachLegs(facility, approachIndex, approachTransitionIndex, visualRunway, transStartIndex, skipCourseReversal) {
        const isVisual = !!visualRunway;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const approach = isVisual ? FmsUtils.buildVisualApproach(facility, visualRunway, 1, 2.5) : facility.approaches[approachIndex];
        const transition = approach.transitions[approachTransitionIndex];
        const isVtf = approachTransitionIndex < 0;
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = transStartIndex !== undefined ? transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const lastTransitionLeg = insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1];
        if (isVtf) {
            insertProcedureObject.procedureLegs.push(FlightPlan.createLeg({ type: LegType.Discontinuity }));
        }
        const finalLegs = approach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && lastTransitionLeg && this.isDuplicateIFLeg(lastTransitionLeg, leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] = this.mergeDuplicateLegData(lastTransitionLeg, leg);
                continue;
            }
            if (!isVisual && leg.fixIcao[0] === 'R') {
                const approachRunway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = FmsUtils.buildRunwayLeg(facility, approachRunway, false);
                    runwayLeg.altitude1 += 15; //Runway leg altitude should be 50 feet above threshold
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = visualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (approach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(approach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
                if (isVtf && BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    await this.insertVtfLegs(insertProcedureObject, leg, finalLegs[i - 1], finalLegs[i + 1]);
                }
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageFafAltitudeRestriction(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            if (skipCourseReversal) {
                this.tryRemoveCourseReversal(insertProcedureObject);
            }
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && approach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(facility, approach.runwayNumber, approach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Inserts vectors-to-final legs into an insert procedure object. Vectors to final legs consist of a discontinuity
     * leg followed by a CF leg to the final approach fix. The course of the CF leg (the vectors-to-final course) is
     * defined as follows:
     * * If the leg to the faf is a CF leg, the VTF course is equal to the CF leg course.
     * * If the leg to the faf is not an IF leg, the VTF course is defined by the great-circle path from the fix
     * immediately prior to the faf to the faf.
     * * If the leg to the faf is an IF leg, the VTF course is defined by the great-circle path from the faf to the fix
     * immediately following it.
     *
     * If a VTF course cannot be defined, then no vectors-to-final legs are inserted.
     * @param proc The insert procedure object to which to insert the vectors-to-final legs.
     * @param fafLeg The leg to the final approach fix in the procedure.
     * @param prevLeg The leg immediately prior to the faf leg.
     * @param nextLeg The leg immediately after the faf leg.
     */
    async insertVtfLegs(proc, fafLeg, prevLeg, nextLeg) {
        if (fafLeg.type === LegType.CF) {
            // faf leg is a CF -> copy the leg into the VTF sequence.
            const discoLeg = FlightPlan.createLeg({ type: LegType.ThruDiscontinuity });
            discoLeg.legDefinitionFlags = LegDefinitionFlags.VectorsToFinal;
            proc.procedureLegs.push(discoLeg);
            proc.procedureLegs.push(Object.assign({ legDefinitionFlags: LegDefinitionFlags.VectorsToFinal }, fafLeg));
        }
        else {
            try {
                const fafFacility = await this.facLoader.getFacility(ICAO.getFacilityType(fafLeg.fixIcao), fafLeg.fixIcao);
                const fafPoint = Fms.geoPointCache[0].set(fafFacility);
                let course;
                if (fafLeg.type === LegType.IF) {
                    // faf leg is an IF, meaning it is the first leg in the approach -> get the course from the next leg.
                    let nextLegFixIcao = '';
                    switch (nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                        case LegType.HF:
                        case LegType.HM:
                        case LegType.HA:
                            nextLegFixIcao = nextLeg.fixIcao;
                    }
                    const nextLegFacility = await this.facLoader.getFacility(ICAO.getFacilityType(nextLegFixIcao), nextLegFixIcao);
                    course = MagVar.trueToMagnetic(fafPoint.bearingTo(nextLegFacility), fafPoint);
                }
                else {
                    // faf leg is not the first leg in the approach -> get the course from the previous leg.
                    let prevLegFixIcao = '';
                    switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                        case LegType.HF:
                        case LegType.HM:
                        case LegType.HA:
                            prevLegFixIcao = prevLeg.fixIcao;
                    }
                    const prevLegFacility = await this.facLoader.getFacility(ICAO.getFacilityType(prevLegFixIcao), prevLegFixIcao);
                    course = MagVar.trueToMagnetic(fafPoint.bearingFrom(prevLegFacility), fafPoint);
                }
                const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
                discoLeg.legDefinitionFlags = LegDefinitionFlags.VectorsToFinal;
                const vtfLeg = FlightPlan.createLeg({
                    type: LegType.CF,
                    fixIcao: fafLeg.fixIcao,
                    course,
                    fixTypeFlags: fafLeg.fixTypeFlags,
                    altDesc: fafLeg.altDesc,
                    altitude1: fafLeg.altitude1,
                    altitude2: fafLeg.altitude2
                });
                vtfLeg.legDefinitionFlags = LegDefinitionFlags.VectorsToFinal;
                proc.procedureLegs.push(discoLeg);
                proc.procedureLegs.push(vtfLeg);
            }
            catch (_a) {
                // noop
            }
        }
    }
    /**
     * Manages the altitude constraints when adding a procedure by creating a VerticalData object for each leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index for the inserted procedure.
     */
    setVerticalData(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        for (let l = 0; l < segment.legs.length; l++) {
            const leg = segment.legs[l];
            const altitude1 = leg.leg.altitude1;
            const altitude2 = leg.leg.altitude2;
            const altDesc = leg.leg.altDesc;
            const verticalData = {
                altDesc: altDesc,
                altitude1: altitude1,
                altitude2: altitude2
            };
            plan.setLegVerticalData(segmentIndex, l, verticalData);
        }
    }
    /**
     * Method to set a user altitude constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @param altitude The altitude to set the constraint at; if undefined, delete user constraint.
     * @param revert Whether to revert the constraint data to the nav data constraint.
     */
    setUserConstraint(segmentIndex, segmentLegIndex, altitude, revert = false) {
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            const verticalData = {
                altDesc: altitude !== undefined ? AltitudeRestrictionType.At : AltitudeRestrictionType.Unused,
                altitude1: altitude !== undefined ? UnitType.FOOT.convertTo(altitude, UnitType.METER) : 0,
                altitude2: 0
            };
            if (revert) {
                const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
                if (leg !== null) {
                    const altitude1 = leg.leg.altitude1;
                    const altitude2 = leg.leg.altitude2;
                    const altDesc = leg.leg.altDesc;
                    verticalData.altDesc = altDesc;
                    verticalData.altitude1 = altitude1;
                    verticalData.altitude2 = altitude2;
                }
            }
            plan.setLegVerticalData(segmentIndex, segmentLegIndex, verticalData);
            const directToData = plan.directToData;
            if (this.getDirectToState() === DirectToState.TOEXISTING && segmentIndex === directToData.segmentIndex
                && segmentLegIndex === directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET) {
                plan.setLegVerticalData(segmentIndex, directToData.segmentLegIndex, verticalData);
            }
            plan.calculate();
        }
    }
    /**
     * Method to check if a leg has a user specified constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @returns Whether the leg has a user constraint.
     */
    isConstraintUser(segmentIndex, segmentLegIndex) {
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if ((leg === null || leg === void 0 ? void 0 : leg.verticalData.altDesc) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altDesc) || (leg === null || leg === void 0 ? void 0 : leg.verticalData.altitude1) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altitude1) || (leg === null || leg === void 0 ? void 0 : leg.verticalData.altitude2) !== (leg === null || leg === void 0 ? void 0 : leg.leg.altitude2)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to check if a leg constraint can be reverted to the nav data constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @returns Whether the leg has a nav data constraint to be reverted to.
     */
    hasConstraint(segmentIndex, segmentLegIndex) {
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
            if (leg !== null && leg.leg.altDesc !== AltitudeRestrictionType.Unused) {
                switch (leg.leg.altDesc) {
                    case AltitudeRestrictionType.At:
                    case AltitudeRestrictionType.AtOrAbove:
                    case AltitudeRestrictionType.AtOrBelow:
                        return UnitType.METER.convertTo(leg.leg.altitude1, UnitType.FOOT);
                    case AltitudeRestrictionType.Between:
                        return UnitType.METER.convertTo(leg.leg.altitude2, UnitType.FOOT);
                }
            }
        }
        return undefined;
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageFafAltitudeRestriction(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.AtOrAbove;
                leg.altitude1 = alt;
                leg.altitude2 = 0;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) !== LegType.PI) {
                replacementLeg.altDesc = AltitudeRestrictionType.Unused;
                replacementLeg.altitude1 = 0;
                replacementLeg.altitude2 = 0;
            }
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getFlightPlan();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        this.planRemoveSegment(segmentIndex);
        if (plan.procedureDetails.approachIndex < 0 && plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        this.loadApproachFrequency();
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        const plan = this.getFlightPlan();
        const hasArrival = plan.procedureDetails.arrivalIndex >= 0;
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        if (hasArrival) {
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            const segment = plan.getSegment(lastEnrouteSegmentIndex);
            const lastLegIndex = segment && segment.legs.length > 0 ? segment.legs.length - 1 : 0;
            if (plan.destinationAirport && segment.legs[lastLegIndex] && segment.legs[lastLegIndex].leg.fixIcao === plan.destinationAirport) {
                this.planRemoveLeg(lastEnrouteSegmentIndex, lastLegIndex);
            }
            plan.setDestinationRunway();
            if (plan.procedureDetails.arrivalFacilityIcao && plan.procedureDetails.arrivalFacilityIcao !== plan.destinationAirport) {
                const arrivalFacility = await this.facLoader.getFacility(FacilityType.Airport, plan.procedureDetails.arrivalFacilityIcao);
                this.setDestination(arrivalFacility);
            }
        }
        plan.setApproach();
        this.planRemoveSegment(segmentIndex);
        if (plan.destinationAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            const destLegSegmentIndex = hasArrival
                ? this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival)
                : this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Destination);
            this.planAddOriginDestinationLeg(false, destLegSegmentIndex, airport, plan.procedureDetails.destinationRunway);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (plan.getUserData('visual_approach')) {
            plan.deleteUserData('visual_approach');
        }
        plan.calculate(0);
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param fplnIndex is the index of the flight plan in which to activate the leg.
     * @param inhibitImmediateSequence Whether to inhibit immediate automatic sequencing past the activated leg.
     */
    activateLeg(segmentIndex, legIndex, fplnIndex = 0, inhibitImmediateSequence = false) {
        const plan = this.getFlightPlan(fplnIndex);
        const indexInFlightplan = plan.getSegment(segmentIndex).offset + legIndex;
        if (fplnIndex === 0 && this.flightPlanner.activePlanIndex > 0) {
            this.flightPlanner.setActivePlanIndex(0);
        }
        if (this.missedApproachActive) {
            const segment = plan.getSegment(segmentIndex);
            if (segment.legs[legIndex] && !BitFlags.isAll(segment.legs[legIndex].flags, LegDefinitionFlags.MissedApproach)) {
                this.bus.getPublisher().pub('activate_missed_approach', false, true);
            }
        }
        if (fplnIndex === 0
            && (segmentIndex < plan.directToData.segmentIndex || (segmentIndex === plan.directToData.segmentIndex && legIndex <= plan.directToData.segmentLegIndex))) {
            this.removeDirectToExisting(indexInFlightplan);
        }
        else {
            plan.setCalculatingLeg(indexInFlightplan);
            plan.setLateralLeg(indexInFlightplan);
            plan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        const controlEvents = this.bus.getPublisher();
        controlEvents.pub('suspend_sequencing', false, true);
        if (inhibitImmediateSequence) {
            controlEvents.pub('lnav_inhibit_next_sequence', true, true);
        }
    }
    /**
     * Activates a vertical direct to a selected constraint.
     * @param constraintGlobalLegIndex The global leg index of the constraint to set vertical direct to.
     * @returns Whether the vertical direct was activated or not.
     */
    activateVerticalDirect(constraintGlobalLegIndex) {
        if (this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX) && this.verticalPathCalculator) {
            const lateralPlan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
            const verticalData = {
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0
            };
            if (lateralPlan.length > constraintGlobalLegIndex) {
                for (let i = 0; i < constraintGlobalLegIndex; i++) {
                    lateralPlan.setLegVerticalData(i, verticalData);
                }
                this.verticalPathCalculator.activateVerticalDirect(Fms.PRIMARY_PLAN_INDEX, constraintGlobalLegIndex);
                return true;
            }
        }
        return false;
    }
    /**
     * Checks whether an approach can be activated. An approach can be activated if and only if the primary flight plan
     * has a non-vectors-to-final approach loaded.
     * @returns Whether an approach can be activated.
     */
    canActivateApproach() {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        return FmsUtils.isApproachLoaded(plan) && !FmsUtils.isVtfApproachLoaded(plan);
    }
    /**
     * Activates an approach. Activating an approach activates a Direct To to the first approach waypoint of the primary
     * flight plan, and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary
     * flight plan does not have an approach loaded, this method has no effect.
     */
    activateApproach() {
        if (!this.canActivateApproach()) {
            return;
        }
        const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
        this.createDirectToExisting(approachSegmentIndex, 0);
        this.setLocFrequency(1, true);
        this.setLocFrequency(2, true);
    }
    /**
     * Checks whether vectors-to-final can be activated. VTF can be activated if and only if the primary flight plan has
     * an approach loaded.
     * @returns Whether vectors-to-final can be activated.
     */
    canActivateVtf() {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        return FmsUtils.isApproachLoaded(plan);
    }
    /**
     * Activates vectors-to-final. Activating vectors-to-final activates the primary flight plan's vectors-to-final leg,
     * and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary flight plan
     * has a non-VTF approach loaded, it will be replaced by its VTF counterpart. If the primary flight plan has no
     * approach loaded, this method has no effect.
     */
    async activateVtf() {
        if (!this.canActivateVtf()) {
            return;
        }
        const plan = this.getPrimaryFlightPlan();
        let vtfLeg = FmsUtils.getApproachVtfLeg(plan);
        let approachType = ApproachType.APPROACH_TYPE_UNKNOWN;
        if (!vtfLeg) {
            // if a VTF approach is not loaded; replace the current approach with its VTF counterpart.
            try {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.procedureDetails.approachFacilityIcao);
                const visApproachRwyDesignation = plan.getUserData('visual_approach');
                if (plan.procedureDetails.approachIndex >= 0) {
                    await this.insertApproach(airport, plan.procedureDetails.approachIndex, -1);
                    approachType = airport.approaches[plan.procedureDetails.approachIndex].approachType;
                }
                else {
                    let runway;
                    if (visApproachRwyDesignation) {
                        runway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, visApproachRwyDesignation);
                    }
                    if (!runway) {
                        return;
                    }
                    approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                    await this.insertApproach(airport, -1, -1, runway.direction, runway.runwayDesignator);
                }
                vtfLeg = FmsUtils.getApproachVtfLeg(plan);
            }
            catch (_a) {
                return;
            }
        }
        else {
            approachType = this.approachDetails.approachType;
        }
        if (!vtfLeg) {
            return;
        }
        const segment = plan.getSegmentFromLeg(vtfLeg);
        if (!segment) {
            return;
        }
        this.activateLeg(segment.segmentIndex, segment.legs.indexOf(vtfLeg), Fms.PRIMARY_PLAN_INDEX, true);
        this.setLocFrequency(1, true);
        this.setLocFrequency(2, true);
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                this.bus.getPublisher().pub('cdi_src_set', { type: NavSourceType.Nav, index: 1 }, true);
                break;
        }
    }
    /**
     * Method to check if the approach is VTF.
     * @returns whether the approach is VTF.
     */
    isApproachVtf() {
        if (!this.hasPrimaryFlightPlan()) {
            return false;
        }
        const plan = this.getPrimaryFlightPlan();
        return FmsUtils.isVtfApproachLoaded(plan);
    }
    /**
     * Method to check if there is a currently loaded missed approach to be activated.
     * @returns whether the approach can activate
     */
    canMissedApproachActivate() {
        const plan = this.getFlightPlan();
        if (this.cdiSource.type === NavSourceType.Gps && plan && plan.activeLateralLeg < plan.length - 1 && plan.segmentCount > 0) {
            const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            if (segmentIndex > 0) {
                const segment = plan.getSegment(segmentIndex);
                if (segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(segment.legs[segment.legs.length - 1].flags, LegDefinitionFlags.MissedApproach)) {
                    for (let i = 0; i < segment.legs.length; i++) {
                        const leg = segment.legs[i];
                        if (leg.leg.fixTypeFlags === FixTypeFlags.FAF) {
                            if (plan.activeLateralLeg - segment.offset >= i) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * Method to activate the missed approach.
     */
    activateMissedApproach() {
        if (this.canMissedApproachActivate()) {
            this.bus.getPublisher().pub('activate_missed_approach', true, true);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    createDirectToRandom(target, course) {
        const icao = typeof target === 'string' ? target : target.icao;
        const plan = this.flightPlanner.createFlightPlan(1);
        plan.setCalculatingLeg(0);
        plan.setLateralLeg(0);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            if (plan.getSegment(i) !== undefined) {
                plan.removeSegment(i);
            }
        }
        plan.insertSegment(0, FlightPlanSegmentType.RandomDirectTo, undefined, true);
        const segment = plan.getSegment(0);
        if (segment) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            // Dup the disco leg if we have a defined course so that DTO sequences are always 3 legs long
            const dtoOriginLeg = course === undefined ? this.createDTOOriginLeg(this.ppos) : discoLeg;
            const dtoTargetLeg = this.createDTODirectLeg(icao, undefined, course);
            plan.addLeg(0, discoLeg, 0, LegDefinitionFlags.DirectTo);
            plan.addLeg(0, dtoOriginLeg, 1, LegDefinitionFlags.DirectTo);
            plan.addLeg(0, dtoTargetLeg, 2, LegDefinitionFlags.DirectTo);
            plan.calculate(0);
            plan.setCalculatingLeg(2);
            plan.setLateralLeg(2);
            if (this.flightPlanner.activePlanIndex !== 1) {
                this.flightPlanner.setActivePlanIndex(1);
            }
            this.bus.getPublisher().pub('suspend_sequencing', false, true);
        }
    }
    /**
     * Method to create a direct to an existing waypoint in the plan. This method will also then call activateLeg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param legIndex is the index of the leg in the specified segment to activate as direct to.
     * @param course The magnetic course for the Direct To. If undefined, the Direct To will be initiated from the
     * airplane's present position.
     */
    createDirectToExisting(segmentIndex, legIndex, course) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[legIndex];
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && legIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState() === DirectToState.TOEXISTING) {
                this.removeDirectToExisting();
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        plan.setDirectToData(segmentIndex, legIndex + legIndexDelta);
        if (segment && leg) {
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            // Dup the disco leg if we have a defined course so that DTO sequences are always 3 legs long
            const dtoOriginLeg = course === undefined ? this.createDTOOriginLeg(this.ppos) : discoLeg;
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg, course);
            plan.addLeg(segmentIndex, discoLeg, legIndex + legIndexDelta + 1, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoOriginLeg, legIndex + legIndexDelta + 2, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoTargetLeg, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET, (leg.flags & LegDefinitionFlags.MissedApproach) | LegDefinitionFlags.DirectTo);
            plan.setLegVerticalData(segmentIndex, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET, leg.verticalData);
            this.activateLeg(segmentIndex, legIndex + legIndexDelta + FmsUtils.DTO_LEG_OFFSET);
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To DF leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @param course The magnetic course for the Direct To.
     * @returns a Direct-To DF leg.
     */
    createDTODirectLeg(icao, leg, course) {
        let legType;
        if (course === undefined) {
            legType = LegType.DF;
            const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
            course = planeHeading === 0 ? 360 : planeHeading;
        }
        else {
            legType = LegType.CF;
        }
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = legType;
            directLeg.course = course;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: legType,
                fixIcao: icao,
                course
            });
        }
    }
    /**
     * Empties the primary flight plan.
     */
    async emptyPrimaryFlightPlan() {
        if (!this.flightPlanner.hasFlightPlan(Fms.PRIMARY_PLAN_INDEX)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(Fms.PRIMARY_PLAN_INDEX);
        const directToState = this.getDirectToState();
        if (directToState === DirectToState.TOEXISTING || (directToState !== DirectToState.TORANDOM && !Simplane.getIsGrounded() && plan.activeLateralLeg > 0)) {
            const directToIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            if (directToIcao) {
                const facType = ICAO.getFacilityType(directToIcao);
                const fac = await this.facLoader.getFacility(facType, directToIcao);
                this.createDirectToRandom(fac);
            }
        }
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            this.planRemoveSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        plan.removeOriginAirport();
        plan.removeDestinationAirport();
        plan.setDirectToData(-1);
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false);
        plan.setCalculatingLeg(0);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
    }
    /**
     * Builds a flight plan to preview a procedure.
     * @param calculator The flight path calculator to assign to the preview plan.
     * @param facility The airport facility to load the approach from
     * @param procType The type of procedure to preview.
     * @param procIndex The procedure index selected.
     * @param transIndex The transition index selected.
     * @param oneWayRunway The one way runway to build the preview with, if any.
     * @param rwyTransIndex The runway transition index selected, if any.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param transStartIndex The transition start offset, if any.
     * @returns A Promise which is fulfilled with whether the preview plan was successfully built.
     */
    async buildProcedurePreviewPlan(calculator, facility, procType, procIndex, transIndex, oneWayRunway, rwyTransIndex, visualRunwayNumber, visualRunwayDesignator, transStartIndex) {
        var _a, _b;
        const plan = new FlightPlan(0, calculator, FlightPlanner.buildDefaultLegName);
        let procedureLegObject;
        switch (procType) {
            case ProcedureType.APPROACH:
                procedureLegObject = await this.buildApproachLegs(facility, procIndex, transIndex, undefined, transStartIndex !== undefined ? transStartIndex : 0);
                plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                break;
            case ProcedureType.ARRIVAL: {
                const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                procedureLegObject = this.buildArrivalLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                plan.addSegment(0, FlightPlanSegmentType.Arrival, undefined, false);
                break;
            }
            case ProcedureType.DEPARTURE: {
                const runwayIndex = rwyTransIndex !== null && rwyTransIndex !== void 0 ? rwyTransIndex : -1;
                procedureLegObject = this.buildDepartureLegs(facility, procIndex, transIndex, runwayIndex, oneWayRunway);
                plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, false);
                break;
            }
            case ProcedureType.VISUALAPPROACH:
                if (visualRunwayNumber !== undefined && visualRunwayDesignator !== undefined) {
                    const visualRunway = RunwayUtils.matchOneWayRunway(facility, visualRunwayNumber, visualRunwayDesignator);
                    procedureLegObject = await this.buildApproachLegs(facility, -1, -1, visualRunway);
                    plan.addSegment(0, FlightPlanSegmentType.Approach, undefined, false);
                }
                break;
        }
        if (procedureLegObject && procedureLegObject.procedureLegs.length > 0) {
            // remove discontinuity legs from the start of the procedure
            while (((_a = procedureLegObject.procedureLegs[0]) === null || _a === void 0 ? void 0 : _a.type) === LegType.Discontinuity) {
                procedureLegObject.procedureLegs.shift();
            }
            if (procedureLegObject.procedureLegs[0].type !== LegType.IF) {
                const replacementLeg = FlightPlan.createLeg({
                    type: LegType.IF,
                    fixIcao: procedureLegObject.procedureLegs[0].fixIcao,
                    fixTypeFlags: procedureLegObject.procedureLegs[0].fixTypeFlags,
                });
                procedureLegObject.procedureLegs.splice(0, 1, replacementLeg);
            }
            procedureLegObject.procedureLegs.forEach((l) => {
                var _a;
                plan.addLeg(0, l, undefined, (_a = l.legDefinitionFlags) !== null && _a !== void 0 ? _a : LegDefinitionFlags.None, false);
            });
            if (procType === ProcedureType.APPROACH) {
                // Adds missed approach legs
                if (!visualRunwayNumber && !visualRunwayDesignator && procedureLegObject.procedureLegs.length > 0) {
                    const missedLegs = (_b = facility.approaches[procIndex].missedLegs) !== null && _b !== void 0 ? _b : [];
                    if (missedLegs && missedLegs.length > 0) {
                        let maphIndex = -1;
                        for (let m = missedLegs.length - 1; m >= 0; m--) {
                            switch (missedLegs[m].type) {
                                case LegType.HA:
                                case LegType.HF:
                                case LegType.HM:
                                    maphIndex = m - 1;
                                    break;
                            }
                        }
                        for (let n = 0; n < missedLegs.length; n++) {
                            const newLeg = FlightPlan.createLeg(missedLegs[n]);
                            if (maphIndex > 0 && n === maphIndex) {
                                newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                                plan.addLeg(0, newLeg, undefined, LegDefinitionFlags.MissedApproach, false);
                            }
                            else {
                                plan.addLeg(0, newLeg, undefined, LegDefinitionFlags.MissedApproach, false);
                            }
                        }
                    }
                }
            }
            await plan.calculate(0);
            return plan;
        }
        else {
            return plan;
        }
    }
    /**
     * Builds a flight plan to preview procedure transitions.
     * @param calculator The flight path calculator to assign to the preview plan.
     * @param facility The airport facility to which the procedure to preview belongs.
     * @param procType The type of procedure to preview.
     * @param procIndex The index of the procedure to preview.
     * @param rwyTransIndex The index of the procedure's runway transition.
     * @returns The index of the procedure transition preview plan.
     */
    async buildProcedureTransitionPreviewPlan(calculator, facility, procType, procIndex, rwyTransIndex) {
        const plan = new FlightPlan(0, calculator, FlightPlanner.buildDefaultLegName);
        let legs;
        switch (procType) {
            case ProcedureType.DEPARTURE:
                if (facility.departures[procIndex] && rwyTransIndex !== undefined) {
                    legs = this.buildDepartureTransitionPreviewLegs(facility.departures[procIndex], rwyTransIndex);
                }
                break;
            case ProcedureType.ARRIVAL:
                if (facility.arrivals[procIndex] && rwyTransIndex !== undefined) {
                    legs = this.buildArrivalTransitionPreviewLegs(facility.arrivals[procIndex], rwyTransIndex);
                }
                break;
            case ProcedureType.APPROACH:
                if (facility.approaches[procIndex]) {
                    legs = this.buildApproachTransitionPreviewLegs(facility.approaches[procIndex]);
                }
                break;
        }
        if (legs && legs.length > 0) {
            plan.addSegment(0, FlightPlanSegmentType.Enroute, undefined, false);
            legs.forEach((l) => {
                plan.addLeg(0, l, undefined, 0, false);
            });
            await plan.calculate(0);
        }
        return plan;
    }
    /**
     * Builds a sequence of legs for a departure transition preview. The sequence consists of the legs of each departure
     * transition in order. Discontinuity legs separate legs of different transitions.
     * @param departure A departure.
     * @param rwyTransIndex The runway transition index of the departure.
     * @returns A sequence of legs for a departure transition preview.
     */
    buildDepartureTransitionPreviewLegs(departure, rwyTransIndex) {
        var _a;
        const runwayTransition = departure.runwayTransitions[rwyTransIndex];
        if (!runwayTransition && departure.runwayTransitions.length > 0) {
            return [];
        }
        const insertProcObject = { procedureLegs: [] };
        const legs = [];
        const preTransitionLegs = [];
        const lastCommonLeg = departure.commonLegs[departure.commonLegs.length - 1];
        const lastPreTransitionLeg = lastCommonLeg !== null && lastCommonLeg !== void 0 ? lastCommonLeg : runwayTransition.legs[runwayTransition.legs.length - 1];
        const secondLastPreTransitionLeg = lastPreTransitionLeg
            ? lastCommonLeg
                ? (_a = departure.commonLegs[departure.commonLegs.length - 2]) !== null && _a !== void 0 ? _a : runwayTransition.legs[runwayTransition.legs.length - 1]
                : runwayTransition.legs[runwayTransition.legs.length - 2]
            : undefined;
        secondLastPreTransitionLeg && preTransitionLegs.push(secondLastPreTransitionLeg);
        lastPreTransitionLeg && preTransitionLegs.push(lastPreTransitionLeg);
        const transitions = departure.enRouteTransitions;
        for (let i = 0; i < transitions.length; i++) {
            const transition = transitions[i];
            if (transition.legs.length > 0) {
                insertProcObject.procedureLegs.push(...preTransitionLegs);
                for (let j = 0; j < transition.legs.length; j++) {
                    const leg = transition.legs[j];
                    if (j === 0 && lastPreTransitionLeg && this.isDuplicateIFLeg(lastPreTransitionLeg, leg)) {
                        continue;
                    }
                    insertProcObject.procedureLegs.push(leg);
                }
                this.tryCleanupHold(insertProcObject);
                legs.push(...insertProcObject.procedureLegs, FlightPlan.createLeg({ type: LegType.Discontinuity }));
                insertProcObject.procedureLegs.length = 0;
            }
        }
        return legs;
    }
    /**
     * Builds a sequence of legs for an arrival transition preview. The sequence consists of the legs of each arrival
     * transition in order. Discontinuity legs separate legs of different transitions.
     * @param arrival An arrival.
     * @param rwyTransIndex The runway transition index of the arrival.
     * @returns A sequence of legs for an arrival transition preview.
     */
    buildArrivalTransitionPreviewLegs(arrival, rwyTransIndex) {
        var _a;
        const runwayTransition = arrival.runwayTransitions[rwyTransIndex];
        if (!runwayTransition && arrival.runwayTransitions.length > 0) {
            return [];
        }
        const insertProcObject = { procedureLegs: [] };
        const legs = [];
        const firstCommonLeg = arrival.commonLegs[0];
        const firstPostTransitionLeg = firstCommonLeg !== null && firstCommonLeg !== void 0 ? firstCommonLeg : runwayTransition.legs[0];
        const secondPostTransitionLeg = firstPostTransitionLeg
            ? firstCommonLeg
                ? (_a = arrival.commonLegs[1]) !== null && _a !== void 0 ? _a : runwayTransition.legs[0]
                : runwayTransition.legs[1]
            : undefined;
        const transitions = arrival.enRouteTransitions;
        for (let i = 0; i < transitions.length; i++) {
            const transition = transitions[i];
            if (transition.legs.length > 0) {
                for (let j = 0; j < transition.legs.length; j++) {
                    insertProcObject.procedureLegs.push(transition.legs[j]);
                }
                const lastTransitionLeg = insertProcObject.procedureLegs[insertProcObject.procedureLegs.length - 1];
                if (firstPostTransitionLeg && !this.isDuplicateIFLeg(lastTransitionLeg, firstPostTransitionLeg)) {
                    insertProcObject.procedureLegs.push(firstPostTransitionLeg);
                    // need to add the second post-transition leg if the last transition leg is a PI leg and first post-
                    // transition leg is an IF so that the calculator can get an inbound course for the PI leg.
                    if (lastTransitionLeg.type === LegType.PI && firstPostTransitionLeg.type === LegType.IF && secondPostTransitionLeg) {
                        insertProcObject.procedureLegs.push(secondPostTransitionLeg);
                    }
                }
                this.tryInsertIFLeg(insertProcObject);
                this.tryCleanupHold(insertProcObject);
                legs.push(...insertProcObject.procedureLegs, FlightPlan.createLeg({ type: LegType.Discontinuity }));
                insertProcObject.procedureLegs.length = 0;
            }
        }
        return legs;
    }
    /**
     * Builds a sequence of legs for an approach transition preview. The sequence consists of the legs of each approach
     * transition in order, followed by the first leg of the final approach. Discontinuity legs separate legs of
     * different transitions.
     * @param approach An approach.
     * @returns A sequence of legs for an approach transition preview.
     */
    buildApproachTransitionPreviewLegs(approach) {
        const insertProcObject = { procedureLegs: [] };
        const legs = [];
        const firstFinalLeg = approach.finalLegs[0];
        const secondFinalLeg = approach.finalLegs[1];
        const transitions = approach.transitions;
        for (let i = 0; i < transitions.length; i++) {
            const transition = transitions[i];
            if (transition.legs.length > 0) {
                for (let j = 0; j < transition.legs.length; j++) {
                    insertProcObject.procedureLegs.push(transition.legs[j]);
                }
                const lastTransitionLeg = insertProcObject.procedureLegs[insertProcObject.procedureLegs.length - 1];
                if (firstFinalLeg && !this.isDuplicateIFLeg(lastTransitionLeg, firstFinalLeg)) {
                    insertProcObject.procedureLegs.push(firstFinalLeg);
                    // need to add the second final approach leg if the last transition leg is a PI leg and first final leg is
                    // an IF so that the calculator can get an inbound course for the PI leg.
                    if (lastTransitionLeg.type === LegType.PI && firstFinalLeg.type === LegType.IF && secondFinalLeg) {
                        insertProcObject.procedureLegs.push(secondFinalLeg);
                    }
                }
                this.tryInsertIFLeg(insertProcObject);
                this.tryCleanupHold(insertProcObject);
                legs.push(...insertProcObject.procedureLegs, FlightPlan.createLeg({ type: LegType.Discontinuity }));
                insertProcObject.procedureLegs.length = 0;
            }
        }
        return legs;
    }
    /**
     * Builds a temporary flight plan to preview an airway entry.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the index of the temporary flight plan.
     */
    buildAirwayPreviewSegment(airway, entry, exit) {
        this.flightPlanner.deleteFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const plan = this.flightPlanner.createFlightPlan(Fms.PROC_PREVIEW_PLAN_INDEX);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        plan.insertSegment(0, FlightPlanSegmentType.Enroute, airway.name, false);
        if (airwayLegObject.procedureLegs.length > 0) {
            airwayLegObject.procedureLegs.forEach((l) => {
                plan.addLeg(0, l, undefined, LegDefinitionFlags.None, false);
            });
            plan.calculate(0, true);
        }
        return Fms.PROC_PREVIEW_PLAN_INDEX;
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getFlightPlan();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}.${ICAO.getIdent(exit.icao)}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        if (entrySegmentIndex < plan.directToData.segmentIndex
            || (entrySegmentIndex === plan.directToData.segmentIndex && entrySegmentLegIndex < plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
        }
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, removeLegsSegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                const leg = segment.legs[i].leg;
                this.planAddLeg(nextSegmentIndex, leg);
                this.planRemoveLeg(segmentIndex, i);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            for (let i = legIndex + 1; i < segment.legs.length; i++) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getFlightPlan();
        let combineSegments = false;
        const nextSegmentIsAirway = plan.getSegment(segmentIndex + 1).airway;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            let entryLeg = undefined;
            if (nextSegmentIsAirway) {
                const segment = plan.getSegment(segmentIndex);
                entryLeg = segment.legs[segment.legs.length - 1].leg;
            }
            this.planRemoveSegment(segmentIndex);
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            if (priorSegmentEnrouteNonAirway && entryLeg !== undefined) {
                this.planAddLeg(segmentIndex - 1, entryLeg);
            }
            else if (entryLeg !== undefined) {
                const newSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                this.planAddLeg(newSegmentIndex, entryLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.flags);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Inserts a hold-at-waypoint leg to the primary flight plan. The hold leg will be inserted immediately after the
     * specified parent leg. The hold leg must have the same fix as the parent leg.
     * @param planIndex The plan index to add the hold to.
     * @param segmentIndex The index of the segment that contains the hold's parent leg.
     * @param legIndex The index of the hold's parent leg in its segment.
     * @param holdLeg The hold leg to add.
     * @returns Whether the hold-at-waypoint leg was successfully inserted.
     */
    insertHold(planIndex, segmentIndex, legIndex, holdLeg) {
        const plan = this.hasFlightPlan(planIndex) && this.getFlightPlan(planIndex);
        if (!plan) {
            return false;
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex + 1);
        if ((prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.fixIcao) !== holdLeg.fixIcao) {
            return false;
        }
        if (planIndex === Fms.PRIMARY_PLAN_INDEX) {
            this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
            return true;
        }
        else {
            plan.addLeg(segmentIndex, holdLeg);
            this.bus.getPublisher().pub('suspend_sequencing', false, true);
            return true;
        }
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     */
    planAddLeg(segmentIndex, leg, index, flags = 0, notify = true) {
        const plan = this.getFlightPlan();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        if (dtoSegmentIndex >= 0
            && (segmentIndex < dtoSegmentIndex
                || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex))) {
            this.removeDirectToExisting();
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index !== undefined ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach
            && addIndex > 0
            && BitFlags.isAll(segment.legs[addIndex - 1].flags, LegDefinitionFlags.MissedApproach)) {
            flags |= LegDefinitionFlags.MissedApproach;
        }
        plan.addLeg(segmentIndex, leg, index, flags, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                const newActiveLegIndex = plan.activeLateralLeg + 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, segmentLegIndex, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        const plan = this.getFlightPlan();
        if (segmentIndex < 0 || segmentIndex >= plan.segmentCount) {
            return false;
        }
        const toRemoveLeg = plan.getSegment(segmentIndex).legs[segmentLegIndex];
        if (!toRemoveLeg) {
            return false;
        }
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        const isDirectToExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, segmentLegIndex);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex);
        }
        else {
            removed = plan.removeLeg(segmentIndex, segmentLegIndex, notify) !== null;
            if (!removed) {
                return false;
            }
            const dtoLegIndex = plan.directToData.segmentLegIndex;
            const dtoSegmentIndex = plan.directToData.segmentIndex;
            if (!skipCancelDirectTo
                && dtoSegmentIndex >= 0
                && (segmentIndex < dtoSegmentIndex
                    || (segmentIndex === dtoSegmentIndex && segmentLegIndex <= dtoLegIndex))) {
                // Need to adjust direct to data to compensate for removed leg.
                if (segmentIndex === dtoSegmentIndex) {
                    plan.directToData.segmentLegIndex--;
                }
                if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && segmentLegIndex === dtoLegIndex) {
                    // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                    const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg.fixIcao;
                    this.createDirectToRandom(directIcao);
                }
                this.removeDirectToExisting(plan.activeLateralLeg - 1);
            }
            else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        const prevLeg = removeLegGlobalIndex - 1 >= 0 ? plan.getLeg(removeLegGlobalIndex - 1) : null;
        const nextLeg = removeLegGlobalIndex < plan.length ? plan.getLeg(removeLegGlobalIndex) : null;
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck) {
            this.checkAndRemoveEmptySegment(plan, segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Handles removing a leg that is either in an airway segment or is an entry for an airway segment.
     * @param plan The flight plan containing the leg to remove.
     * @param airwayLegType The type of the leg to remove with respect to its associated airway.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @returns Whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex) {
        var _a, _b;
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        let removed = false;
        let needReconcileDto = plan.directToData.segmentIndex >= 0;
        if (segmentIndex < plan.directToData.segmentIndex
            || (segmentIndex === plan.directToData.segmentIndex && segmentLegIndex <= plan.directToData.segmentLegIndex)) {
            // If there are DTO legs after the leg we are removing, we need to remove them (canceling the active DTO existing if necessary)
            if (this.getDirectToState() === DirectToState.TOEXISTING && segmentLegIndex === plan.directToData.segmentLegIndex) {
                // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + FmsUtils.DTO_LEG_OFFSET].leg.fixIcao;
                this.createDirectToRandom(directIcao);
            }
            this.removeDirectToExisting();
            needReconcileDto = false;
        }
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE: {
                const segment = plan.getSegment(segmentIndex);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex > 0) {
                    // Need to rename the airway segment with the new exit (if we removed the first leg after the entry, the
                    // airway segment will be deleted so no need to bother)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    plan.setAirway(segmentIndex, segment.airway.replace(/\..*/, `.${segment.legs[segmentLegIndex - 1].name}`));
                }
                // We need to move the leg immediately after the removed leg to the next enroute segment
                // (if the next enroute segment does not exist we will create one)
                if (plan.segmentCount <= segmentIndex + 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                }
                const legAfterRemoved = segment.legs[segmentLegIndex].leg;
                plan.addLeg(segmentIndex + 1, legAfterRemoved, 0);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex < segment.legs.length) {
                    // There is at least one more leg in the original airway segment after the one we moved to the next enroute
                    // segment -> move these remaining legs into a new airway segment
                    const newEntrySegment = plan.getSegment(segmentIndex + 1);
                    let newAirwaySegmentIndex = segmentIndex + 2;
                    if (newEntrySegment.legs.length > 1) {
                        // need to split the segment containing the entry leg of the new airway segment
                        newAirwaySegmentIndex = this.splitSegment(plan, segmentIndex + 1, 0);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const airwayName = segment.airway.replace(/\..*/, `.${segment.legs[segment.legs.length - 1].name}`);
                    plan.insertSegment(newAirwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
                    while (segment.legs.length > segmentLegIndex) {
                        const leg = segment.legs[segmentLegIndex].leg;
                        plan.removeLeg(segmentIndex, segmentLegIndex);
                        plan.addLeg(newAirwaySegmentIndex, leg);
                    }
                    // If the newly added airway segment is the last enroute segment, we need to insert an empty enroute segment
                    // after it to ensure that the last enroute segment in the plan is not an airway segment
                    if (newAirwaySegmentIndex >= plan.segmentCount - 1 || plan.getSegment(newAirwaySegmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                        plan.insertSegment(newAirwaySegmentIndex + 1, FlightPlanSegmentType.Enroute);
                    }
                }
                removed = true;
                break;
            }
            case AirwayLegType.ENTRY: {
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into the previous enroute segment to serve as the new entry leg.
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 1);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into a newly created enroute segment placed before the airway segment to serve as the new entry leg.
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 2);
                    this.planAddLeg(segmentIndex + 1, leg);
                }
                removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                break;
            }
            case AirwayLegType.EXIT: {
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the airway segment, so just delete the segment.
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    // Remove the leg, then change the name of the airway segment to reflect the new exit waypoint.
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[segmentLegIndex - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                }
                break;
            }
            case AirwayLegType.EXIT_ENTRY: {
                // We need to move the first leg in the next airway segment out of that segment and into an enroute segment
                // before the next airway segment.
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                plan.removeLeg(segmentIndex + 1, 0);
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the first airway segment, so just remove the segment.
                    plan.removeSegment(segmentIndex);
                    let prevSegmentIndex = segmentIndex - 1;
                    const prevSegment = plan.getSegment(prevSegmentIndex);
                    if (prevSegment.segmentType !== FlightPlanSegmentType.Enroute || prevSegment.airway !== undefined) {
                        plan.insertSegment(segmentIndex, FlightPlanSegmentType.Enroute);
                        prevSegmentIndex = segmentIndex;
                    }
                    plan.addLeg(prevSegmentIndex, leg);
                }
                else {
                    // Remove the leg from the first airway segment, then change the name of the airway segment to reflect the
                    // new exit waypoint.
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                    plan.addLeg(segmentIndex + 1, leg);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[segmentLegIndex - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                removed = true;
            }
        }
        if (removed) {
            if (needReconcileDto) {
                FmsUtils.reconcileDirectToData(plan);
            }
            if (removeLegGlobalIndex <= plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        return removed;
    }
    /**
     * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
     * segments that are followed by another Enroute segment are eligible to be removed if empty.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment to check.
     * @returns Whether the segment was removed.
     */
    checkAndRemoveEmptySegment(plan, segmentIndex) {
        if (this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
            const prevSegmentIndex = segmentIndex - 1;
            const nextSegmentIndex = segmentIndex;
            const prevSegment = prevSegmentIndex >= 0 ? plan.getSegment(prevSegmentIndex) : undefined;
            const nextSegment = nextSegmentIndex < plan.segmentCount ? plan.getSegment(nextSegmentIndex) : undefined;
            if ((prevSegment === null || prevSegment === void 0 ? void 0 : prevSegment.segmentType) === FlightPlanSegmentType.Enroute
                && prevSegment.airway === undefined
                && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) === FlightPlanSegmentType.Enroute
                && nextSegment.airway === undefined) {
                // We are left with two consecutive non-airway enroute segments -> merge the two
                this.mergeSegments(plan, prevSegmentIndex);
            }
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                        return true;
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = FmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getFlightPlan();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getFlightPlan();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1) {
            const directIcao = plan.getLeg(plan.activeLateralLeg).leg.fixIcao;
            this.removeDirectToExisting();
            if (this.getDirectToState() !== DirectToState.TORANDOM) {
                this.createDirectToRandom(directIcao);
            }
        }
        const newActiveLegIndex = plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length);
        plan.setCalculatingLeg(newActiveLegIndex);
        plan.setLateralLeg(newActiveLegIndex);
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF
            && leg2.type !== LegType.CF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF
            || leg1.type === LegType.CF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getFlightPlan();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg1Index = plan.getLegIndexFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg2Index = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = BitFlags.isAll(leg1.flags, LegDefinitionFlags.DirectTo);
        const isLeg2DirectToLeg = BitFlags.isAll(leg2.flags, LegDefinitionFlags.DirectTo);
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        if ((!isLeg1InProc && isLeg2InProc)
            || (isLeg1InProc && isLeg2InProc && leg1Segment !== leg2Segment)
            || BitFlags.isAny(leg2.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP)) {
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1Index - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2Index - leg2Segment.offset;
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, LegDefinitionFlags.DirectTo);
                if (isDtoExistingActive) {
                    const newActiveLegIndex = preservedLegIndex + FmsUtils.DTO_LEG_OFFSET;
                    plan.setCalculatingLeg(newActiveLegIndex);
                    plan.setLateralLeg(newActiveLegIndex);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Converts an OBS course to a Direct-To. The OBS leg is assumed to be the currently active flight plan leg.
     * @param obsCourse The OBS course, in degrees magnetic.
     */
    convertObsToDirectTo(obsCourse) {
        const dtoState = this.getDirectToState();
        if (dtoState === DirectToState.TORANDOM) {
            // Just replace the DTO random with one with a custom course
            const dtoTargetIcao = this.getDirectToTargetIcao();
            this.createDirectToRandom(dtoTargetIcao, obsCourse);
        }
        else if (dtoState === DirectToState.TOEXISTING) {
            const dtoData = this.getPrimaryFlightPlan().directToData;
            this.createDirectToExisting(dtoData.segmentIndex, dtoData.segmentLegIndex, obsCourse);
        }
        else {
            const plan = this.getPrimaryFlightPlan();
            const segmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
            const segmentLegIndex = plan.getSegmentLegIndex(plan.activeLateralLeg);
            if (segmentIndex >= 0 && segmentLegIndex >= 0) {
                this.createDirectToExisting(segmentIndex, segmentLegIndex, obsCourse);
            }
        }
    }
    /**
     * Loads an approach frequency into the fms.
     * @param facility The airport facility.
     * @param approachIndex The approach Index.
     */
    loadApproachFrequency(facility, approachIndex) {
        this.approachFrequency.set(FmsUtils.getApproachFrequency(facility, approachIndex));
    }
    /**
     * Loads an approach frequency into the fms.
     * @param radioIndex The radio index to set (1 or 2).
     * @param forceNotify resets the subject to force a cross-instrument notification.
     */
    setLocFrequency(radioIndex, forceNotify = false) {
        const approachFrequency = this.approachFrequency.get();
        if (forceNotify) {
            this.approachFrequency.set(undefined);
            this.approachFrequency.set(approachFrequency);
        }
        if (approachFrequency === undefined || Math.abs(this.navActiveFreqs[radioIndex].get() - approachFrequency.freqMHz) < 0.001) {
            return;
        }
        const setActive = this.cdiSource.type === NavSourceType.Gps || this.cdiSource.index !== radioIndex;
        SimVar.SetSimVarValue(`K:NAV${radioIndex}_STBY_SET_HZ`, 'Hz', approachFrequency.freqMHz * 1000000);
        if (setActive) {
            SimVar.SetSimVarValue(`K:NAV${radioIndex}_RADIO_SWAP`, 'Bool', 1);
        }
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     * @param approachIsCircling Whether the approach is a circling approach.
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling) {
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive,
            approachIsCircling: approachIsCircling !== undefined ? approachIsCircling : this.approachDetails.approachIsCircling
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
            this.bus.getPublisher().pub('approach_available', approachDetails.approachIsActive && approachDetails.approachLoaded, true);
            this.bus.getPublisher().pub('gp_available', this.isGpAvailable(), true);
        }
    }
    /**
     * Checks whether the approach details indicate that a GP should be available for tracking and display.
     * @returns whether or not the GP is available.
     */
    isGpAvailable() {
        if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive && !this.approachDetails.approachIsCircling) {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    return true;
            }
        }
        return false;
    }
}
Fms.PRIMARY_PLAN_INDEX = 0;
Fms.DTO_RANDOM_PLAN_INDEX = 1;
Fms.PROC_PREVIEW_PLAN_INDEX = 2;
Fms.geoPointCache = [new GeoPoint(0, 0)];

/** The acceptable priority types for a given warning. */
var WarningType;
(function (WarningType) {
    WarningType[WarningType["Warning"] = 0] = "Warning";
    WarningType[WarningType["Caution"] = 1] = "Caution";
    WarningType[WarningType["Test"] = 2] = "Test";
    WarningType[WarningType["SoundOnly"] = 3] = "SoundOnly";
})(WarningType || (WarningType = {}));
/** The main logic for a system warning. */
class Warning {
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type, condition, shortText, longText, soundId, once) {
        this.type = type;
        this.shortText = shortText;
        this.longText = longText;
        this.soundId = soundId;
        this.condition = condition;
        this.once = once;
        this._triggered = false;
        if (this.soundId) {
            this._soundEventId = new Name_Z(this.soundId);
        }
    }
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText() {
        return this.shortText || this.longText ? true : false;
    }
    /**
     * The alert is being fired, take action.
     */
    trigger() {
        this._triggered = true;
    }
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description() {
        return `<${this.shortText}|${this.longText}|${this.soundId}>`;
    }
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered() {
        return this._triggered;
    }
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger() {
        return !this.once || !this._triggered;
    }
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId() {
        return this._soundEventId;
    }
}
/** The basic component for handling warning logic. */
class WarningManager {
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings, logicHost, textCb, soundCb) {
        this.warnings = warnings;
        this.logicHost = logicHost;
        this.textCb = textCb;
        this.soundCb = soundCb;
        this.curSndIdx = null;
        this.curTxtIdx = null;
        this.warnActiveStates = new Array();
        for (let i = 0; i < warnings.length; i++) {
            this.logicHost.addLogicAsNumber(warnings[i].condition, this.handleWarning.bind(this, i), 0);
            this.warnActiveStates.push(false);
        }
    }
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    handleWarning(warnIndex, active) {
        const warning = this.warnings[warnIndex];
        // Handle a warning that is going active.
        if (active && warning.canTrigger) {
            this.warnActiveStates[warnIndex] = true;
            warning.trigger();
            // Only worry about text if the warning has text.
            if (warning.hasText) {
                // If there is no existing text displayed, or text of a lower priority, replace it.
                if ((this.curTxtIdx == undefined || this.curTxtIdx > warnIndex)) {
                    // First, if the prior warning was a one-shot, force it to inactive so it won't be restored later.
                    if (this.curTxtIdx && this.warnings[this.curTxtIdx].once) {
                        this.warnActiveStates[this.curTxtIdx] = false;
                    }
                    this.textCb(warning);
                    this.curTxtIdx = warnIndex;
                }
            }
            // Now check for sound.
            if (this.soundCb !== undefined && warning.soundId) {
                // Make sure we have the right to play our sound.
                if (this.curSndIdx == undefined || this.curSndIdx > warnIndex) {
                    // Disable a prior sound, if one was playing.
                    if (this.curSndIdx && this.curSndIdx > warnIndex) {
                        this.soundCb(this.warnings[this.curSndIdx], false);
                        // If the prior warning was a one-shot, force it to inactive so it won't be restored.
                        if (this.warnings[this.curSndIdx].once) {
                            this.warnActiveStates[this.curSndIdx] = false;
                        }
                    }
                    this.soundCb(warning, true);
                    this.curSndIdx = warnIndex;
                }
            }
            // If that was a one-time alert, turn it off, too.
            if (warning.once) {
                this.handleWarning(warnIndex, 0);
            }
        }
        else if (!active) {
            this.warnActiveStates[warnIndex] = false;
            let isCurSnd = this.curSndIdx == warnIndex ? true : false;
            let isCurTxt = this.curTxtIdx == warnIndex ? true : false;
            // If this warning is the current active text or sound, we need to disable it.
            if (isCurSnd && this.soundCb) {
                this.soundCb(warning, false);
            }
            if (isCurTxt) {
                this.textCb(undefined);
            }
            // If either of those were true, let's see if there's anything else
            // of lower prirority that should be made active.
            if (isCurSnd || isCurTxt) {
                // We know there was no higher-priority warning, so we step through
                // everything lower than us.
                let i = warnIndex + 1;
                while ((isCurSnd || isCurTxt) && i < this.warnings.length) {
                    // Only continue this iteration if the next potential warning
                    // is active.
                    if (this.warnActiveStates[i]) {
                        const nextWarning = this.warnings[i];
                        // Make sure we can trigger the warning.   This will be false if
                        // it's a one-shot that's already triggered.  If so, just fall
                        // through to the next iteration.
                        if (nextWarning.canTrigger) {
                            // See if the lower priority warning has sound.  If so, activate.
                            if (isCurSnd && nextWarning.soundId && this.soundCb) {
                                this.soundCb(this.warnings[i], true);
                                this.curSndIdx = i;
                                // We can stop looking for another sound.
                                isCurSnd = false;
                            }
                            // Now do the same sort of thing for text.
                            if (isCurTxt && this.warnings[i].hasText) {
                                this.textCb(this.warnings[i]);
                                this.curTxtIdx = i;
                                // We can stop looking for another text.
                                isCurTxt = false;
                            }
                        }
                    }
                    // Move to the next warning on the list.
                    i++;
                }
            }
            // If we haven't yet set new sound or text, just nullify them.
            if (isCurSnd && this.soundCb) {
                this.curSndIdx = null;
            }
            if (isCurTxt) {
                this.curTxtIdx = null;
            }
        }
    }
}

/// <reference types="msfstypes/Pages/VCockpit/Instruments/Shared/utils/XMLLogic" />
/** Create a list of system warnings. */
class XMLWarningFactory {
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument) {
        this.instrument = instrument;
    }
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document) {
        const warnings = new Array();
        const configs = document.getElementsByTagName('VoicesAlerts');
        if (configs.length == 0) {
            return warnings;
        }
        const config = configs[0];
        for (const warn of config.children) {
            let type;
            const typeElem = warn.getElementsByTagName('Type');
            if (typeElem.length == 0) {
                continue;
            }
            switch (typeElem[0].textContent) {
                case 'Warning':
                    type = WarningType.Warning;
                    break;
                case 'Caution':
                    type = WarningType.Caution;
                    break;
                case 'Test':
                    type = WarningType.Test;
                    break;
                case 'SoundOnly':
                    type = WarningType.SoundOnly;
                    break;
                default:
                    continue;
            }
            let textElem = warn.getElementsByTagName('Condition');
            if (textElem.length == 0) {
                continue;
            }
            const condition = new CompositeLogicXMLElement(this.instrument, textElem[0]);
            textElem = warn.getElementsByTagName('ShortText');
            let shortText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                shortText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('LongText');
            let longText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                longText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('SoundEvent');
            let soundEvent = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                soundEvent = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('Once');
            let once = false;
            if (textElem.length > 0 && textElem[0].textContent == 'True') {
                once = true;
            }
            warnings.push(new Warning(type, condition, shortText, longText, soundEvent, once));
        }
        return warnings;
    }
}

/** A publisher for sound events. */
class SoundPublisher extends BasePublisher {
    /**
     * Create a SoundPublisher.
     * @param bus An event bus.
     * @param pacer An optional pacer to controle the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Request that a sound be played.
     * @param soundId The id of the sound to play.
     */
    playSound(soundId) {
        this.publish('play_sound', soundId, true, false);
    }
    /**
     * Request that a continuous sound be started.
     * @param soundId The id of the sound to play.
     */
    startSound(soundId) {
        this.publish('start_sound', soundId, true, false);
    }
    /**
     * Request that a continuous sound be stopped.
     * @param soundId The id of the sound to play.
     */
    stopSound(soundId) {
        this.publish('stop_sound', soundId, true, false);
    }
    /**
     * Send a notification that play has been requested.
     * @param soundId The id of the sound requested.
     */
    soundQueued(soundId) {
        this.publish('sound_queued', soundId, true, false);
    }
    /**
     * Send a notification that play has completed.
     * @param soundId The id of the sound played.
     */
    soundPlayed(soundId) {
        this.publish('sound_played', soundId, true, false);
    }
}
/**
 * A event-drive sound server that manages both one-shot and continuous sound playback.
 */
class SoundServer {
    /**
     * Create a sound server.
     * @param bus An event bus.
     * @param publisher A sound publisher.
     * @param instrument The hosting instance of BaseInstrument.
     */
    constructor(bus, publisher, instrument) {
        this.instrument = instrument;
        this.playing = new Map();
        this.subscriber = bus.getSubscriber();
        this.publisher = publisher;
        this.subscriber.on('play_sound').handle((soundId) => { this.playSound(soundId, false); });
        this.subscriber.on('start_sound').handle((soundId) => { this.playSound(soundId, true); });
        this.subscriber.on('stop_sound').handle((soundId) => { this.stopSound(soundId); });
    }
    /**
     * Play a requested sound once or continuously.
     * @param soundId The id of the sound to play.
     * @param continuous Whether to play it continuously.
     */
    playSound(soundId, continuous = false) {
        if (!this.playing.has(soundId)) {
            this.instrument.playInstrumentSound(soundId);
            this.playing.set(soundId, { soundEventId: new Name_Z(soundId), continuous: continuous });
            this.publisher.soundQueued(soundId);
        }
    }
    /**
     * Stop a continuously played sound.
     * @param soundId The id of the sound to stop.
     */
    stopSound(soundId) {
        const record = this.playing.get(soundId);
        if (record) {
            // Setting continuous to false means it won't be retriggered next time it ends.
            record.continuous = false;
            this.playing.set(soundId, record);
        }
    }
    /**
     * Handle a sound end event.  This needs to be called by the parent device,
     * and it takes a Name_Z, as sent from VCockpit.js in the master onSoundEnd call.
     * @param soundEventId The id of the sound event.
     */
    onSoundEnd(soundEventId) {
        for (const entry of this.playing.entries()) {
            // Name_Z can't be compared with ==, you need to use the in-built function.
            if (Name_Z.compare(entry[1].soundEventId, soundEventId)) {
                if (entry[1].continuous) {
                    this.instrument.playInstrumentSound(entry[0]);
                    return;
                }
                else {
                    this.publisher.soundPlayed(entry[0]);
                    this.playing.delete(entry[0]);
                    return;
                }
            }
        }
    }
}

var FLARMOperatingMode;
(function (FLARMOperatingMode) {
    FLARMOperatingMode[FLARMOperatingMode["Off"] = 0] = "Off";
    FLARMOperatingMode[FLARMOperatingMode["On"] = 1] = "On";
})(FLARMOperatingMode || (FLARMOperatingMode = {}));
var FLARMAlertLevel;
(function (FLARMAlertLevel) {
    FLARMAlertLevel[FLARMAlertLevel["None"] = 0] = "None";
    FLARMAlertLevel[FLARMAlertLevel["Small"] = 1] = "Small";
    FLARMAlertLevel[FLARMAlertLevel["Medium"] = 2] = "Medium";
    FLARMAlertLevel[FLARMAlertLevel["Heavy"] = 3] = "Heavy";
})(FLARMAlertLevel || (FLARMAlertLevel = {}));
class FLARMAirplane {
    constructor(contact) {
        this.contact = contact;
        this._position = new GeoPoint(0, 0);
        this.position = this._position.readonly;
        this._heading = Subject.create(0);
        this.heading = this._heading;
        this._alertLevel = Subject.create(FLARMAlertLevel.Small);
        this.alertLevel = this._alertLevel;
    }
    updateParameters(contact) {
        this.updatePosition(contact.lat, contact.lon, contact.heading);
        this.updateAlertLevel(contact.timeToCollision);
    }
    updatePosition(lat, lon, heading) {
        this._position.set({ lat: lat, lon: lon });
        this._heading.set(heading);
    }
    updateAlertLevel(timeToCollision) {
        let alertLevel = FLARMAlertLevel.None;
        if (timeToCollision > 19 || timeToCollision === -1) {
            alertLevel = FLARMAlertLevel.None;
        }
        else if (timeToCollision > 14 && timeToCollision <= 19) {
            alertLevel = FLARMAlertLevel.Small;
        }
        else if (timeToCollision > 9 && timeToCollision <= 14) {
            alertLevel = FLARMAlertLevel.Medium;
        }
        else if (timeToCollision > 0 && timeToCollision <= 9) {
            alertLevel = FLARMAlertLevel.Heavy;
        }
        this._alertLevel.set(alertLevel);
    }
    getuId() {
        return this.contact.uId;
    }
}
class FLARM {
    constructor(bus, flarmInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq) {
        this.bus = bus;
        this.flarmInstrument = flarmInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(FLARMOperatingMode.On);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.contactUpdatedHandler = this.onContactUpdated.bind(this);
        this.alertLevelSubs = new Map();
        this.alertLevel = -1;
        this.FLARMEventSubscriber = this.bus.getSubscriber();
        this.FLARMEventPublisher = this.bus.getPublisher();
    }
    init() {
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('flarm_traffic_contact_added');
        this.contactRemovedConsumer = sub.on('flarm_traffic_contact_removed');
        this.contactUpdatedConsumer = sub.on('flarm_traffic_contact_updated');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        this.contactUpdatedConsumer.handle(this.contactUpdatedHandler);
        this.flarmInstrument.forEachContact((contact) => {
            this.onContactAdded(contact.uId);
        });
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    getIntruders() {
        return this.intrudersFiltered;
    }
    getEventSubscriber() {
        return this.FLARMEventSubscriber;
    }
    onOperatingModeChanged(mode) {
        this.bus.pub('flarm_operating_mode', mode, false, false);
        if (mode === FLARMOperatingMode.Off) {
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    createIntruderEntry(contact) {
        return new FLARMAirplane(contact);
    }
    onContactAdded(uId) {
        const contact = this.flarmInstrument.getContact(uId);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    onContactRemoved(uId) {
        const sortedIndex = this.intrudersSorted.findIndex((intruder) => intruder.contact.uId === uId);
        const culledIndex = this.intrudersFiltered.findIndex((intruder) => intruder.contact.uId === uId);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    onContactUpdated(uId) {
        const contact = this.flarmInstrument.getContact(uId);
        for (let i = 0; i < this.intrudersSorted.length; i++) {
            if (uId === this.intrudersSorted[i].getuId()) {
                this.intrudersSorted[i].updateParameters(contact);
            }
        }
    }
    doUpdate() {
        this.updateIntruderArray();
        this.updateAlertLevel();
    }
    intruderComparator(a, b) {
        if (a.contact.timeToCollision < b.contact.timeToCollision) {
            return -1;
        }
        else if (a.contact.timeToCollision === b.contact.timeToCollision) {
            return 0;
        }
        else {
            return 1;
        }
    }
    updateAlertLevel() {
        const len = this.intrudersSorted.length;
        let currentAlertLevel = FLARMAlertLevel.None;
        for (let i = 0; i < len; i++) {
            currentAlertLevel = Math.max(currentAlertLevel, this.intrudersSorted[i].alertLevel.get());
        }
        if (this.alertLevel !== currentAlertLevel) {
            SimVar.SetSimVarValue('L:FLARM_WARNING_LEVEL', 'Number', currentAlertLevel);
            this.alertLevel = currentAlertLevel;
        }
    }
    updateIntruderArray() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            if (i < this.maxIntruderCount) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    onSimTimeChanged(simTime) {
        if (this.operatingModeSub.get() === FLARMOperatingMode.Off) {
            return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq ||
            Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate();
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.FLARMEventPublisher.pub('flarm_intruder_added', intruder, false, false);
    }
    cleanUpIntruder(intruder) {
        var _a;
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.FLARMEventPublisher.pub('flarm_intruder_removed', intruder, false, false);
    }
    onAlertLevelChanged(intruder) {
        this.FLARMEventPublisher.pub('flarm_intruder_alert_changed', intruder, false, false);
    }
}

class FLARMTrafficInstrument {
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    getContact(uid) {
        return this.tracked.get(uid);
    }
    forEachContact(visitor) {
        return this.tracked.forEach(visitor);
    }
    init() {
        this.bus.getSubscriber().on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy ||
            Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq ||
            Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_FLARM_PLANES'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    createContact(entry, simTime) {
        const contact = new FLARMTrafficClass(entry.uId);
        this.tracked.set(contact.uId, contact);
        contact.update(entry.bearing, entry.lat, entry.lon, entry.distance, entry.relativeAltitude, entry.heading, entry.verticalBearing, entry.timeToCollision, simTime);
        this.bus.pub('flarm_traffic_contact_added', contact.uId, false, false);
    }
    updateContact(contact, entry, simTime) {
        contact.update(entry.bearing, entry.lat, entry.lon, entry.distance, entry.relativeAltitude, entry.heading, entry.verticalBearing, entry.timeToCollision, simTime);
        this.bus.pub('flarm_traffic_contact_updated', contact.uId, false, false);
    }
    deprecateContacts(simTime) {
        this.tracked.forEach((contact) => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uId);
                this.bus.pub('flarm_traffic_contact_removed', contact.uId, false, false);
            }
        });
    }
    onUpdate() { }
}
class FLARMTrafficClass {
    constructor(uId) {
        this.uId = uId;
        this.bearing = 0;
        this.lat = 0;
        this.lon = 0;
        this.distance = 0;
        this.relativeAltitude = 0;
        this.heading = 0;
        this.verticalBearing = 0;
        this.timeToCollision = 0;
        this.lastContactTime = NaN;
    }
    update(bearing, lat, lon, distance, relativeAltitude, heading, verticalBearing, timeToCollision, simTime) {
        this.bearing = bearing;
        this.lat = lat;
        this.lon = lon;
        this.distance = distance;
        this.relativeAltitude = relativeAltitude;
        this.heading = heading;
        this.verticalBearing = verticalBearing;
        this.timeToCollision = timeToCollision;
        this.lastContactTime = simTime;
    }
}

var ASEvents;
(function (ASEvents) {
    ASEvents["UPPER_RIGHT_INC"] = "UpperRightKnobInc";
    ASEvents["UPPER_RIGHT_DEC"] = "UpperRightKnobDec";
    ASEvents["BOTTOM_RIGHT_INC"] = "BottomRightKnobInc";
    ASEvents["BOTTOM_RIGHT_DEC"] = "BottomRightKnobDec";
    ASEvents["BOTTOM_LEFT_INC"] = "BottomLeftKnobInc";
    ASEvents["BOTTOM_LEFT_DEC"] = "BottomLeftKnobDec";
    ASEvents["UPPER_LEFT_INC"] = "UpperLeftKnobInc";
    ASEvents["UPPER_LEFT_DEC"] = "UpperLeftKnobDec";
    ASEvents["SOFTKEY_0_PUSH"] = "SoftKey0Push";
    ASEvents["SOFTKEY_1_PUSH"] = "SoftKey1Push";
    ASEvents["SOFTKEY_2_PUSH"] = "SoftKey2Push";
    ASEvents["SOFTKEY_3_PUSH"] = "SoftKey3Push";
    ASEvents["SOFTKEY_4_PUSH"] = "SoftKey4Push";
    ASEvents["SOFTKEY_5_PUSH"] = "SoftKey5Push";
    ASEvents["SOFTKEY_6_PUSH"] = "SoftKey6Push";
    ASEvents["SOFTKEY_7_PUSH"] = "SoftKey7Push";
})(ASEvents || (ASEvents = {}));

class ASEventPublisher extends BasePublisher {
    dispatchASEvent(event, sync = false) {
        this.publish('ASEvent', event, sync);
        switch (event) {
            case ASEvents.BOTTOM_LEFT_DEC:
            case ASEvents.BOTTOM_LEFT_INC:
                this.publish('MapEvent', event, sync);
                break;
            case ASEvents.UPPER_LEFT_DEC:
            case ASEvents.UPPER_LEFT_INC:
                this.publish('VolumeEvent', event, sync);
                break;
            case ASEvents.SOFTKEY_0_PUSH:
            case ASEvents.SOFTKEY_1_PUSH:
            case ASEvents.SOFTKEY_2_PUSH:
            case ASEvents.SOFTKEY_3_PUSH:
            case ASEvents.SOFTKEY_4_PUSH:
            case ASEvents.SOFTKEY_5_PUSH:
            case ASEvents.SOFTKEY_6_PUSH:
            case ASEvents.SOFTKEY_7_PUSH:
                this.publish('SoftKeyEvent', event, sync);
                break;
        }
    }
}

const AS_H_EVENT_RGX = /(AS8030|AS9070)_(.+)/;
const ASEventsMap = {
    UpperRightKnobInc: ASEvents.UPPER_RIGHT_INC,
    UpperRightKnobDec: ASEvents.UPPER_RIGHT_DEC,
    BottomRightKnobInc: ASEvents.BOTTOM_RIGHT_INC,
    BottomRightKnobDec: ASEvents.BOTTOM_RIGHT_DEC,
    BottomLeftKnobInc: ASEvents.BOTTOM_LEFT_INC,
    BottomLeftKnobDec: ASEvents.BOTTOM_LEFT_DEC,
    UpperLeftKnobInc: ASEvents.UPPER_LEFT_INC,
    UpperLeftKnobDec: ASEvents.UPPER_LEFT_DEC,
    SoftKey0Push: ASEvents.SOFTKEY_0_PUSH,
    SoftKey1Push: ASEvents.SOFTKEY_1_PUSH,
    SoftKey2Push: ASEvents.SOFTKEY_2_PUSH,
    SoftKey3Push: ASEvents.SOFTKEY_3_PUSH,
    SoftKey4Push: ASEvents.SOFTKEY_4_PUSH,
    SoftKey5Push: ASEvents.SOFTKEY_5_PUSH,
    SoftKey6Push: ASEvents.SOFTKEY_6_PUSH,
    SoftKey7Push: ASEvents.SOFTKEY_7_PUSH,
};
function mapHEventToASEvent(hEvent, prefix) {
    const hEventWithoutPrefix = AS_H_EVENT_RGX[Symbol.match](hEvent);
    if (hEventWithoutPrefix !== null && hEventWithoutPrefix[1] === prefix) {
        const mappedEvent = ASEventsMap[hEventWithoutPrefix[2]];
        if (mappedEvent === undefined) {
            throw new Error(`[mapHEventToASEvent] Unmapped H event '${hEvent}'.`);
        }
        return mappedEvent;
    }
    return undefined;
}

/**
 * The item position to focus a component's children when performing a focus operation.
 */
var FocusPosition;
(function (FocusPosition) {
    /** The component's most recently focused descendants will be focused. */
    FocusPosition["MostRecent"] = "MostRecent";
    /** The first focus-able child at each node in the descendant tree will be focused. */
    FocusPosition["First"] = "First";
    /** The last focus-able child at each node in the descendant tree will be focused. */
    FocusPosition["Last"] = "Last";
    /** No child components will be focused. */
    FocusPosition["None"] = "None";
})(FocusPosition || (FocusPosition = {}));
/**
 * A strategy to focus a component's children as part of a blur reconciliation operation.
 */
var BlurReconciliation;
(function (BlurReconciliation) {
    /** The component's first focus-able child will be focused. */
    BlurReconciliation["First"] = "First";
    /** The component's last focus-able child will be focused. */
    BlurReconciliation["Last"] = "Last";
    /**
     * The component's next focus-able child after the child that was blurred will be focused. If no such child exists,
     * then the last focus-able child before the child that was blurred will be focused.
     */
    BlurReconciliation["Next"] = "Next";
    /**
     * The component's last focus-able child before the child that was blurred will be focused. If no such child exists,
     * then the next focus-able child after the child that was blurred will be focused.
     */
    BlurReconciliation["Prev"] = "Prev";
    /** No child components will be focused. */
    BlurReconciliation["None"] = "None";
})(BlurReconciliation || (BlurReconciliation = {}));
/**
 * An abstract implementation of a component that forms the base of a Garmin-like UI control system. Subclasses should
 * implement an appropriate event handler interface (using the utility type `UiControlEventHandlers<Events>`) and have
 * their props implement the corresponding prop event handler interface (using the utility type
 * `UiControlPropEventHandlers<Events>`).
 * @template E An event definition type for events supported by this control.
 * @template P The component prop type for this control.
 */
class HardwareUiControl extends DisplayComponent {
    /**
     * Creates an instance of a HardwareUiControl.
     * @param props The props for this component.
     */
    constructor(props) {
        super(props);
        this.focusedIndex = -1;
        this._isDisabled = false;
        this._isFocused = false;
        this._isIsolated = false;
        this._UICONTROL_ = true;
        this._isIsolated = this.props.isolateScroll !== undefined && this.props.isolateScroll;
    }
    /**
     * Gets the current number of registered child controls.
     * @returns The current number of registered child controls.
     */
    get length() {
        if (this.registeredControls !== undefined) {
            return this.registeredControls.length;
        }
        return 0;
    }
    /**
     * Gets whether or not the control is currently disabled.
     * @returns True if disabled, false otherwise.
     */
    get isDisabled() {
        return this._isDisabled;
    }
    /**
     * Gets whether or not the control is currently focused.
     * @returns True if disabled, false otherwise.
     */
    get isFocused() {
        return this._isFocused;
    }
    /**
     * Gets whether or not the control is currently in scroll isolation.
     * @returns True if currently in scroll isolation, false otherwise.
     */
    get isIsolated() {
        return this._isIsolated;
    }
    /**
     * An event called when the control receives focus.
     * @param source The control that emitted this event.
     */
    onFocused(source) {
        this.props.onFocused && this.props.onFocused(source);
    }
    /**
     * An event called when the control is blurred.
     * @param source The control that emitted this event.
     */
    onBlurred(source) {
        this.props.onBlurred && this.props.onBlurred(source);
    }
    /**
     * An event called when the control is enabled.
     * @param source The control that emitted this event.
     */
    onEnabled(source) {
        this.props.onEnabled && this.props.onEnabled(source);
    }
    /**
     * An event called when the control is disabled.
     * @param source The control that emitted this event.
     */
    onDisabled(source) {
        this.props.onDisabled && this.props.onDisabled(source);
    }
    /**
     * An event called when a control is registered with this control.
     * @param source The control that emitted this event.
     */
    onRegistered(source) {
        this.props.onRegistered && this.props.onRegistered(source);
    }
    /**
     * An event called when a control is unregistered from this control.
     * @param source The control that emitted this event.
     */
    onUnregistered(source) {
        this.props.onUnregistered && this.props.onUnregistered(source);
    }
    /**
     * Gets the focus position to apply when this control is focused from a scroll.
     * @param direction The direction of the scroll.
     * @returns The focus position to apply when this control is focused from a scroll.
     */
    getFocusPositionOnScroll(direction) {
        if (this.props.getFocusPositionOnScroll) {
            return this.props.getFocusPositionOnScroll(direction);
        }
        return direction === 'forward' ? FocusPosition.First : FocusPosition.Last;
    }
    /**
     * An event called when the control is scrolled.
     * @param direction The direction that is being requested to scroll.
     * @returns True if this control handled this event, false otherwise.
     */
    onScroll(direction) {
        if (this.registeredControls !== undefined && this.registeredControls.length > 0) {
            const delta = direction === 'forward' ? 1 : -1;
            for (let i = this.focusedIndex + delta; direction === 'forward' ? i < this.registeredControls.length : i >= 0; i += delta) {
                const controlToFocus = this.registeredControls[i];
                if (controlToFocus.focus(controlToFocus.getFocusPositionOnScroll(direction))) {
                    this.onAfterScroll(controlToFocus, i);
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * An event called when a scroll operation has completed.
     * @param control The control that was scrolled to.
     * @param index The index of the control in the collection of registered controls.
     */
    onAfterScroll(control, index) {
        this.props.onAfterScroll && this.props.onAfterScroll(control, index);
    }
    /**
     * Scrolls the currently focused control in the supplied direction.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    scroll(direction) {
        if (!this.isFocused) {
            return false;
        }
        const controlToScroll = this.getFocusedComponentPath()[0];
        if (controlToScroll !== undefined) {
            return controlToScroll.tryPerformScroll(direction);
        }
        else {
            return this.tryPerformScroll(direction);
        }
    }
    /**
     * Attempts to perform a scroll operation on the control, propagating the operation
     * upward in the tree if the control does not handle the operation.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    tryPerformScroll(direction) {
        let handled = false;
        if (this.props.onScroll !== undefined) {
            handled = this.props.onScroll(direction);
        }
        else {
            handled = this.onScroll(direction);
        }
        if (!handled) {
            const currentlyIsolated = this.isFocused && this.isIsolated;
            if (this.parent !== undefined && !currentlyIsolated) {
                return this.parent.tryPerformScroll(direction);
            }
            else if (currentlyIsolated) {
                return true;
            }
        }
        return handled;
    }
    /**
     * Triggers an event on this control. The event will first be routed to the deepest focused descendent of this
     * control and will propagate up the control tree until it is handled or there are no more controls to which to
     * propagate.
     * @param event The event to trigger.
     * @param source The source of the event. Defaults to this if not supplied.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    triggerEvent(event, source, ...args) {
        const canListen = this.isFocused || this.parent === undefined;
        if (!canListen) {
            return false;
        }
        const focusedControl = this.getFocusedComponentPath()[0];
        if (focusedControl !== undefined) {
            return focusedControl.propagateEvent(event, focusedControl, args);
        }
        return false;
    }
    /**
     * Propagates an event up the control tree.
     * @param event The event to propagate.
     * @param source The source of the event.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    propagateEvent(event, source, args) {
        const handler = this[`on${event}`];
        const propHandler = this.props[`on${event}`];
        // Class-defined handlers get priority over prop-defined handlers
        // Prop-defined handlers are not called if a class-defined handler exists -> this is to allow subclasses to
        // restrict which events get sent to prop-defined handlers if they choose.
        const stopPropagation = (!!handler && handler.call(this, source, ...args)) || (!!propHandler && propHandler(source, ...args));
        if (!stopPropagation && this.parent !== undefined) {
            return this.parent.propagateEvent(event, this.parent, args);
        }
        return stopPropagation;
    }
    /**
     * Validates that the control can be focused by checking if any ancestors in the
     * control tree are disabled.
     * @returns True if there are no disabled ancestors, false otherwise.
     */
    canBeFocused() {
        let canFocus = true;
        if (!this._isDisabled) {
            if (this.parent !== undefined) {
                canFocus = this.parent.canBeFocused();
            }
        }
        else {
            canFocus = false;
        }
        return canFocus;
    }
    /**
     * Brings focus to the control. Focusing the control will also blur the currently
     * focused control, if any.
     * @param focusPosition The focus position to activate for descendents of this control.
     * @returns Whether this control was successfully focused.
     */
    focus(focusPosition) {
        if (!this.canBeFocused()) {
            return false;
        }
        const focusStack = this.buildFocusPath(focusPosition);
        if (focusStack.length === 0) {
            return false;
        }
        // Top of the stack is always 'this', and will be repeated by getFocusRootPath() if we don't remove it
        focusStack.pop();
        this.getDeepestFocusedAncestorPath(focusStack);
        const focusRoot = focusStack[focusStack.length - 1];
        const blurStack = focusRoot.getFocusedComponentPath();
        if (blurStack.length > 0) {
            // Top of the blur stack is the deepest common ancestor of the old focused leaf and this control.
            // This ancestor will be focused after this operation, so we need to remove it from the blur stack.
            blurStack.pop();
            for (let i = 0; i < blurStack.length; i++) {
                blurStack[i]._isFocused = false;
            }
        }
        // Top of the focus stack is the deepest common ancestor of the old focused leaf and this control, OR the root of
        // the control tree if nothing in the tree is focused -> either way, the control will be focused after this
        // operation, so if the control is already focused, we need to remove it from the focus stack.
        if (focusRoot.isFocused) {
            focusStack.pop();
        }
        for (let i = 0; i < focusStack.length; i++) {
            const control = focusStack[i];
            const parent = control.parent;
            control._isFocused = true;
            if (parent !== undefined && parent.registeredControls !== undefined) {
                parent.focusedIndex = parent.registeredControls.indexOf(control);
            }
        }
        while (blurStack.length > 0) {
            const control = blurStack.pop();
            if (control !== undefined) {
                control.onBlurred(control);
            }
        }
        while (focusStack.length > 0) {
            const control = focusStack.pop();
            if (control !== undefined) {
                control.onFocused(control);
            }
        }
        return true;
    }
    /**
     * Gets the path from this control to the deepest descendent control that is focused. If this control is not focused,
     * then the path is empty.
     * @param path The stack of control nodes defining the path to the currently
     * focused descendent control.
     * @returns A stack of nodes that defines the path to the deepest focused descendent
     * node, in order of deepest descendent first.
     */
    getFocusedComponentPath(path) {
        if (path === undefined) {
            path = [];
        }
        if (!this._isFocused) {
            return path;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let currentControl = this;
        while (currentControl !== undefined) {
            path.splice(0, 0, currentControl);
            if (currentControl.registeredControls !== undefined) {
                currentControl = currentControl.registeredControls.find(c => c.isFocused);
            }
            else {
                currentControl = undefined;
            }
        }
        return path;
    }
    /**
     * Gets the path from this control to its deepest ancestor that is focused (including itself). If none of this
     * control's ancestors are focused, the path will contain this control and all of its ancestors up to and including
     * the root of its control tree.
     * @param path An array in which to store the path.
     * @returns A stack of controls that defines the path from this control to its deepest focused ancestor, ordered
     * from descendents to ancestors (the control at the shallowest tree depth is located at the top of the stack).
     */
    getDeepestFocusedAncestorPath(path) {
        if (path === undefined) {
            path = [];
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let currentControl = this;
        while (currentControl !== undefined) {
            path.push(currentControl);
            if (currentControl !== this && currentControl.isFocused) {
                break;
            }
            currentControl = currentControl.parent;
        }
        return path;
    }
    /**
     * Builds the path of controls to focus from this control downward in children based on the provided default focus
     * position. If this control cannot be focused, the path will be empty.
     * @param focusPosition The focus position to use to build the path.
     * @param focusStack The stack in which to store the path.
     * @returns A stack of components that defines the path from the deepest descendent to focus to this control if this
     * control were to be focused with the specified focus position, ordered from descendents to ancestors (the control
     * at the shallowest tree depth is located at the top of the stack).
     */
    buildFocusPath(focusPosition, focusStack) {
        var _a;
        if (focusStack === undefined) {
            focusStack = [];
        }
        if (this._isDisabled) {
            return focusStack;
        }
        //focusStack.splice(0, 0, currentControl);
        const originalStackDepth = focusStack.length;
        const childControls = this.registeredControls;
        if (childControls !== undefined) {
            switch (focusPosition) {
                case FocusPosition.MostRecent:
                    // Attempt to focus the most recent focused child. If this fails, fall back to FocusPosition.First.
                    (_a = childControls[this.focusedIndex]) === null || _a === void 0 ? void 0 : _a.buildFocusPath(FocusPosition.MostRecent, focusStack);
                    if (focusStack.length > originalStackDepth) {
                        break;
                    }
                // eslint-disable-next-line no-fallthrough
                case FocusPosition.First:
                    for (let i = 0; i < childControls.length; i++) {
                        childControls[i].buildFocusPath(FocusPosition.First, focusStack);
                        if (focusStack.length > originalStackDepth) {
                            break;
                        }
                    }
                    break;
                case FocusPosition.Last:
                    for (let i = childControls.length - 1; i >= 0; i--) {
                        childControls[i].buildFocusPath(FocusPosition.Last, focusStack);
                        if (focusStack.length > originalStackDepth) {
                            break;
                        }
                    }
                    break;
            }
        }
        // If this control requires child focus, make sure a child was able to be focused before adding this control to the stack.
        if (!this.props.requireChildFocus || focusStack.length > originalStackDepth) {
            focusStack.push(this);
        }
        return focusStack;
    }
    /**
     * Blurs, or removes focus, from the component.
     */
    blur() {
        var _a, _b;
        if (!this._isFocused) {
            return;
        }
        let indexInParent = -1;
        if (this.parent) {
            indexInParent = (_b = (_a = this.parent.registeredControls) === null || _a === void 0 ? void 0 : _a.indexOf(this)) !== null && _b !== void 0 ? _b : -1;
        }
        const blurStack = this.getFocusedComponentPath();
        for (let i = 0; i < blurStack.length; i++) {
            blurStack[i]._isFocused = false;
        }
        while (blurStack.length > 0) {
            const control = blurStack.pop();
            if (control !== undefined) {
                control.onBlurred(control);
            }
        }
        if (this.parent && indexInParent >= 0) {
            this.parent.handleNoFocusedChild(indexInParent, this);
        }
    }
    /**
     * Handles the case where this control is left focused with no focused child control after a child control is
     * blurred.
     * @param indexBlurred The index of the child control that was blurred. If the child is no longer registered, then
     * this is the index of the child prior to being unregistered.
     * @param childBlurred The child control that was blurred.
     */
    handleNoFocusedChild(indexBlurred, childBlurred) {
        var _a;
        if (!this._isFocused || this.getFocusedIndex() >= 0) {
            return;
        }
        const reconciliation = this.reconcileChildBlur(indexBlurred, childBlurred);
        if (this.registeredControls) {
            if (typeof reconciliation === 'number') {
                const controlToFocus = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[reconciliation];
                controlToFocus === null || controlToFocus === void 0 ? void 0 : controlToFocus.focus(FocusPosition.First);
            }
            else {
                switch (reconciliation) {
                    case BlurReconciliation.First:
                        this.focus(FocusPosition.First);
                        break;
                    case BlurReconciliation.Last:
                        this.focus(FocusPosition.Last);
                        break;
                    case BlurReconciliation.Next:
                        for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                            if (this.registeredControls[i].focus(FocusPosition.First)) {
                                break;
                            }
                        }
                        for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                            if (this.registeredControls[i].focus(FocusPosition.First)) {
                                break;
                            }
                        }
                        break;
                    case BlurReconciliation.Prev:
                        for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                            if (this.registeredControls[i].focus(FocusPosition.Last)) {
                                break;
                            }
                        }
                        for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                            if (this.registeredControls[i].focus(FocusPosition.Last)) {
                                break;
                            }
                        }
                        break;
                }
            }
        }
        if (this.props.requireChildFocus && this.getFocusedIndex() < 0) {
            this.blur();
        }
    }
    /**
     * Reconciles the focus state of this control's children when this control is focused with no focused children after
     * a child has been blurred.
     * @param index The index of the child control that was blurred. If the child is no longer registered, then this is
     * the index of the child prior to being unregistered.
     * @param child The child control that was blurred.
     * @returns The index of the child control to focus.
     */
    reconcileChildBlur(index, child) {
        var _a;
        if (this.props.reconcileChildBlur) {
            return this.props.reconcileChildBlur(index, child);
        }
        if (((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[index]) !== child) {
            return BlurReconciliation.Next;
        }
        else {
            return -1;
        }
    }
    /**
     * Sets the component to be disabled, removing the ability for the component to scroll. Setting
     * a component to disabled will also blur the component and its children, if necessary.
     * @param isDisabled Whether or not the component is disabled.
     */
    setDisabled(isDisabled) {
        this._isDisabled = isDisabled;
        if (isDisabled) {
            this.blur();
            this.onDisabled(this);
        }
        else {
            this.onEnabled(this);
        }
    }
    /**
     * Registers a child control with this control.
     * @param control The control to register.
     * @param index The index at which to register the control. If none is provided,
     * the control will be registered at the end of the collection of child controls.
     */
    register(control, index) {
        if (this.registeredControls === undefined) {
            this.registeredControls = [];
        }
        if (index !== undefined) {
            this.registeredControls.splice(index, 0, control);
            if (this.focusedIndex >= index) {
                this.focusedIndex++;
            }
        }
        else {
            this.registeredControls.push(control);
        }
        control.setParent(this);
        control.onRegistered(control);
    }
    /**
     * Unregisters a child control with this control.
     * @param item The child control or index of a child control to unregister. If a
     * child control is provided, it will attempt to be located in the control's
     * child registry and then removed. If an index is provided, the child control
     * at that registered index will be removed.
     */
    unregister(item) {
        if (this.registeredControls !== undefined) {
            let index = -1;
            if (typeof item === 'number') {
                index = item;
            }
            else {
                index = this.registeredControls.indexOf(item);
            }
            if (index >= 0 && index < this.length) {
                const controlToRemove = this.registeredControls[index];
                const isRemovedControlFocused = controlToRemove._isFocused;
                this.registeredControls.splice(index, 1);
                controlToRemove.parent = undefined;
                if (isRemovedControlFocused) {
                    controlToRemove.blur();
                    this.handleNoFocusedChild(index, controlToRemove);
                }
                else {
                    if (this.focusedIndex === index) {
                        this.focusedIndex = -1;
                    }
                    else if (this.focusedIndex > index) {
                        this.focusedIndex--;
                    }
                }
                this.focusedIndex = Math.min(this.focusedIndex, this.registeredControls.length - 1);
                if (controlToRemove.length > 0) {
                    controlToRemove.clearRegistered();
                }
                controlToRemove.onUnregistered(controlToRemove);
                if (this.length === 0) {
                    this.registeredControls = undefined;
                }
            }
        }
    }
    /**
     * Clears the list of registered components.
     */
    clearRegistered() {
        if (this.registeredControls !== undefined) {
            const registeredControls = this.registeredControls;
            this.registeredControls = undefined;
            this.focusedIndex = -1;
            for (let i = 0; i < registeredControls.length; i++) {
                const controlToRemove = registeredControls[i];
                controlToRemove.parent = undefined;
                if (controlToRemove._isFocused) {
                    controlToRemove.blur();
                }
                if (controlToRemove.length > 0) {
                    controlToRemove.clearRegistered();
                }
                registeredControls[i].onUnregistered(registeredControls[i]);
            }
            // Only call this once for the last child removed to prevent multiple sequential, redundant reconciliations.
            this.handleNoFocusedChild(0, registeredControls[registeredControls.length - 1]);
        }
    }
    /**
     * Gets the current focused index in the registered controls collection.
     * @returns The index of the focused control in the collection of registered controls.
     */
    getFocusedIndex() {
        var _a, _b;
        return ((_b = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[this.focusedIndex]) === null || _b === void 0 ? void 0 : _b._isFocused) ? this.focusedIndex : -1;
    }
    /**
     * Gets the most recent focused index (including the current focused index, if one exists) in the registered controls
     * collection.
     * @returns The index of the most recently focused control in the collection of registered controls.
     */
    getMostRecentFocusedIndex() {
        return this.focusedIndex;
    }
    /**
     * Sets the current most recently focused child control index. If this control is focused and has children
     * that have focus, this will also switch child focus to the new index.
     * @param index The index of the child control to set most recent focus for.
     * @param focusPosition The focus position to focus the child for, if required.
     */
    setFocusedIndex(index, focusPosition = FocusPosition.MostRecent) {
        var _a;
        if (this.isFocused && this.length > 0 && ((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.findIndex(c => c.isFocused)) !== -1) {
            const child = this.getChild(index);
            if (child !== undefined) {
                child.focus(focusPosition);
            }
        }
        else if (this.length > 0 && index >= 0 && index < this.length) {
            this.focusedIndex = index;
        }
    }
    /**
     * Gets a child control at the specified index.
     * @param index The index of the child control to get.
     * @returns The specified child control.
     */
    getChild(index) {
        if (this.registeredControls !== undefined) {
            return this.registeredControls[index];
        }
        return undefined;
    }
    /**
     * Gets the index of a specified child control within the registered
     * child controls collection.
     * @param child The child to get the index of.
     * @returns The index of the child, or -1 if not found.
     */
    indexOf(child) {
        if (this.registeredControls !== undefined) {
            return this.registeredControls.indexOf(child);
        }
        return -1;
    }
    /**
     * Sets the parent of this control.
     * @param parent The parent to set.
     */
    setParent(parent) {
        this.parent = parent;
    }
    /**
     * Sets whether or not this control is in scroll isolation. While scroll isolation
     * is enabled, scroll events will not propagate to the control's parent when the
     * control has focus.
     * @param isolated Whether or not the control is isolated.
     */
    setIsolated(isolated) {
        this._isIsolated = isolated;
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        FSComponent.visitNodes(thisNode, (node) => {
            const instance = node.instance;
            if (instance !== this && (instance === null || instance === void 0 ? void 0 : instance._UICONTROL_)) {
                this.register(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * Renders the control.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.props.onDestroyed && this.props.onDestroyed(this);
    }
}

class ASUiControls extends HardwareUiControl {
    constructor() {
        super(...arguments);
        this.fieldOnEdit = false;
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.disabled) {
            this.setDisabled(true);
        }
    }
    onInteractionEvent(event) {
        if (this.fieldOnEdit) {
            return this.routeToField(event);
        }
        else {
            switch (event) {
                case ASEvents.BOTTOM_RIGHT_INC:
                    return this.scroll('backward');
                case ASEvents.BOTTOM_RIGHT_DEC:
                    return this.scroll('forward');
            }
        }
        return this.triggerEvent(event, this);
    }
    routeToField(event) {
        if (this.registeredControls !== undefined) {
            const field = this.registeredControls[this.focusedIndex];
            field.onInteractionEvent(event);
        }
        return false;
    }
    startFieldEdit() {
        if (this.registeredControls !== undefined) {
            const field = this.registeredControls[this.focusedIndex];
            this.fieldOnEdit = field.onStartEdit();
        }
    }
    validateFieldEdit() {
        if (this.registeredControls !== undefined) {
            const field = this.registeredControls[this.focusedIndex];
            this.fieldOnEdit = field.onValidateEdit();
        }
    }
    cancelFieldEdit() {
        if (this.registeredControls !== undefined) {
            const field = this.registeredControls[this.focusedIndex];
            this.fieldOnEdit = field.onCancelEdit();
        }
    }
    onUpperRightKnobInc(source) {
        return this.props.onUpperRightKnobInc ? this.props.onUpperRightKnobInc(source) : false;
    }
    onUpperRightKnobDec(source) {
        return this.props.onUpperRightKnobDec ? this.props.onUpperRightKnobDec(source) : false;
    }
    onBottomRightKnobInc(source) {
        return this.props.onBottomRightKnobInc ? this.props.onBottomRightKnobInc(source) : false;
    }
    onBottomRightKnobDec(source) {
        return this.props.onBottomRightKnobDec ? this.props.onBottomRightKnobDec(source) : false;
    }
    onBottomLeftKnobInc(source) {
        return this.props.onBottomLeftKnobInc ? this.props.onBottomLeftKnobInc(source) : false;
    }
    onBottomLeftKnobDec(source) {
        return this.props.onBottomLeftKnobDec ? this.props.onBottomLeftKnobDec(source) : false;
    }
    onUpperLeftKnobInc(source) {
        return this.props.onUpperLeftKnobInc ? this.props.onUpperLeftKnobInc(source) : false;
    }
    onUpperLeftKnobDec(source) {
        return this.props.onUpperLeftKnobDec ? this.props.onUpperLeftKnobDec(source) : false;
    }
    onSoftKey0Push(source) {
        return false;
    }
    onSoftKey1Push(source) {
        return false;
    }
    onSoftKey2Push(source) {
        return false;
    }
    onSoftKey3Push(source) {
        return false;
    }
    onSoftKey4Push(source) {
        return false;
    }
    onSoftKey5Push(source) {
        return false;
    }
    onSoftKey6Push(source) {
        return false;
    }
    onSoftKey7Push(source) {
        return false;
    }
}

class GuiDialog extends ASUiControls {
    constructor(props) {
        super(props);
        this.onOpen = new SubEvent();
        this.onClose = new SubEvent();
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        FSComponent.visitNodes(node, (_node) => {
            if (_node.instance instanceof HTMLElement) {
                this.rootElement = _node.instance;
                this.close();
            }
            return this.rootElement !== undefined;
        });
        this.focus(FocusPosition.First);
    }
    open() {
        var _a;
        (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');
        this.onOpen.notify(this);
    }
    close() {
        var _a;
        (_a = this.rootElement) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');
        this.onClose.notify(this);
    }
}

class ViewService {
    constructor(elementID) {
        this.registeredViews = new Map();
        this.refsMap = new Map();
        this.openViews = [];
        this.activeViewEntrySub = Subject.create(null);
        this.activeViewKey = this.activeViewEntrySub.map((entry) => { var _a; return (_a = entry === null || entry === void 0 ? void 0 : entry.key) !== null && _a !== void 0 ? _a : ''; });
        this.activeView = this.activeViewEntrySub.map((entry) => entry === null || entry === void 0 ? void 0 : entry.ref.instance);
        this.viewClosedHandler = this.handleViewClosed.bind(this);
        this.elementID = elementID;
    }
    routeInteractionEventToViews(evt) {
        const activeView = this.activeView.get();
        if (activeView) {
            return activeView.onInteractionEvent(evt);
        }
        return false;
    }
    openByIndex(index) {
        let type = Array.from(this.refsMap.keys())[index];
        let viewEntry = this.refsMap.get(type);
        type = index.toString();
        if (viewEntry === undefined) {
            viewEntry = {
                key: type,
                ref: this.createView(type),
            };
            this.refsMap.set(type, viewEntry);
        }
        return this.open(viewEntry);
    }
    openByName(type) {
        let viewEntry = this.refsMap.get(type);
        if (viewEntry === undefined) {
            viewEntry = {
                key: type,
                ref: this.createView(type),
            };
            this.refsMap.set(type, viewEntry);
        }
        return this.open(viewEntry);
    }
    open(viewEntry) {
        const view = viewEntry.ref.instance;
        this.clearStack(true);
        view.open();
        view.onClose.on(this.viewClosedHandler);
        const index = this.openViews.indexOf(viewEntry);
        if (index >= 0) {
            this.openViews.splice(index, 1);
        }
        this.openViews.push(viewEntry);
        this.activeViewEntrySub.set(viewEntry);
        document.getElementById("Container").scrollIntoView();
        return view;
    }
    handleViewClosed(closedView) {
        var _a;
        const viewIndex = this.openViews.findIndex((entry) => entry.ref.instance === closedView);
        closedView.onClose.off(this.viewClosedHandler);
        if (viewIndex >= 0) {
            this.openViews.splice(viewIndex, 1);
            this.activeViewEntrySub.set((_a = this.openViews[0]) !== null && _a !== void 0 ? _a : null);
        }
    }
    createView(type) {
        const vnodeFn = this.registeredViews.get(type);
        if (vnodeFn === undefined) {
            console.error(`Could not find a registered view of type ${type.toString()}!`);
            throw new Error(`Could not find a registered view of type ${type.toString()}!`);
        }
        const node = vnodeFn();
        console.log("Rendering " + node + " to #" + this.elementID);
        FSComponent.render(node, document.getElementById(this.elementID));
        const viewRef = FSComponent.createRef();
        viewRef.instance = node.instance;
        return viewRef;
    }
    clearStack(closePage) {
        if (this.openViews.length === 0) {
            return;
        }
        const viewEntries = [...this.openViews];
        const len = viewEntries.length;
        for (let i = len - 1; i > 0; i++) {
            viewEntries[i].ref.instance.close();
        }
        this.openViews.length = 1;
        if (closePage || !(viewEntries[0].ref.instance instanceof GuiDialog)) {
            viewEntries[0].ref.instance.close();
            this.openViews.length = 0;
        }
    }
    registerView(type, vnodeFn) {
        this.registeredViews.set(type, vnodeFn);
    }
}

class ModeViewService extends ViewService {
    constructor(bus, elementID) {
        super(elementID);
        this.activeKeyTopPageArray = ['AirportMode', 'NearMode', 'InfoMode', 'SetupMode'];
        this.currentModeIndex = 0;
        this.bus = bus;
        this.subscriber = this.bus.getSubscriber();
        this.subscriber.on('ASEvent').handle((event) => {
            if (this.isActiveViewTopPage() && (event === ASEvents.UPPER_RIGHT_INC || event === ASEvents.UPPER_RIGHT_DEC)) {
                switch (event) {
                    case ASEvents.UPPER_RIGHT_DEC:
                        this.currentModeIndex =
                            this.currentModeIndex + 1 == this.activeKeyTopPageArray.length ? 0 : this.currentModeIndex + 1;
                        break;
                    case ASEvents.UPPER_RIGHT_INC:
                        this.currentModeIndex =
                            this.currentModeIndex - 1 == -1 ? this.activeKeyTopPageArray.length - 1 : this.currentModeIndex - 1;
                        break;
                }
                this.openByName(this.activeKeyTopPageArray[this.currentModeIndex]);
            }
            else {
                this.routeInteractionEventToViews(event);
            }
        });
    }
    isActiveViewTopPage() {
        return this.activeKeyTopPageArray.includes(this.activeViewKey.get());
    }
}

class KeysManager {
    constructor(QNHAndResSettings) {
        RegisterViewListener('JS_LISTENER_KEYEVENT');
        QNHAndResSettings.whenSettingChanged('qnh').handle((qnhSetting) => {
            Coherent.call('TRIGGER_KEY_EVENT', 'KOHLSMAN_SET', true, qnhSetting * 16, 1, 0);
        });
    }
}

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
        this.settings = new Map(settingDefs.map(def => {
            const syncTopic = `${DefaultUserSettingManager.SYNC_TOPIC_PREFIX}${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            this.subscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            this.onSettingValueChanged(entry, entry.setting.value);
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.publisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, true, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // protect against race conditions by not responding to sync events older than the last time this manager synced
        // the setting
        if (data.syncTime < entry.syncTime) {
            return;
        }
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, data.value, false, true);
    }
}
DefaultUserSettingManager.SYNC_TOPIC_PREFIX = 'usersetting.';
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
}

const mapSettings = [
    {
        name: 'mapRange',
        defaultValue: 10,
    },
];
class MapUserSettings {
    static getManager(bus) {
        var _a;
        return ((_a = MapUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE = new DefaultUserSettingManager(bus, mapSettings)));
    }
}
MapUserSettings.mapRanges = [200, 100, 80, 60, 40, 30, 20, 15, 10, 4, 2, 1, 0.4, 0.2];

class MapEventController {
    constructor(bus, mapSettingsManager = MapUserSettings.getManager(bus)) {
        this.bus = bus;
        this.mapSettingsManager = mapSettingsManager;
        this.handleMapEvent = (event) => {
            if (event === ASEvents.BOTTOM_LEFT_DEC) {
                this.handleMapRangeDecrease();
            }
            if (event === ASEvents.BOTTOM_LEFT_INC) {
                this.handleMapRangeIncrease();
            }
        };
        const mapEvents = this.bus.getSubscriber();
        mapEvents.on('MapEvent').handle(this.handleMapEvent);
    }
    handleMapRangeDecrease() {
        const mapRangeSetting = this.mapSettingsManager.getSetting('mapRange');
        const currentRange = mapRangeSetting.value;
        const currentIndex = MapUserSettings.mapRanges.indexOf(currentRange);
        const newIndex = Math.max(currentIndex - 1, 0);
        const newFormat = MapUserSettings.mapRanges[newIndex];
        mapRangeSetting.value = newFormat;
        NAVMAP.zoom_in();
    }
    handleMapRangeIncrease() {
        const mapRangeSetting = this.mapSettingsManager.getSetting('mapRange');
        const currentRange = mapRangeSetting.value;
        const currentIndex = MapUserSettings.mapRanges.indexOf(currentRange);
        const newIndex = Math.min(currentIndex + 1, MapUserSettings.mapRanges.length - 1);
        const newFormat = MapUserSettings.mapRanges[newIndex];
        mapRangeSetting.value = newFormat;
        NAVMAP.zoom_out();
    }
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
class ImageCache {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
        if (this.cache[key] === undefined) {
            const img = new Image();
            img.src = url;
            this.cache[key] = img;
        }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
        return this.cache[key];
    }
}
ImageCache.cache = {};

class MapIconImageCache extends ImageCache {
    static init() {
        MapIconImageCache.addToCache('AIRPORT', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/near/ICON_GLIDERS_AIRPORT.svg');
        MapIconImageCache.addToCache('GLIDER', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/glider/glider.svg');
        MapIconImageCache.addToCache('GLIDER_FLARM_LEVEL_NONE', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/flarm/glider_flarm_alert_level_none.svg');
        MapIconImageCache.addToCache('GLIDER_FLARM_LEVEL_SMALL', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/flarm/glider_flarm_alert_level_small.svg');
        MapIconImageCache.addToCache('GLIDER_FLARM_LEVEL_MEDIUM', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/flarm/glider_flarm_alert_level_medium.svg');
        MapIconImageCache.addToCache('GLIDER_FLARM_LEVEL_HEAVY', '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/flarm/glider_flarm_alert_level_heavy.svg');
    }
    static getAirportIcon() {
        return MapIconImageCache.get('AIRPORT');
    }
    static getGliderIcon() {
        return MapIconImageCache.get('GLIDER');
    }
    static getGliderFLARMLevelIcon(flarm_level) {
        switch (flarm_level) {
            case FLARMAlertLevel.None:
                return MapIconImageCache.get('GLIDER_FLARM_LEVEL_NONE');
            case FLARMAlertLevel.Small:
                return MapIconImageCache.get('GLIDER_FLARM_LEVEL_SMALL');
            case FLARMAlertLevel.Medium:
                return MapIconImageCache.get('GLIDER_FLARM_LEVEL_MEDIUM');
            case FLARMAlertLevel.Heavy:
                return MapIconImageCache.get('GLIDER_FLARM_LEVEL_HEAVY');
        }
    }
}

class ComputedSimVarPublisher extends BasePublisher {
    constructor() {
        super(...arguments);
        this.simvars = new Map();
    }
    startPublish() {
        super.startPublish();
        this.init();
    }
    init() {
        for (const definition of this.simvars.values()) {
            this.consumerFilter(definition.subscriber.on(definition.topic)).handle(definition.handler);
        }
    }
    consumerFilter(consumer) {
        return consumer;
    }
}

class FlightInfoPublisher extends ComputedSimVarPublisher {
    constructor(bus, pacer) {
        super(bus, pacer);
        this.values = new Map();
        this.simvars = new Map([
            [
                'flightTime',
                {
                    subscriber: bus.getSubscriber(),
                    topic: 'simTime',
                    handler: this.handleSimTime.bind(this),
                },
            ],
            [
                'heightDifference',
                {
                    subscriber: bus.getSubscriber(),
                    topic: 'pressure_alt',
                    handler: this.handlePressureAltitude.bind(this),
                },
            ],
        ]);
    }
    publishTopic(v, topic) {
        var _a;
        if (!this.values.has(topic))
            this.values.set(topic, v);
        this.publish(topic, v - ((_a = this.values.get(topic)) !== null && _a !== void 0 ? _a : 0));
    }
    handleSimTime(v) {
        this.publishTopic(v, 'flightTime');
    }
    handlePressureAltitude(v) {
        this.publishTopic(v, 'heightDifference');
    }
}

class SimForcePublisher extends SimVarPublisher {
    constructor(bus, pacer) {
        super(SimForcePublisher.simvars, bus, pacer);
    }
}
SimForcePublisher.simvars = new Map([
    ['g_meter', { name: 'G FORCE', type: 'G Force' }],
]);

class SunriseSunsetTimePublisher extends BasePublisher {
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
    }
    onUpdate() {
        this.publishZuluSunriseTime();
        this.publishZuluSunsetTime();
    }
    publishZuluSunriseTime() {
        const zuluSunriseTime = SimVar.GetSimVarValue('E:ZULU SUNRISE TIME', 'seconds');
        this.publish('zulu_sunrise_time', zuluSunriseTime);
    }
    publishZuluSunsetTime() {
        const zuluSunsetTime = SimVar.GetSimVarValue('E:ZULU SUNSET TIME', 'seconds');
        this.publish('zulu_sunset_time', zuluSunsetTime);
    }
}

var VarioIndicatorNavBoxSettingMode;
(function (VarioIndicatorNavBoxSettingMode) {
    VarioIndicatorNavBoxSettingMode["AverageVario"] = "Avg.vario";
    VarioIndicatorNavBoxSettingMode["Time"] = "Time";
    VarioIndicatorNavBoxSettingMode["FlightTime"] = "Flight time";
    VarioIndicatorNavBoxSettingMode["Netto"] = "Netto";
    VarioIndicatorNavBoxSettingMode["OutsideTemp"] = "Out.Temp.";
    VarioIndicatorNavBoxSettingMode["AltitudeM"] = "Altitude (m)";
    VarioIndicatorNavBoxSettingMode["TAS"] = "TAS";
    VarioIndicatorNavBoxSettingMode["SpeedLast60s"] = "60' speed";
    VarioIndicatorNavBoxSettingMode["AltitudeFt"] = "Altitude (ft)";
    VarioIndicatorNavBoxSettingMode["FlightLevel"] = "Flight level";
    VarioIndicatorNavBoxSettingMode["IAS"] = "IAS";
    VarioIndicatorNavBoxSettingMode["AverageNetto"] = "Avg. Netto";
    VarioIndicatorNavBoxSettingMode["Height"] = "Height";
})(VarioIndicatorNavBoxSettingMode || (VarioIndicatorNavBoxSettingMode = {}));
var VarioIndicatorNeedleSettingMode;
(function (VarioIndicatorNeedleSettingMode) {
    VarioIndicatorNeedleSettingMode["Vario"] = "Vario";
    VarioIndicatorNeedleSettingMode["Netto"] = "Netto";
})(VarioIndicatorNeedleSettingMode || (VarioIndicatorNeedleSettingMode = {}));
var VarioIndicatorRedDiamondSettingMode;
(function (VarioIndicatorRedDiamondSettingMode) {
    VarioIndicatorRedDiamondSettingMode["None"] = "No Diamond";
    VarioIndicatorRedDiamondSettingMode["Average"] = "Average";
    VarioIndicatorRedDiamondSettingMode["Netto"] = "Netto";
    VarioIndicatorRedDiamondSettingMode["Gmeter"] = "G-meter";
})(VarioIndicatorRedDiamondSettingMode || (VarioIndicatorRedDiamondSettingMode = {}));
var VarioIndicatorYellowBarSettingMode;
(function (VarioIndicatorYellowBarSettingMode) {
    VarioIndicatorYellowBarSettingMode["None"] = "No bar";
    VarioIndicatorYellowBarSettingMode["MinMaxVario"] = "Min./Max.";
    VarioIndicatorYellowBarSettingMode["Gmeter"] = "G-meter";
})(VarioIndicatorYellowBarSettingMode || (VarioIndicatorYellowBarSettingMode = {}));
var VarioIndicatorSideBarSettingMode;
(function (VarioIndicatorSideBarSettingMode) {
    VarioIndicatorSideBarSettingMode["None"] = "No bar";
    VarioIndicatorSideBarSettingMode["STF"] = "STF bar";
})(VarioIndicatorSideBarSettingMode || (VarioIndicatorSideBarSettingMode = {}));
class VarioIndicatorUserSettings extends DefaultUserSettingManager {
    static getManager(bus) {
        var _a;
        return ((_a = VarioIndicatorUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (VarioIndicatorUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'varioNeedle',
                defaultValue: VarioIndicatorNeedleSettingMode.Vario,
            },
            {
                name: 'navBoxesDisplayed',
                defaultValue: 4,
            },
            {
                name: 'navBox1',
                defaultValue: VarioIndicatorNavBoxSettingMode.AverageVario,
            },
            {
                name: 'navBox2',
                defaultValue: VarioIndicatorNavBoxSettingMode.Netto,
            },
            {
                name: 'navBox3',
                defaultValue: VarioIndicatorNavBoxSettingMode.AltitudeM,
            },
            {
                name: 'navBox4',
                defaultValue: VarioIndicatorNavBoxSettingMode.TAS,
            },
            {
                name: 'yellowBar',
                defaultValue: VarioIndicatorYellowBarSettingMode.MinMaxVario,
            },
            {
                name: 'redDiamond',
                defaultValue: VarioIndicatorRedDiamondSettingMode.Average,
            },
            {
                name: 'isMcSettingVisible',
                defaultValue: true,
            },
            {
                name: 'sideBar',
                defaultValue: VarioIndicatorSideBarSettingMode.STF,
            },
            {
                name: 'isScaleLinear',
                defaultValue: true,
            },
            {
                name: 'varioNeedleFilter',
                defaultValue: 1.5,
            },
            {
                name: 'nettoFilter',
                defaultValue: 1.5,
            },
            {
                name: 'varioRange',
                defaultValue: 5,
            },
            {
                name: 'integratorTime',
                defaultValue: 20,
            },
            {
                name: 'nettoTime',
                defaultValue: 20,
            },
        ])));
    }
}

class VariometerPublisher extends SimVarPublisher {
    constructor(bus, pacer) {
        super(VariometerPublisher.simvars, bus, pacer);
    }
}
VariometerPublisher.simvars = new Map([
    ['total_energy', { name: 'VARIOMETER TOTAL ENERGY:1', type: SimVarValueType.MetersPerSecond }],
    ['netto', { name: 'VARIOMETER NETTO:1', type: SimVarValueType.MetersPerSecond }],
    ['speed_to_fly', { name: 'VARIOMETER SPEED TO FLY:1', type: 'kilometers per hour' }],
    ['speed_to_fly_glide_ratio', { name: 'VARIOMETER SPEED TO FLY GLIDE RATIO:1', type: SimVarValueType.Number }],
    ['mac_cready_setting', { name: 'VARIOMETER MAC CREADY SETTING:1', type: SimVarValueType.MetersPerSecond }],
]);

class VolumePublisher extends SimVarPublisher {
    constructor(bus, pacer) {
        super(VolumePublisher.simvars, bus, pacer);
    }
}
VolumePublisher.simvars = new Map([
    ['variometer_volume', { name: 'L:XMLVAR_VARIOMETER_VOLUME', type: SimVarValueType.Percent }],
]);

class WeightAndBalancePublisher extends SimVarPublisher {
    constructor(bus, pacer) {
        super(WeightAndBalancePublisher.simvars, bus, pacer);
    }
}
WeightAndBalancePublisher.simvars = new Map([
    ['wing_area', { name: 'WING AREA', type: 'm2' }],
    ['total_weight', { name: 'TOTAL WEIGHT', type: 'kilograms' }],
]);
class ComputedWeightAndBalancePublisher extends ComputedSimVarPublisher {
    constructor(bus, pacer) {
        super(bus, pacer);
        this.wingArea = Subject.create(0);
        this.totalWeight = Subject.create(0);
        this.simvars = new Map([
            [
                'wing_area',
                {
                    subscriber: bus.getSubscriber(),
                    topic: 'wing_area',
                    handler: (v) => this.wingArea.set(v),
                },
            ],
            [
                'total_weight',
                {
                    subscriber: bus.getSubscriber(),
                    topic: 'total_weight',
                    handler: (v) => this.totalWeight.set(v),
                },
            ],
        ]);
        this.wingArea.sub(this.publishWingLoading.bind(this));
        this.totalWeight.sub(this.publishWingLoading.bind(this));
    }
    publishWingLoading() {
        if (this.wingArea.get() !== 0) {
            this.publish('wing_loading', this.totalWeight.get() / this.wingArea.get());
        }
        else {
            this.publish('wing_loading', 0);
        }
    }
    consumerFilter(consumer) {
        return consumer.whenChanged();
    }
}

var ETACalculationSettingMode;
(function (ETACalculationSettingMode) {
    ETACalculationSettingMode["MacCready"] = "MacCready";
    ETACalculationSettingMode["AverageVario"] = "Average Vario";
    ETACalculationSettingMode["AverageSpeedVario"] = "Avg.speed/Vario";
    ETACalculationSettingMode["AverageSpeedMc"] = "Avg.speed/Mc";
})(ETACalculationSettingMode || (ETACalculationSettingMode = {}));
class QNHAndResUserSettings extends DefaultUserSettingManager {
    static getManager(bus) {
        var _a;
        return ((_a = QNHAndResUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (QNHAndResUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'fieldElevation',
                defaultValue: SimVar.GetSimVarValue('PLANE ALTITUDE', 'feet'),
            },
            {
                name: 'qnh',
                defaultValue: 1013,
            },
            {
                name: 'safetyAltitude',
                defaultValue: 656,
            },
            {
                name: 'ETACalculation',
                defaultValue: ETACalculationSettingMode.MacCready,
            },
        ])));
    }
}

class VolumeUserSettings extends DefaultUserSettingManager {
    static getManager(bus) {
        var _a;
        return ((_a = VolumeUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (VolumeUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'variometer_volume',
                defaultValue: 1,
            },
        ])));
    }
}

class Warnings {
    constructor(_bus, _soundPublisher, _logicHandler, _warnings) {
        this.soundPublisher = _soundPublisher;
        this.warningsManager = new WarningManager(_warnings, _logicHandler, this.onWarningText.bind(this), this.onWarningSound.bind(this));
    }
    onWarningText(warning) { }
    onWarningSound(warning, active) {
        if (warning.soundId) {
            if (active) {
                this.soundPublisher.startSound(warning.soundId);
            }
            else {
                this.soundPublisher.stopSound(warning.soundId);
            }
        }
    }
}

class VolumeManager {
    constructor(bus, volumeUserSettingsManager, volumeSimVarsPublisher) {
        this.bus = bus;
        this.volumeUserSettingsManager = volumeUserSettingsManager;
        this.volumeSimVarsPublisher = volumeSimVarsPublisher;
        const volumeEvents = this.bus.getSubscriber();
        volumeEvents.on('VolumeEvent').handle(this.handleVolumeEvent.bind(this));
    }
    handleVariometerVolume(value, step) {
        const newValue = Utils.Clamp(value + step, 0, 100);
        SimVar.SetSimVarValue('L:XMLVAR_VARIOMETER_VOLUME', 'Percent', newValue);
        this.volumeUserSettingsManager.getSetting('variometer_volume').set(newValue);
    }
    handleVolumeEvent(event) {
        switch (event) {
            case ASEvents.UPPER_LEFT_DEC:
                this.handleVariometerVolume(this.volumeSimVarsPublisher.getValue('variometer_volume'), -5);
                break;
            case ASEvents.UPPER_LEFT_INC:
                this.handleVariometerVolume(this.volumeSimVarsPublisher.getValue('variometer_volume'), 5);
                break;
        }
    }
}

class ASShared extends BaseInstrument {
    constructor(_name) {
        super();
        this.aircraftName = '';
        MapIconImageCache.init();
        this.name = _name;
        this.bus = new EventBus();
        this.aSEventPublisher = new ASEventPublisher(this.bus);
        this.soundPublisher = new SoundPublisher(this.bus);
        this.FLARMTrafficInstrument = new FLARMTrafficInstrument(this.bus, {
            realTimeUpdateFreq: 2,
            simTimeUpdateFreq: 1,
            contactDeprecateTime: 10,
        });
        this.backplane = new InstrumentBackplane();
        this.backplane.addPublisher('aSEvents', this.aSEventPublisher);
        this.backplane.addPublisher('clock', new ClockPublisher(this.bus));
        this.backplane.addPublisher('adc', new ADCPublisher(this.bus));
        this.backplane.addPublisher('gnss', new GNSSPublisher(this.bus));
        this.backplane.addPublisher('flightInfo', new FlightInfoPublisher(this.bus));
        this.backplane.addPublisher('electrical', new ElectricalPublisher(this.bus));
        this.backplane.addPublisher('sunriseSunset', new SunriseSunsetTimePublisher(this.bus, new DeltaPacer(1)));
        this.backplane.addPublisher('sound', this.soundPublisher);
        this.backplane.addPublisher('variometer', new VariometerPublisher(this.bus));
        this.backplane.addPublisher('weightAndBalance', new WeightAndBalancePublisher(this.bus));
        this.backplane.addPublisher('computedWeightAndBalance', new ComputedWeightAndBalancePublisher(this.bus));
        this.backplane.addInstrument('flarmTraffic', this.FLARMTrafficInstrument);
        this.mapRangeController = new MapEventController(this.bus);
        this.loader = new FacilityLoader(FacilityRepository.getRepository(this.bus));
        this.calculator = new FlightPathCalculator(this.loader, {
            bankAngle: 30,
            defaultSpeed: 100,
            defaultClimbRate: 500,
        });
        this.planner = FlightPlanner.getPlanner(this.bus, this.calculator);
        this.fms = new Fms(this.bus, this.planner);
        this.flarm = new FLARM(this.bus, this.FLARMTrafficInstrument, 15, 2, 1);
        this.VolumeManager = new VolumeManager(this.bus, VolumeUserSettings.getManager(this.bus), new VolumePublisher(this.bus));
        this.KeyManager = new KeysManager(QNHAndResUserSettings.getManager(this.bus));
        this.XmlLogicHost = new CompositeLogicXMLHost();
        this.warningFactory = new XMLWarningFactory(this);
        this.soundServer = new SoundServer(this.bus, this.soundPublisher, this);
        this.modeViewService = new ModeViewService(this.bus, 'Container');
        this.initDuration = 3000;
    }
    Init() {
        super.Init();
        this.flarm.init();
        new Warnings(this.bus, this.soundPublisher, this.XmlLogicHost, this.warningFactory.parseConfig(this.xmlConfig));
    }
    parseXMLConfig() {
        super.parseXMLConfig();
        if (this.xmlConfig) {
            let aircraftName = this.xmlConfig.getElementsByTagName('AircraftName');
            if (aircraftName.length > 0 && aircraftName[0].textContent) {
                this.aircraftName = aircraftName[0].textContent.toUpperCase();
            }
        }
    }
    connectedCallback() {
        super.connectedCallback();
        this.backplane.init();
    }
    onInteractionEvent(args) {
        const mapEvent = mapHEventToASEvent(args[0], this.name);
        if (mapEvent !== undefined) {
            this.aSEventPublisher.dispatchASEvent(mapEvent);
        }
    }
    Update() {
        super.Update();
        this.backplane.onUpdate();
        if (this.previousScreenState !== this.screenState) {
            this.onScreenStateChanged();
        }
        this.XmlLogicHost.update(this.deltaTime);

    }
    get isInteractive() {
        return false;
    }
    onScreenStateChanged() {
        this.bus.pub('vc_screen_state', {
            previous: this.previousScreenState,
            current: this.screenState,
        });
        switch (this.screenState) {
            case ScreenState.INIT:
                this.modeViewService.openByName('StartUpLogoPage');
                break;
            case ScreenState.ON:
                if (this.previousScreenState === undefined) {
                    this.modeViewService.openByName('AirportMode');
                }
                else if (this.previousScreenState === ScreenState.INIT) {
                    this.modeViewService.openByName('StartUpProfilePage');
                }
                break;
        }

        this.previousScreenState = this.screenState;
    }
    onSoundEnd(soundEventId) {
        this.soundServer.onSoundEnd(soundEventId);
    }

}

var FieldActionEvent;
(function (FieldActionEvent) {
    FieldActionEvent[FieldActionEvent["EDIT"] = 0] = "EDIT";
    FieldActionEvent[FieldActionEvent["CLOSE"] = 1] = "CLOSE";
    FieldActionEvent[FieldActionEvent["OK"] = 2] = "OK";
    FieldActionEvent[FieldActionEvent["CANCEL"] = 3] = "CANCEL";
})(FieldActionEvent || (FieldActionEvent = {}));
var WatchActionEvent;
(function (WatchActionEvent) {
    WatchActionEvent[WatchActionEvent["START"] = 0] = "START";
    WatchActionEvent[WatchActionEvent["STOP"] = 1] = "STOP";
    WatchActionEvent[WatchActionEvent["RESET"] = 2] = "RESET";
})(WatchActionEvent || (WatchActionEvent = {}));
var ValidationActionsEvent;
(function (ValidationActionsEvent) {
    ValidationActionsEvent[ValidationActionsEvent["SELECT"] = 0] = "SELECT";
    ValidationActionsEvent[ValidationActionsEvent["CLOSE"] = 1] = "CLOSE";
})(ValidationActionsEvent || (ValidationActionsEvent = {}));
var NearActionsEvent;
(function (NearActionsEvent) {
    NearActionsEvent[NearActionsEvent["GOTO"] = 0] = "GOTO";
})(NearActionsEvent || (NearActionsEvent = {}));
var VarioIndicatorActionEvent;
(function (VarioIndicatorActionEvent) {
    VarioIndicatorActionEvent[VarioIndicatorActionEvent["EDIT"] = 0] = "EDIT";
    VarioIndicatorActionEvent[VarioIndicatorActionEvent["CLOSE"] = 1] = "CLOSE";
    VarioIndicatorActionEvent[VarioIndicatorActionEvent["OK"] = 2] = "OK";
    VarioIndicatorActionEvent[VarioIndicatorActionEvent["CANCEL"] = 3] = "CANCEL";
    VarioIndicatorActionEvent[VarioIndicatorActionEvent["RESET_G"] = 4] = "RESET_G";
})(VarioIndicatorActionEvent || (VarioIndicatorActionEvent = {}));
var AirportModeActionEvent;
(function (AirportModeActionEvent) {
    AirportModeActionEvent[AirportModeActionEvent["WIND"] = 0] = "WIND";
    AirportModeActionEvent[AirportModeActionEvent["AIRSPACE"] = 1] = "AIRSPACE";
    AirportModeActionEvent[AirportModeActionEvent["MORE"] = 2] = "MORE";
    AirportModeActionEvent[AirportModeActionEvent["MAP"] = 3] = "MAP";
    AirportModeActionEvent[AirportModeActionEvent["SELECT"] = 4] = "SELECT";
    AirportModeActionEvent[AirportModeActionEvent["MC_BAL"] = 5] = "MC_BAL";
    AirportModeActionEvent[AirportModeActionEvent["RADIO"] = 6] = "RADIO";
    AirportModeActionEvent[AirportModeActionEvent["XPDR"] = 7] = "XPDR";
    AirportModeActionEvent[AirportModeActionEvent["TEAM"] = 8] = "TEAM";
    AirportModeActionEvent[AirportModeActionEvent["PAN"] = 9] = "PAN";
    AirportModeActionEvent[AirportModeActionEvent["FLARM"] = 10] = "FLARM";
    AirportModeActionEvent[AirportModeActionEvent["EVENT"] = 11] = "EVENT";
    AirportModeActionEvent[AirportModeActionEvent["SEND"] = 12] = "SEND";
    AirportModeActionEvent[AirportModeActionEvent["ROTATE_FAI"] = 13] = "ROTATE_FAI";
    AirportModeActionEvent[AirportModeActionEvent["LAYOUT"] = 14] = "LAYOUT";
    AirportModeActionEvent[AirportModeActionEvent["MARK"] = 15] = "MARK";
    AirportModeActionEvent[AirportModeActionEvent["NOTAM"] = 16] = "NOTAM";
    AirportModeActionEvent[AirportModeActionEvent["NIGHT"] = 17] = "NIGHT";
    AirportModeActionEvent[AirportModeActionEvent["OFF"] = 18] = "OFF";
})(AirportModeActionEvent || (AirportModeActionEvent = {}));
var McBalPopUpActionEvent;
(function (McBalPopUpActionEvent) {
    McBalPopUpActionEvent[McBalPopUpActionEvent["CLOSE"] = 0] = "CLOSE";
    McBalPopUpActionEvent[McBalPopUpActionEvent["BAL"] = 1] = "BAL";
    McBalPopUpActionEvent[McBalPopUpActionEvent["RESET"] = 2] = "RESET";
})(McBalPopUpActionEvent || (McBalPopUpActionEvent = {}));
var QNHAndResStartUpActionEvent;
(function (QNHAndResStartUpActionEvent) {
    QNHAndResStartUpActionEvent[QNHAndResStartUpActionEvent["QNH_ELEV"] = 0] = "QNH_ELEV";
    QNHAndResStartUpActionEvent[QNHAndResStartUpActionEvent["DEFAULT"] = 1] = "DEFAULT";
})(QNHAndResStartUpActionEvent || (QNHAndResStartUpActionEvent = {}));

class SoftKeyMenu {
    constructor(menuSystem, temporary = false, isActive = false) {
        this.menuSystem = menuSystem;
        this.temporary = temporary;
        this.isActive = isActive;
        this.menuItems = [];
    }
    addItem(index, label, callback, disabled = false, hidden = false, icon) {
        this.menuItems[index] = {
            label: Subject.create(label),
            callback,
            disabled: Subject.create(callback === undefined || disabled),
            hidden: Subject.create(hidden),
            icon,
        };
    }
    replaceLabel(index, newLabel) {
        this.menuItems[index].label.set(newLabel);
    }
    replaceCallback(index, callback) {
        this.menuItems[index].callback = callback;
    }
    show(index, shown = true) {
        this.menuItems[index].hidden.set(!shown);
    }
    enable(index, enabled = true) {
        this.menuItems[index].disabled.set(!enabled);
    }
    removeItem(index) {
        this.menuItems[index] = SoftKeyMenu.EmptyMenuItem;
    }
    getItem(index) {
        return this.menuItems[index];
    }
    handleBack() {
        this.menuSystem.back();
    }
    forEach(each) {
        for (let i = 0; i < this.menuSystem.nbOfSoftkeys; i++) {
            const item = this.menuItems[i];
            each(item !== null && item !== void 0 ? item : SoftKeyMenu.EmptyMenuItem, i);
        }
    }
    handleItemPressed(index) {
        const menuItem = this.menuItems[index];
        if (menuItem && menuItem.callback && !menuItem.disabled.get()) {
            menuItem.callback(this);
        }
    }
}
SoftKeyMenu.EmptyMenuItem = {
    label: Subject.create(''),
    callback: undefined,
    disabled: Subject.create(true),
    hidden: Subject.create(true),
    icon: undefined,
};

class AboutMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishAboutMenuEvent(ValidationActionsEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
    }
}

class AirportModeMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, true);
        this.index = 0;
        this.items = new Array([
            { index: 0, label: 'AIRSPACE' },
            { index: 1, label: 'WIND' },
            { index: 3, label: 'MAP' },
            {
                index: 4,
                label: 'MC/BAL',
                callback: () => {
                    this.menuSystem.asMenuPublisher.publishAirportModeMenuEvent(AirportModeActionEvent.MC_BAL);
                },
            },
            { index: 5, label: 'SELECT' },
        ], [
            { index: 0, label: 'RADIO' },
            { index: 1, label: 'XPDR' },
            { index: 3, label: 'TEAM' },
            { index: 4, label: 'PAN' },
            { index: 5, label: 'FLARM' },
        ], [
            { index: 0, label: 'EVENT' },
            { index: 1, label: 'SEND' },
            { index: 3, label: 'ROT.FAI' },
            { index: 4, label: 'LAYOUT' },
            { index: 5, label: 'MARK' },
        ], [
            { index: 3, label: 'NOTAM' },
            { index: 4, label: 'NIGHT' },
            { index: 5, label: 'OFF' },
        ]);
        [0, 1, 3, 4, 5].forEach((i) => this.addItem(i, ''));
        this.addItem(2, 'MORE>>', () => {
            this.menuSystem.asMenuPublisher.publishAirportModeMenuEvent(AirportModeActionEvent.MORE);
            this.nextMenu();
        });
        this.setMenu();
    }
    nextMenu() {
        this.index = (this.index + 1) % this.items.length;
        this.setMenu();
    }
    setMenu() {
        let indexes = [0, 1, 3, 4, 5];
        this.items[this.index].forEach((item) => {
            this.replaceLabel(item.index, item.label);
            this.show(item.index);
            this.enable(item.index, item.callback !== undefined);
            this.replaceCallback(item.index, item.callback);
            indexes = indexes.filter((i) => i != item.index);
        });
        indexes.forEach((i) => this.show(i, false));
    }
}

class EditMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.addItem(3, 'CLOSE', () => {
            console.log('should go back');
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
        this.addItem(5, 'EDIT', () => {
            this.menuSystem.asMenuPublisher.publishFieldActionEvent(FieldActionEvent.EDIT);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
    }
}

class FieldMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.addItem(3, 'CANCEL', () => {
            this.menuSystem.asMenuPublisher.publishFieldActionEvent(FieldActionEvent.CANCEL);
        });
        this.addItem(5, 'OK', () => {
            this.menuSystem.asMenuPublisher.publishFieldActionEvent(FieldActionEvent.OK);
        });
    }
}

class GraphicsMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishGraphicsMenuEvent(ValidationActionsEvent.CLOSE);
        });
        this.addItem(5, 'SELECT', () => {
            this.menuSystem.asMenuPublisher.publishGraphicsMenuEvent(ValidationActionsEvent.SELECT);
        });
    }
}

class HardwareMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishHardwareMenuEvent(ValidationActionsEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
        this.addItem(5, 'SELECT', () => {
            this.menuSystem.asMenuPublisher.publishHardwareMenuEvent(ValidationActionsEvent.SELECT);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
}

class InfoMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.watchAction = 0;
        this.addItem(4, 'START', () => {
            this.menuSystem.asMenuPublisher.publishWatchActionEvent(this.watchAction);
            this.watchAction = this.watchAction + 1 == 3 ? 0 : this.watchAction + 1;
            this.replaceLabel(4, WatchActionEvent[this.watchAction]);
        });
        this.addItem(5, 'MARK', () => { }, true);
    }
}

class McBalPopUpMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishMcBalPopUpMenuEvent(McBalPopUpActionEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
        this.addItem(4, '+0.0m/s', () => {
            this.menuSystem.asMenuPublisher.publishMcBalPopUpMenuEvent(McBalPopUpActionEvent.RESET);
        }, false);
        this.addItem(5, 'BAL', () => {
            this.menuSystem.asMenuPublisher.publishMcBalPopUpMenuEvent(McBalPopUpActionEvent.BAL);
        }, true, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
}

class ASMenuPublisher extends BasePublisher {
    publishFieldActionEvent(event) {
        this.publish('FieldActionEvent', event);
    }
    publishWatchActionEvent(event) {
        this.publish('WatchActionEvent', event);
    }
    publishSetupMenuEvent(event) {
        this.publish('SetupMenuEvent', event);
    }
    publishGraphicsMenuEvent(event) {
        this.publish('GraphicsMenuEvent', event);
    }
    publishQNHAndResMenuEvent(event) {
        this.publish('QNHAndResMenuEvent', event);
    }
    publishNearMenuEvent(event) {
        this.publish('NearMenuEvent', event);
    }
    publishVarioParametersMenuEvent(event) {
        this.publish('VarioParametersMenuEvent', event);
    }
    publishHardwareMenuEvent(event) {
        this.publish('HardwareMenuEvent', event);
    }
    publishPolarMenuEvent(event) {
        this.publish('PolarMenuEvent', event);
    }
    publishVarioIndicatorMenuEvent(event) {
        this.publish('VarioIndicatorMenuEvent', event);
    }
    publishAboutMenuEvent(event) {
        this.publish('AboutMenuEvent', event);
    }
    publishAirportModeMenuEvent(event) {
        this.publish('AirportModeMenuEvent', event);
    }
    publishMcBalPopUpMenuEvent(event) {
        this.publish('McBalPopUpMenuEvent', event);
    }
    publishQNHAndResStartUpMenuEvent(event) {
        this.publish('QNHAndResStartUpMenuEvent', event);
    }
}

class MenuSystem {
    constructor(bus, nbOfSoftkeys) {
        this.bus = bus;
        this.nbOfSoftkeys = nbOfSoftkeys;
        this.menuStack = [new SoftKeyMenu(this)];
        this.registeredMenus = {};
        this.lastSoftKeyHit = 0;
        this.temporaryDelay = 5000;
        this.asEventSubscriber = bus.getSubscriber();
        this.asMenuPublisher = new ASMenuPublisher(bus);
        this.asMenuPublisher.startPublish();
        this.asEventSubscriber.on('SoftKeyEvent').handle((event) => {
            let eventNeedsRouting = false;
            if (this.currentMenu.temporary) {
                eventNeedsRouting = this.handleTemporaryMenuDisplay();
            }
            else {
                eventNeedsRouting = true;
            }
            if (eventNeedsRouting) {
                this.handleSoftKey(event);
            }
        });
    }
    handleTemporaryMenuDisplay() {
        this.lastSoftKeyHit = Date.now();
        clearTimeout(this.timeoutHandler);
        this.timeoutHandler = setTimeout(() => {
            if (Date.now() - this.lastSoftKeyHit > this.temporaryDelay - 300) {
                this.hideMenu();
                this.currentMenu.isActive = false;
            }
        }, this.temporaryDelay);
        if (!this.currentMenu.isActive) {
            this.showMenu();
            this.currentMenu.isActive = true;
            return false;
        }
        else {
            return true;
        }
    }
    showMenu() {
        var _a;
        (_a = this.softKeys) === null || _a === void 0 ? void 0 : _a.showMenu();
    }
    hideMenu() {
        var _a;
        (_a = this.softKeys) === null || _a === void 0 ? void 0 : _a.hideMenu();
    }
    get currentMenu() {
        return this.menuStack[this.menuStack.length - 1];
    }
    addMenu(name, entry) {
        this.registeredMenus[name] = entry;
    }
    pushMenu(name) {
        if (this.currentMenu)
            this.currentMenu.isActive = false;
        clearTimeout(this.timeoutHandler);
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
        if (this.currentMenu.temporary)
            this.hideMenu();
        else
            this.showMenu();
    }
    replaceMenu(name) {
        if (this.menuStack.length > 1) {
            this.menuStack.pop();
        }
        this.menuStack.push(this.registeredMenus[name]);
        this.renderToSoftKeys();
    }
    back() {
        if (this.menuStack.length == 1) {
            return;
        }
        this.menuStack.pop();
        this.renderToSoftKeys();
    }
    clear() {
        this.menuStack.length = 1;
        this.renderToSoftKeys();
    }
    attachSoftKeys(softKeys) {
        this.softKeys = softKeys;
        this.currentMenu.temporary ? this.hideMenu() : this.showMenu();
        this.renderToSoftKeys();
    }
    renderToSoftKeys() {
        this.currentMenu.forEach((item, index) => {
            var _a;
            (_a = this.softKeys) === null || _a === void 0 ? void 0 : _a.setMenuItem(index, item);
        });
    }
    handleSoftKey(event) {
        const softKeyIndex = parseInt(event.charAt(7));
        this.currentMenu.handleItemPressed(softKeyIndex);
    }
}

class NearMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(1, 'SORT', () => { }, true, false);
        this.addItem(2, 'REPORT', () => { }, true, false);
        this.addItem(3, 'FREQ', () => { }, true, false);
        this.addItem(4, 'VIEW', () => { }, true, false);
        this.addItem(5, 'GOTO', () => {
            this.menuSystem.asMenuPublisher.publishNearMenuEvent(NearActionsEvent.GOTO);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
}

class PolarMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishPolarMenuEvent(ValidationActionsEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
    }
}

class QNHAndResMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
        this.addItem(5, 'EDIT', () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.EDIT);
            this.setValidationMenu();
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
    setSelectMenu() {
        this.replaceLabel(3, 'CLOSE');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.CLOSE);
        });
        this.replaceLabel(5, 'EDIT');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.EDIT);
            this.setValidationMenu();
        });
    }
    setValidationMenu() {
        this.replaceLabel(3, 'CANCEL');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.CANCEL);
            this.setSelectMenu();
        });
        this.replaceLabel(5, 'OK');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResMenuEvent(FieldActionEvent.OK);
            this.setSelectMenu();
        });
    }
}

class SetupMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(5, 'SELECT', () => this.menuSystem.asMenuPublisher.publishSetupMenuEvent(ValidationActionsEvent.SELECT), false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
}

class SoftKey extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.menuItem = SoftKeyMenu.EmptyMenuItem;
        this.softKeyElement = new NodeReference();
        this.labelElement = new NodeReference();
        this.iconElement = new NodeReference();
        this.setLabel = (text) => {
            this.labelElement.instance.textContent = text;
        };
        this.setDisabled = (isDisabled) => {
            if (isDisabled) {
                this.softKeyElement.instance.classList.add('text-disabled');
            }
            else {
                this.softKeyElement.instance.classList.remove('text-disabled');
            }
        };
        this.setHidden = (isHidden) => {
            if (isHidden) {
                this.softKeyElement.instance.classList.add('visibility-hidden');
            }
            else {
                this.softKeyElement.instance.classList.remove('visibility-hidden');
            }
        };
        this.setIcon = (iconPath) => {
            if (iconPath !== undefined) {
                this.iconElement.instance.src = iconPath;
            }
            else {
                this.iconElement.instance.src = '';
            }
        };
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.setMenuItem(this.props.menuItem);
    }
    setMenuItem(item) {
        this.unsubscribeFromMenuItem(this.menuItem);
        this.menuItem = item;
        this.setLabel(item.label.get());
        item.label.sub(this.setLabel);
        this.setDisabled(item.disabled.get() === true);
        item.disabled.sub(this.setDisabled);
        this.setHidden(item.hidden.get() === true);
        item.hidden.sub(this.setHidden);
        this.setIcon(item.icon);
    }
    unsubscribeFromMenuItem(item) {
        item.disabled.unsub(this.setDisabled);
        item.label.unsub(this.setLabel);
        item.hidden.unsub(this.setHidden);
    }
    render() {
        return (FSComponent.buildComponent("div", { class: "softkey-item-label", ref: this.softKeyElement },
            FSComponent.buildComponent("div", { class: "softkey-content", ref: this.labelElement }),
            FSComponent.buildComponent("img", { class: "softkey-icon", ref: this.iconElement })));
    }
}

class SoftKeyRenderer extends DisplayComponent {
    constructor(props) {
        super(props);
        this.menuRef = new NodeReference();
        this.refs = [];
        this.menuSystem = this.props.menuSystem;
    }
    buildSoftKeys(_row) {
        var _a;
        const softKeys = [];
        const startIndex = _row === 'top' ? 0 : this.menuSystem.nbOfSoftkeys / 2;
        for (let i = startIndex; i < startIndex + this.menuSystem.nbOfSoftkeys / 2; i++) {
            const ref = FSComponent.createRef();
            softKeys.push(FSComponent.buildComponent(SoftKey, { ref: ref, menuItem: SoftKeyMenu.EmptyMenuItem }));
            if (this.props.softkeyIndexMapping.get(i) !== undefined) {
                this.refs[(_a = this.props.softkeyIndexMapping.get(i)) !== null && _a !== void 0 ? _a : i] = ref;
            }
        }
        return softKeys;
    }
    onAfterRender() {
        this.menuSystem.attachSoftKeys(this);
    }
    setMenuItem(index, menuItem) {
        this.refs[index].instance.setMenuItem(menuItem);
    }
    showMenu() {
        this.menuRef.instance.style.visibility = 'visible';
    }
    hideMenu() {
        this.menuRef.instance.style.visibility = 'hidden';
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'softkey-menu', ref: this.menuRef },
            FSComponent.buildComponent("div", { class: 'softkey-row top' }, this.buildSoftKeys('top')),
            FSComponent.buildComponent("div", { class: 'softkey-row bottom' }, this.buildSoftKeys('bottom'))));
    }
}

class StartUpProfileMenu extends SoftKeyMenu {
    constructor(menuSystem, viewService) {
        super(menuSystem, false);
        this.addItem(3, 'DEFAULT', () => viewService.openByName('StartUpQNHPage'));
        this.addItem(5, 'SELECT', () => viewService.openByName('StartUpQNHPage'));
    }
}

class StartUpQNHMenu extends SoftKeyMenu {
    constructor(menuSystem, viewService, QNHAndResSettings) {
        super(menuSystem, false);
        this.addItem(3, 'QNH', () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResStartUpMenuEvent(QNHAndResStartUpActionEvent.QNH_ELEV);
            const newLabel = this.getItem(3).label.get() === 'QNH' ? 'ELEV' : 'QNH';
            this.replaceLabel(3, newLabel);
        });
        this.addItem(4, `${QNHAndResSettings.getSetting('fieldElevation').get().toFixed()}ft`, () => {
            this.menuSystem.asMenuPublisher.publishQNHAndResStartUpMenuEvent(QNHAndResStartUpActionEvent.DEFAULT);
        });
        this.addItem(5, 'OK', () => viewService.openByName('AirportMode'));
    }
}

class VarioIndicatorMenu extends SoftKeyMenu {
    constructor(menuSystem, temporary = false) {
        super(menuSystem, temporary);
        this.addItem(2, 'DEMO', () => { }, true);
        this.addItem(3, 'CLOSE', () => { }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
        this.addItem(4, 'RESET-G', () => {
            this.menuSystem.asMenuPublisher.publishVarioIndicatorMenuEvent(VarioIndicatorActionEvent.RESET_G);
        }, true, false);
        this.addItem(5, 'EDIT', () => { }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
        this.setSelectMenu();
    }
    setSelectMenu() {
        this.replaceLabel(3, 'CLOSE');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishVarioIndicatorMenuEvent(VarioIndicatorActionEvent.CLOSE);
        });
        this.replaceLabel(5, 'EDIT');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishVarioIndicatorMenuEvent(VarioIndicatorActionEvent.EDIT);
            this.setValidationMenu();
        });
        this.getItem(2).hidden.set(false);
        this.getItem(4).hidden.set(false);
    }
    setValidationMenu() {
        this.replaceLabel(3, 'CANCEL');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishVarioIndicatorMenuEvent(VarioIndicatorActionEvent.CANCEL);
            this.setSelectMenu();
        });
        this.replaceLabel(5, 'OK');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishVarioIndicatorMenuEvent(VarioIndicatorActionEvent.OK);
            this.setSelectMenu();
        });
        this.getItem(2).hidden.set(true);
        this.getItem(4).hidden.set(true);
    }
}

class VarioParametersMenu extends SoftKeyMenu {
    constructor(menuSystem) {
        super(menuSystem, false);
        this.addItem(3, 'CLOSE', () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.CLOSE);
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CANCEL.svg');
        this.addItem(5, 'EDIT', () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.EDIT);
            this.setValidationMenu();
        }, false, false, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/menu/ICON_GLIDERS_CHECKBOX.svg');
    }
    setSelectMenu() {
        this.replaceLabel(3, 'CLOSE');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.CLOSE);
        });
        this.replaceLabel(5, 'EDIT');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.EDIT);
            this.setValidationMenu();
        });
    }
    setValidationMenu() {
        this.replaceLabel(3, 'CANCEL');
        this.replaceCallback(3, () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.CANCEL);
            this.setSelectMenu();
        });
        this.replaceLabel(5, 'OK');
        this.replaceCallback(5, () => {
            this.menuSystem.asMenuPublisher.publishVarioParametersMenuEvent(FieldActionEvent.OK);
            this.setSelectMenu();
        });
    }
}

const AS9070_SoftKey_Mapping = new Map([
    [0, 0],
    [1, 1],
    [2, 2],
    [3, 3],
    [4, 4],
    [5, 5],
    [6, 6],
    [7, 7],
]);

/**
 * The different types of map projection changes.
 */
var MapProjectionChangeType;
(function (MapProjectionChangeType) {
    MapProjectionChangeType[MapProjectionChangeType["Target"] = 1] = "Target";
    MapProjectionChangeType[MapProjectionChangeType["Center"] = 2] = "Center";
    MapProjectionChangeType[MapProjectionChangeType["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType[MapProjectionChangeType["Range"] = 8] = "Range";
    MapProjectionChangeType[MapProjectionChangeType["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType[MapProjectionChangeType["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType[MapProjectionChangeType["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"] = 256] = "ProjectedResolution";
})(MapProjectionChangeType || (MapProjectionChangeType = {}));
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
class MapProjection {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
        // settable parameters
        this.target = new GeoPoint(0, 0);
        this.targetProjectedOffset = new Float64Array(2);
        this.targetProjected = new Float64Array(2);
        this.range = 1; // great-arc radians
        this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]); // [relX1, relY1, relX2, relY2]
        this.projectedSize = new Float64Array(2);
        // computed parameters
        this.center = new GeoPoint(0, 0);
        this.centerProjected = new Float64Array(2);
        this.projectedRange = 0; // projected distance between the range endpoints in pixels
        this.widthRange = 0; // great-arc radians
        this.heightRange = 0; // great-arc radians
        this.oldParameters = {
            target: new GeoPoint(0, 0),
            center: new GeoPoint(0, 0),
            targetProjected: new Float64Array(2),
            range: 1,
            rangeEndpoints: new Float64Array(4),
            scaleFactor: 1,
            rotation: 0,
            projectedSize: new Float64Array(2),
            projectedResolution: 0
        };
        this.queuedParameters = Object.assign({}, this.oldParameters);
        this.updateQueued = false;
        this.changeListeners = [];
        Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
        this.geoProjection = new MercatorProjection();
        Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
        this.targetProjected.set(this.centerProjected);
        this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
        this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection() {
        return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget() {
        return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
        return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected() {
        return this.targetProjected;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange() {
        return this.range;
    }
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints() {
        return this.rangeEndpoints;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange() {
        return this.widthRange;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange() {
        return this.heightRange;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.geoProjection.getScaleFactor();
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation() {
        return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected() {
        return this.centerProjected;
    }
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution() {
        return this.range / this.projectedRange;
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
        const endpoints = this.rangeEndpoints;
        const projectedWidth = this.projectedSize[0];
        const projectedHeight = this.projectedSize[1];
        const endpoint1 = MapProjection.tempVec2_3;
        endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
        endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
        const endpoint2 = MapProjection.tempVec2_4;
        endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
        endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
        const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
        const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
        return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
        if (isNaN(currentTargetProjected[0] + currentTargetProjected[1])) {
            return;
        }
        const currentCenterProjected = MapProjection.tempVec2_2;
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        let ratio = currentRange / this.range;
        if (isNaN(ratio) || ratio === 0) {
            return;
        }
        // iteratively find the appropriate scale factor (empiric testing shows this typically takes less than 4 iterations
        // to converge)
        let iterCount = 0;
        let ratioError = Math.abs(ratio - 1);
        let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
        while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER
            && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE
            && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
            this.geoProjection.setScaleFactor(ratio * this.geoProjection.getScaleFactor());
            this.geoProjection.project(this.target, currentTargetProjected);
            currentCenterProjected.set(currentTargetProjected);
            currentCenterProjected[0] -= this.targetProjectedOffset[0];
            currentCenterProjected[1] -= this.targetProjectedOffset[1];
            currentRange = this.calculateRangeAtCenter(currentCenterProjected);
            ratio = currentRange / this.range;
            const newRatioError = Math.abs(ratio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        // calculate the center point of the projection
        this.invert(currentCenterProjected, this.center);
        this.geoProjection.setCenter(this.center);
        // set the projection's pre-rotation to avoid anti-meridian wrapping issues
        const preRotation = Vec2Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, MapProjection.tempVec2_1);
        this.geoProjection.setPreRotation(preRotation);
        const width = this.projectedSize[0];
        const height = this.projectedSize[1];
        this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
        const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
        const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
        this.widthRange = this.geoDistance(left, right);
        const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
        const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
        this.heightRange = this.geoDistance(top, bottom);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
        parameters.target && this.target.set(parameters.target);
        parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
        parameters.range !== undefined && (this.range = parameters.range);
        parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
        parameters.rotation !== undefined && this.geoProjection.setPostRotation(parameters.rotation);
        this.recompute();
        const changeFlags = this.computeChangeFlags(this.oldParameters);
        this.notifyChangeListeners(changeFlags);
    }
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
        Object.assign(this.queuedParameters, parameters);
        this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
        if (this.updateQueued) {
            this.updateQueued = false;
            this.set(this.queuedParameters);
            for (const key in this.queuedParameters) {
                delete this.queuedParameters[key];
            }
        }
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
        this.projectedSize.set(size);
        Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
        this.geoProjection.setTranslation(this.centerProjected);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
        this.targetProjectedOffset.set(offset);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.target.set(this.target);
        record.center.set(this.center);
        record.targetProjected.set(this.targetProjected);
        record.range = this.range;
        record.rangeEndpoints.set(this.rangeEndpoints);
        record.scaleFactor = this.geoProjection.getScaleFactor();
        record.rotation = this.getRotation();
        record.projectedSize.set(this.projectedSize);
        record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return BitFlags.union(oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target, oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center, Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected, oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range, VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints, oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor, oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation, Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize, oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point, out) {
        return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec, out) {
        return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        if (!(point instanceof Float64Array)) {
            point = this.project(point, MapProjection.tempVec2_2);
        }
        const x = point[0];
        const y = point[1];
        return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
        if (point1 instanceof Float64Array) {
            point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
        }
        if (point2 instanceof Float64Array) {
            point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
        }
        return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
        if (!(point1 instanceof Float64Array)) {
            point1 = this.project(point1, MapProjection.tempVec2_1);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = this.project(point2, MapProjection.tempVec2_2);
        }
        return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
        this.changeListeners.forEach(listener => listener(this, changeFlags));
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
        const index = this.changeListeners.lastIndexOf(listener);
        if (index >= 0) {
            this.changeListeners.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
}
MapProjection.SCALE_FACTOR_MAX_ITER = 20;
MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
MapProjection.tempVec2_1 = new Float64Array(2);
MapProjection.tempVec2_2 = new Float64Array(2);
MapProjection.tempVec2_3 = new Float64Array(2);
MapProjection.tempVec2_4 = new Float64Array(2);
MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);

/**
 * A base component for map layers.
 */
class MapLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
        // noop
    }
}

/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
class MapComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.layerEntries = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.updateCycleHandler = this.update.bind(this);
        this.projectedSize = 'isSubscribable' in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
        const initialSize = this.projectedSize.get();
        if (this.props.projection !== undefined) {
            this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
        }
        this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
        return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        var _a;
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.projectedSizeSub = this.projectedSize.sub(size => {
            this.mapProjection.set({ projectedSize: size });
        });
        (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub(freq => {
            var _a;
            (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.updateCycleSub = this.props.bus.getSubscriber()
                .on('realTime')
                .whenChanged()
                .atFrequency(freq)
                .handle(this.updateCycleHandler);
        }, true);
        this.attachLayers(thisNode);
    }
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
        FSComponent.visitNodes(thisNode, node => {
            if (node.instance instanceof MapLayer) {
                this.attachLayer(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onWake();
        }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onSleep();
        }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
        }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layerEntries.findIndex(entry => entry.layer === layer) >= 0) {
            return;
        }
        const entry = new LayerEntry(layer);
        this.layerEntries.push(entry);
        entry.attach();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layerEntries.findIndex(entry => entry.layer === layer);
        if (index >= 0) {
            const entry = this.layerEntries[index];
            entry.detach();
            this.layerEntries.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].update(time);
        }
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].destroy();
        }
    }
}
/**
 * An entry for a map layer.
 */
class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
        this.layer = layer;
        this.updatePeriod = 0;
        this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
        var _a, _b;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
            const clamped = Math.max(0, freq);
            this.updatePeriod = clamped === 0 ? 0 : 1000 / clamped;
        }, true);
        this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
        if (currentTime - this.lastUpdated >= this.updatePeriod) {
            this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
            this.lastUpdated = currentTime;
        }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
        var _a;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
        this.detach();
        this.layer.destroy();
    }
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
class MapModel {
    constructor() {
        this.modules = new Map();
    }
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param nameOrModule The module to get or the name of the module.
     * @returns The requested map data module.
     * @throws An error if
     */
    getModule(nameOrModule) {
        if (typeof nameOrModule === 'string') {
            return this.modules.get(nameOrModule);
        }
        else if (typeof nameOrModule === 'function') {
            return this.modules.get(nameOrModule.name);
        }
        throw new Error('Invalid type supplied: must be a string key or a module constructor.');
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
        if (this.modules.has(name)) {
            return;
        }
        this.modules.set(name, module);
    }
}

/**
 * An abstract implementation of a map text label.
 */
class AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.text = text;
        this.priority = priority;
        /**
         * The anchor point of this label, expressed relative to this label's width/height. [0, 0] is the top-left corner,
         * and [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array(2);
        /** The padding of this label's background, in pixels. Expressed as [top, right, bottom, left]. */
        this.bgPadding = new Float64Array(4);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        this.font = (_a = options === null || options === void 0 ? void 0 : options.font) !== null && _a !== void 0 ? _a : 'Roboto';
        this.fontSize = (_b = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _b !== void 0 ? _b : 10;
        this.fontColor = (_c = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _c !== void 0 ? _c : 'white';
        this.fontOutlineWidth = (_d = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _d !== void 0 ? _d : 0;
        this.fontOutlineColor = (_e = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _e !== void 0 ? _e : 'black';
        this.showBg = (_f = options === null || options === void 0 ? void 0 : options.showBg) !== null && _f !== void 0 ? _f : false;
        this.bgColor = (_g = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _g !== void 0 ? _g : 'black';
        (options === null || options === void 0 ? void 0 : options.bgPadding) && this.bgPadding.set(options.bgPadding);
        this.bgBorderRadius = (_h = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _h !== void 0 ? _h : 0;
        this.bgOutlineWidth = (_j = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _j !== void 0 ? _j : 0;
        this.bgOutlineColor = (_k = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _k !== void 0 ? _k : 'white';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        this.setTextStyle(context);
        const width = context.measureText(this.text).width;
        const height = this.fontSize;
        const bgExtraWidth = this.showBg ? this.bgPadding[1] + this.bgPadding[3] + this.bgOutlineWidth * 2 : 0;
        const bgExtraHeight = this.showBg ? this.bgPadding[0] + this.bgPadding[2] + this.bgOutlineWidth * 2 : 0;
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (this.anchor[0] - 0.5) * (width + bgExtraWidth);
        const centerY = pos[1] - (this.anchor[1] - 0.5) * (height + bgExtraHeight);
        if (this.showBg) {
            this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
        context.font = `${this.fontSize}px ${this.font}`;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
        if (this.fontOutlineWidth > 0) {
            context.lineWidth = this.fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor;
            context.strokeText(this.text, centerX, centerY);
        }
        context.fillStyle = this.fontColor;
        context.fillText(this.text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
        const backgroundLeft = centerX - width / 2 - (this.bgPadding[3] + this.bgOutlineWidth);
        const backgroundTop = centerY - height / 2 - (this.bgPadding[0] + this.bgOutlineWidth);
        const backgroundWidth = width + (this.bgPadding[1] + this.bgPadding[3] + 2 * this.bgOutlineWidth);
        const backgroundHeight = height + (this.bgPadding[0] + this.bgPadding[2] + 2 * this.bgOutlineWidth);
        let isRounded = false;
        if (this.bgBorderRadius > 0) {
            isRounded = true;
            this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, this.bgBorderRadius);
        }
        if (this.bgOutlineWidth > 0) {
            context.lineWidth = this.bgOutlineWidth * 2;
            context.strokeStyle = this.bgOutlineColor;
            if (isRounded) {
                context.stroke();
            }
            else {
                context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
            }
        }
        context.fillStyle = this.bgColor;
        if (isRounded) {
            context.fill();
        }
        else {
            context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
        const right = left + width;
        const bottom = top + height;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.lineTo(right - radius, top);
        context.arcTo(right, top, right, top + radius, radius);
        context.lineTo(right, bottom - radius);
        context.arcTo(right, bottom, right - radius, bottom, radius);
        context.lineTo(left + radius, bottom);
        context.arcTo(left, bottom, left, bottom - radius, radius);
        context.lineTo(left, top + radius);
        context.arcTo(left, top, left + radius, top, radius);
    }
}
AbstractMapTextLabel.tempVec2 = new Float64Array(2);
/**
 * A text label associated with a specific geographic location.
 */
class MapLocationTextLabel extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The render priority of this label.
     * @param location The geographic location of this label.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
        super(text, priority, options);
        this.offset = new Float64Array(2);
        this._location = location.copy();
        this.location = this._location.readonly;
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getPosition(mapProjection, out) {
        mapProjection.project(this._location, out);
        Vec2Math.add(out, this.offset, out);
        return out;
    }
}

/**
 * A cullable text label associated with a specific geographic location.
 */
class MapCullableLocationTextLabel extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label.
     * @param priority The priority of this label.
     * @param location The geographic location of this label.
     * @param alwaysShow Whether this label is immune to culling.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
        super(text, priority, location, options);
        this.alwaysShow = alwaysShow;
        this.bounds = new Float64Array(4);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateBounds(mapProjection) {
        const width = 0.6 * this.fontSize * this.text.length;
        const height = this.fontSize;
        const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
        let left = pos[0] - this.anchor[0] * width;
        let right = left + width;
        let top = pos[1] - this.anchor[1] * height;
        let bottom = top + height;
        if (this.showBg) {
            left -= (this.bgPadding[3] + this.bgOutlineWidth);
            right += (this.bgPadding[1] + this.bgOutlineWidth);
            top -= (this.bgPadding[0] + this.bgOutlineWidth);
            bottom += (this.bgPadding[2] + this.bgOutlineWidth);
        }
        this.bounds[0] = left;
        this.bounds[1] = top;
        this.bounds[2] = right;
        this.bounds[3] = bottom;
    }
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
class MapCullableTextLabelManager {
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled = true) {
        this.cullingEnabled = cullingEnabled;
        this.registered = new Set();
        this._visibleLabels = [];
        this.needUpdate = false;
        this.lastScaleFactor = 1;
        this.lastRotation = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
        return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
        if (this.registered.has(label)) {
            return;
        }
        this.registered.add(label);
        this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
        this.needUpdate = this.registered.delete(label) || this.needUpdate;
    }
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled) {
        this.cullingEnabled = enabled;
        this.needUpdate = true;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
        if (!this.needUpdate) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
            if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
                const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
                if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
                    return;
                }
            }
        }
        this._visibleLabels = [];
        if (this.cullingEnabled) {
            const labelArray = Array.from(this.registered.values());
            const len = labelArray.length;
            for (let i = 0; i < len; i++) {
                labelArray[i].updateBounds(mapProjection);
            }
            labelArray.sort((a, b) => {
                if (a.alwaysShow && !b.alwaysShow) {
                    return -1;
                }
                else if (b.alwaysShow && !a.alwaysShow) {
                    return 1;
                }
                else {
                    return b.priority - a.priority;
                }
            });
            const collisionArray = [];
            for (let i = 0; i < len; i++) {
                const label = labelArray[i];
                let show = true;
                if (!label.alwaysShow) {
                    const len2 = collisionArray.length;
                    for (let j = 0; j < len2; j++) {
                        const other = collisionArray[j];
                        if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                            show = false;
                            break;
                        }
                    }
                }
                if (show) {
                    collisionArray.push(label.bounds);
                    this._visibleLabels.push(label);
                }
            }
        }
        else {
            this._visibleLabels.push(...this.registered.values());
        }
        this.lastScaleFactor = mapProjection.getScaleFactor();
        this.lastRotation = mapProjection.getRotation();
        this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
        return a[0] < b[2]
            && a[2] > b[0]
            && a[1] < b[3]
            && a[3] > b[1];
    }
}
MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;

/**
 * A blank waypoint icon.
 */
/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
class AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, width, height, options) {
        this.waypoint = waypoint;
        this.priority = priority;
        this.width = width;
        this.height = height;
        /**
         * The anchor point of this icon, expressed relative to its width and height. [0, 0] is the top-left corner, and
         * [1, 1] is the bottom-right corner.
         */
        this.anchor = new Float64Array([0.5, 0.5]);
        /** The offset of this icon from the projected position of its associated waypoint, in pixels. */
        this.offset = new Float64Array(2);
        (options === null || options === void 0 ? void 0 : options.anchor) && this.anchor.set(options.anchor);
        (options === null || options === void 0 ? void 0 : options.offset) && this.offset.set(options.offset);
        this.totalOffsetX = this.offset[0] - this.anchor[0] * this.width;
        this.totalOffsetY = this.offset[1] - this.anchor[1] * this.height;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const projected = mapProjection.project(this.waypoint.location, MapWaypointImageIcon.tempVec2);
        const left = projected[0] + this.totalOffsetX;
        const top = projected[1] + this.totalOffsetY;
        this.drawIconAt(context, mapProjection, left, top);
    }
}
AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
class MapWaypointImageIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param width The width at which this icon should be rendered, in pixels.
     * @param height The height at which this icon should be rendered, in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, width, height, options) {
        super(waypoint, priority, width, height, options);
        this.img = img;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
        context.drawImage(this.img, left, top, this.width, this.height);
    }
}

/**
 * A renderer that draws waypoints to a map. For the renderer to draw a waypoint, the waypoint must first be registered
 * with the renderer. Waypoints may be registered under multiple render roles. Each render role is represented as a bit
 * flag. During each render cycle, a specific role is chosen for each waypoint by a selector function. Once the role is
 * chosen, the waypoint will be rendered in that role.
 */
class MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
        this.textManager = textManager;
        this.selectRoleToRender = selectRoleToRender;
        this.registered = new Map();
        this.toCleanUp = new Set();
        /**
         * This renderer's render role definitions. Waypoints assigned to be rendered under a role or combination of roles
         * with no definition will not be rendered.
         */
        this.roleDefinitions = new Map();
    }
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role) {
        return this.roleDefinitions.has(role);
    }
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role, def) {
        if (this.roleDefinitions.has(role)) {
            return false;
        }
        this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
        return true;
    }
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role) {
        return this.roleDefinitions.delete(role);
    }
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role) {
        return this.roleDefinitions.get(role);
    }
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles() {
        return this.roleDefinitions.keys();
    }
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles() {
        this.roleDefinitions.clear();
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.iconFactory = factory;
        return true;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.labelFactory = factory;
        return true;
    }
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role, context) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.canvasContext = context;
        return true;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role, handler) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.visibilityHandler = handler;
        return true;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
        if (!waypoint) {
            return false;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return false;
        }
        if (role === undefined) {
            return true;
        }
        return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        let entry = this.registered.get(waypoint.uid);
        if (!entry) {
            entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
            this.registered.set(waypoint.uid, entry);
        }
        entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return;
        }
        entry.removeRole(role, sourceId);
        if (entry.roles === 0) {
            this.deleteEntry(entry);
        }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
        this.registered.delete(entry.waypoint.uid);
        this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
        var _a;
        this.toCleanUp.forEach(entry => {
            entry.destroy();
        });
        this.toCleanUp.clear();
        const entriesToDrawIcon = [];
        this.registered.forEach(entry => {
            entry.update();
            if (entry.icon) {
                entriesToDrawIcon.push(entry);
            }
        });
        const projectedSize = mapProjection.getProjectedSize();
        for (const roleDef of this.roleDefinitions.values()) {
            const context = roleDef.canvasContext;
            if (context) {
                context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        entriesToDrawIcon.sort((a, b) => a.icon.priority - b.icon.priority);
        const len2 = entriesToDrawIcon.length;
        for (let i = 0; i < len2; i++) {
            const entry = entriesToDrawIcon[i];
            const icon = entry.icon;
            const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
            if (context) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                icon.draw(context, mapProjection);
            }
        }
    }
}
/** A null render role definition. Icons rendered under this role are never visible. */
MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
};
/**
 * The default render role selector. For each waypoint entry, iterates through all possible render roles in the order
 * they were originally added to the renderer and selects the first role under which the entry is registered and is
 * visible.
 * @param entry A waypoint entry.
 * @param roleDefinitions A map from all possible render roles to their definitions.
 * @returns The role under which the waypoint entry should be rendered, or 0 if the entry should not be rendered
 * under any role.
 */
MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
            return role;
        }
    }
    return 0;
};
/**
 * An entry for a waypoint registered with {@link MapWaypointRenderer}.
 */
class MapWaypointRendererEntry {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
        this.waypoint = waypoint;
        this.textManager = textManager;
        this.roleDefinitions = roleDefinitions;
        this.selectRoleToRender = selectRoleToRender;
        this.registrations = {};
        this._roles = 0;
        this._icon = null;
        this._label = null;
        this._lastRenderedRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
        return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole() {
        return this._lastRenderedRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
        return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
        return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            var _a;
            var _b, _c;
            ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : (_b[_c] = new Set())).add(sourceId);
        }, true);
        this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            const role = 1 << index;
            const registrations = this.registrations[role];
            if (registrations) {
                registrations.delete(sourceId);
                if (registrations.size === 0) {
                    this._roles = this._roles & ~role;
                }
            }
        }, true);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
        var _a, _b;
        if (showRole === this._lastRenderedRole) {
            return;
        }
        this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
        const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
        if (this._label && this._label !== label) {
            this.textManager.deregister(this._label);
        }
        if (label && label !== this._label) {
            this.textManager.register(label);
        }
        this._label = label;
        this._lastRenderedRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update() {
        var _a, _b;
        const showRole = this.selectRoleToRender(this, this.roleDefinitions);
        const roleDef = this.roleDefinitions.get(showRole);
        const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
        const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
        this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
        if (this._label) {
            this.textManager.deregister(this._label);
        }
    }
}

/**
 * A path stream which does nothing on any input.
 */
class NullPathStream {
    /**
     * Does nothing.
     */
    beginPath() {
        // noop
    }
    /**
     * Does nothing.
     */
    moveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    lineTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    bezierCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    quadraticCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    arc() {
        // noop
    }
    /**
     * Does nothing.
     */
    closePath() {
        // noop
    }
}
/** An instance of a {@link NullPathStream}. */
NullPathStream.INSTANCE = new NullPathStream();
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
class AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer) {
        this.consumer = consumer;
    }
    /** @inheritdoc */
    getConsumer() {
        return this.consumer;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.consumer = consumer;
    }
}

/**
 * Bitflags describing the relative location of a point with respect to a rectangular bounding box.
 */
var Outcode;
(function (Outcode) {
    Outcode[Outcode["Inside"] = 0] = "Inside";
    Outcode[Outcode["Left"] = 1] = "Left";
    Outcode[Outcode["Top"] = 2] = "Top";
    Outcode[Outcode["Right"] = 4] = "Right";
    Outcode[Outcode["Bottom"] = 8] = "Bottom";
})(Outcode || (Outcode = {}));
/**
 * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
 * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
 * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
 */
class ClippedPathStream extends AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer, bounds) {
        super(consumer);
        this.bounds = bounds;
        this.boundsHandler = this.onBoundsChanged.bind(this);
        this.boundsLines = [
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3)
        ];
        this.isBoundingRectNonZero = false;
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.prevPointOutcode = 0;
        bounds.sub(this.boundsHandler, true);
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
        if (this.prevPointOutcode === 0) {
            this.consumer.moveTo(x, y);
        }
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        const outcode = this.getOutcode(x, y);
        if ((this.prevPointOutcode | outcode) === 0) {
            // Both the previous point and current point are within bounds.
            this.consumer.lineTo(x, y);
        }
        else if ((this.prevPointOutcode & outcode) === 0) {
            // One or both of the previous point and current point are out of bounds, and the line connecting them may
            // cross through the bounding rect
            const bounds = this.bounds.get();
            const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
            let entryPoint, exitPoint;
            const outcodeOr = this.prevPointOutcode | outcode;
            if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
                // The connecting line does not cross zones diagonally -> no need to check if the intersection of the line and
                // boundary falls outside the bounds of the orthogonal axis.
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        break;
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        break;
                    }
                }
            }
            else {
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        const boundsAxisIndex = i % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            entryPoint = intersection;
                            break;
                        }
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        const boundsAxisIndex = i % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            exitPoint = intersection;
                            break;
                        }
                    }
                }
            }
            if (entryPoint) {
                this.consumer.moveTo(entryPoint[0], entryPoint[1]);
            }
            if (exitPoint) {
                this.consumer.lineTo(exitPoint[0], exitPoint[1]);
            }
            else if (outcode === Outcode.Inside) {
                this.consumer.lineTo(x, y);
            }
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = outcode;
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || startAngle === endAngle) {
            return;
        }
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Clamp to 2pi because we don't need to draw anything past a full circle.
        const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
        const bounds = this.bounds.get();
        const radiusSq = radius * radius;
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
        const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
        const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        // find all intersections of the arc circle with the clipping bounds; there can be up to 8 (two for each boundary
        // line)
        const intersections = ClippedPathStream.intersectionCache;
        let intersectionCount = 0;
        for (let i = 0; i < 4; i++) {
            const axisCoordIndex = i % 2;
            const crossAxisCoordIndex = (i + 1) % 2;
            const centerAxisCoord = i % 2 === 0 ? x : y;
            const centerCrossAxisCoord = i % 2 === 0 ? y : x;
            const deltaToBound = bounds[i] - centerAxisCoord;
            if (Math.abs(deltaToBound) < radius) {
                const crossAxisBoundMin = bounds[crossAxisCoordIndex];
                const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
                //const radialOffset = Math.acos(deltaToBound / radius);
                const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
                let intersectionRadialOffset;
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(deltaToBound / radius))) * (axisCoordIndex === 0 ? 1 : -1);
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(deltaToBound / radius))) * (axisCoordIndex === 0 ? 1 : -1);
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
            }
        }
        // Begin at the start radial, then in order (either clockwise or counterclockwise depending on the arc direction)
        // iterate through the intersection points. At each intersection, move to the point if we are currently out of
        // bounds or path an arc from the last visited radial to the point if we are inbounds. Every time we visit an
        // intersection we go from out of bounds to in bounds and vice versa. Stop when the radial to the intersection
        // is past the end radial of the arc.
        let isOutside = startPointOutcode !== Outcode.Inside;
        const startAngleNormalized = ((startAngle % pi2) + pi2) % pi2; // [0, 2 * pi)
        let lastRadial = startAngleNormalized;
        let intersectionStartIndex = -1;
        let minAngularDiff = Infinity;
        for (let i = 0; i < intersectionCount; i++) {
            const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
            if (angularDiff < minAngularDiff) {
                intersectionStartIndex = i;
                minAngularDiff = angularDiff;
            }
        }
        if (intersectionStartIndex >= 0) {
            for (let i = 0; i < intersectionCount; i++) {
                const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
                const intersection = intersections[index];
                if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
                    break;
                }
                if (isOutside) {
                    this.consumer.moveTo(intersection.point[0], intersection.point[1]);
                }
                else {
                    const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
                    this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
                }
                isOutside = !isOutside;
                lastRadial = intersection.radial;
            }
        }
        const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2; // [0, 2 * pi)
        if (!isOutside) {
            const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
            if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
                // This can happen if we clamped the angular width to 2pi -> we need to move the current point to the actual
                // end point to keep the state of the consumer stream consistent with ours.
                this.consumer.moveTo(endPoint[0], endPoint[1]);
            }
        }
        Vec2Math.copy(endPoint, this.prevPoint);
        this.prevPointOutcode = endPointOutcode;
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.prevPointOutcode = 0;
    }
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    getOutcode(x, y) {
        const bounds = this.bounds.get();
        let code = 0;
        if (x < bounds[0]) {
            code |= Outcode.Left;
        }
        else if (x > bounds[2]) {
            code |= Outcode.Right;
        }
        if (y < bounds[1]) {
            code |= Outcode.Top;
        }
        else if (y > bounds[3]) {
            code |= Outcode.Bottom;
        }
        return code;
    }
    /**
     * Handles clipping bounds change events.
     */
    onBoundsChanged() {
        const bounds = this.bounds.get();
        Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
        Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
        Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
        Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
        this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
        this.beginPath();
    }
    /**
     * Destroys this stream.
     */
    destroy() {
        this.bounds.unsub(this.boundsHandler);
    }
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    static getLineCoordinates(x1, y1, x2, y2, out) {
        const a = y1 - y2;
        const b = x2 - x1;
        const c = -(a * x1 + b * y1);
        return Vec3Math.set(a, b, c, out);
    }
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    static findLineLineIntersection(line1, line2, out) {
        const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
        const w = cross[2];
        if (w === 0) {
            return undefined;
        }
        return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
}
ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
});

/**
 * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
 * coordinates.
 */
class GeoProjectionPathStream extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.projection = projection;
        this.firstPoint = new GeoPoint(NaN, NaN);
        this.prevPoint = new GeoPoint(NaN, NaN);
        this.prevPointProjected = new Float64Array(2);
        this.resampleHandler = this.onResampled.bind(this);
        if (arg1 instanceof GeoCircleResampler) {
            this.resampler = arg1;
        }
        else {
            this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
        }
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projection;
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projection = projection;
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (isNaN(this.firstPoint.lat)) {
            this.firstPoint.set(lat, lon);
        }
        this.prevPoint.set(lat, lon);
        const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
        this.consumer.moveTo(projected[0], projected[1]);
    }
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(lon, lat);
            return;
        }
        const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
        const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
        if (!isFinite(circle.center[0])) {
            throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
        }
        this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
        this.prevPoint.set(lat, lon);
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo() {
        throw new Error('GeodesicResamplerStream: bezierCurveTo() is not supported');
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo() {
        throw new Error('GeodesicResamplerStream: quadraticCurveTo() is not supported');
    }
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            return;
        }
        if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Since we early return above if startAngle and endAngle are equal, hitting this case means they are a multiple
            // of 360 degrees apart. The resampler will interpret them as being the same point and won't draw a full circle
            // so we will split the arc into two.
            const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
            this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
            this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
            return;
        }
        const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
        const start = GeoProjectionPathStream.geoPointCache[2];
        const end = GeoProjectionPathStream.geoPointCache[3];
        if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            // The center of the arc circle is one of the poles
            const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
            start.set(circleLat, startAngle);
            end.set(circleLat, endAngle);
        }
        else {
            center.offset(startAngle, radius, start);
            center.offset(endAngle, radius, end);
        }
        if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(start.lon, start.lat);
        }
        else if (!start.equals(this.prevPoint)) {
            this.lineTo(start.lon, start.lat);
        }
        const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
        if (!counterClockwise) {
            circle.reverse();
        }
        this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
        this.prevPoint.set(end);
    }
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath() {
        if (!isNaN(this.firstPoint.lat)) {
            this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        this.firstPoint.set(NaN, NaN);
        this.prevPoint.set(NaN, NaN);
    }
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    onResampled(vector) {
        switch (vector.type) {
            case 'start':
                return;
            case 'line':
                this.consumer.lineTo(vector.projected[0], vector.projected[1]);
                break;
            case 'arc':
                this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
                break;
        }
        Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
}
GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
class AffineTransformPathStream extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.transform = new Transform2D();
        this.scale = 1;
        this.rotation = 0;
    }
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x, y, order = 'after') {
        const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
        order === 'before'
            ? Transform2D.concat(this.transform, translation, this.transform)
            : Transform2D.concat(this.transform, this.transform, translation);
        return this;
    }
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor, order = 'after') {
        const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
        order === 'before'
            ? Transform2D.concat(this.transform, scale, this.transform)
            : Transform2D.concat(this.transform, this.transform, scale);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle, order = 'after') {
        const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
        order === 'before'
            ? Transform2D.concat(this.transform, rotation, this.transform)
            : Transform2D.concat(this.transform, this.transform, rotation);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform() {
        this.transform.toIdentity();
        this.updateScaleRotation();
        return this;
    }
    /** @inheritdoc */
    beginPath() {
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.moveTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.lineTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const cp1Transformed = this.applyTransform(cp1x, cp1y);
        cp1x = cp1Transformed[0];
        cp1y = cp1Transformed[1];
        const cp2Transformed = this.applyTransform(cp2x, cp2y);
        cp2x = cp2Transformed[0];
        cp2y = cp2Transformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        const cpTransformed = this.applyTransform(cpx, cpy);
        cpx = cpTransformed[0];
        cpy = cpTransformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        const transformed = this.applyTransform(x, y);
        this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.consumer.closePath();
    }
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    updateScaleRotation() {
        const params = this.transform.getParameters();
        this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
        this.rotation = Math.atan2(params[0], params[3]);
    }
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    applyTransform(x, y) {
        const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
        return this.transform.apply(vec, vec);
    }
}
AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
AffineTransformPathStream.transformCache = [new Transform2D()];

/**
 * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
 * final transformed output is sent to a consuming stream.
 */
class TransformingPathStreamStack extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.stack = [];
    }
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream) {
        var _a;
        stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
        this.stack.push(stream);
    }
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop() {
        const removed = this.stack.pop();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        return removed;
    }
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream) {
        const displaced = this.stack[0];
        displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
        stream.setConsumer(this.consumer);
        this.stack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift() {
        var _a;
        const removed = this.stack.shift();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
        return removed;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        var _a;
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.stack[this.stack.length - 1].closePath();
    }
}

/**
 * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
 * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
 * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
 * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
 * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
 * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
 */
class GeoProjectionPathStreamStack extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.postStack = new TransformingPathStreamStack(consumer);
        if (arg1 instanceof GeoCircleResampler) {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
        }
        else {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
        }
        this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projectionStream.getProjection();
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projectionStream.setProjection(projection);
    }
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream) {
        this.preStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected() {
        return this.preStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream) {
        this.preStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected() {
        return this.preStack.shift();
    }
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream) {
        this.postStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected() {
        return this.postStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream) {
        this.postStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected() {
        return this.postStack.shift();
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.postStack.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        this.preStack.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        this.preStack.moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        this.preStack.lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.preStack.closePath();
    }
}

/**
 * Renders arcs along geo circles to a path stream stack.
 */
class GeoCirclePathRenderer {
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
        if (!continuePath) {
            streamStack.beginPath();
            streamStack.moveTo(startLon, startLat);
        }
        if (circle.isGreatCircle()) {
            const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
            const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
            if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
                const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
                const midLat = midPoint.lat;
                const midLon = midPoint.lon;
                streamStack.lineTo(midLon, midLat);
                streamStack.lineTo(endLon, endLat);
            }
            else {
                streamStack.lineTo(endLon, endLat);
            }
        }
        else {
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
            const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
            const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
            let startAngle, endAngle;
            if (isCenterPole) {
                startAngle = startLon;
                endAngle = endLon;
            }
            else {
                startAngle = turnCenter.bearingTo(startLat, startLon);
                endAngle = turnCenter.bearingTo(endLat, endLon);
            }
            streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === 'left');
        }
    }
}
GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];

/**
 * Renders arcs along geo circles as curved lines.
 */
class GeoCircleLineRenderer {
    constructor() {
        this.pathRenderer = new GeoCirclePathRenderer();
    }
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     */
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash) {
        this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
        context.lineWidth = width;
        context.strokeStyle = style;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
    }
}
GeoCircleLineRenderer.EMPTY_DASH = [];

/**
 * Renders flight plan paths one leg at a time in either forward or reverse order. Optionally forces the rendering of
 * the active flight plan leg to be last.
 */
class AbstractFlightPathPlanRenderer {
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder = 'forward', renderActiveLegLast = true) {
        this.renderOrder = renderOrder;
        this.renderActiveLegLast = renderActiveLegLast;
    }
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
        startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
        endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = plan.length - 1);
        const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
        const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : undefined;
        const isReverse = this.renderOrder === 'reverse';
        if (isReverse) {
            const oldEndIndex = endIndex;
            endIndex = startIndex;
            startIndex = oldEndIndex;
        }
        let index = startIndex;
        const delta = isReverse ? -1 : 1;
        for (const leg of plan.legs(isReverse, startIndex)) {
            if ((index - endIndex) * delta > 0) {
                break;
            }
            if (this.renderActiveLegLast && index === activeLegIndex) {
                index += delta;
                continue;
            }
            this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
            index += delta;
        }
        if (this.renderActiveLegLast && activeLeg) {
            this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
        }
    }
}

/**
 * Parts of a flight plan leg path to render.
 */
var FlightPathLegRenderPart;
(function (FlightPathLegRenderPart) {
    /** None. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["None"] = 0] = "None";
    /** The ingress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Ingress"] = 1] = "Ingress";
    /** The base path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Base"] = 2] = "Base";
    /** The egress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Egress"] = 4] = "Egress";
    /** The entire leg path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["All"] = 7] = "All";
})(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors.
 */
class AbstractFlightPathLegRenderer {
    constructor() {
        this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg, context, streamStack, partsToRender, ...args) {
        const legCalc = leg.calculated;
        if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
            return;
        }
        const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
        const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
        const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
        let mainVectors = legCalc.ingressToEgress;
        let mainVectorStartIndex = 0;
        let mainVectorEndIndex = legCalc.ingressToEgress.length;
        if (excludeIngress || excludeEgress) {
            mainVectors = legCalc.flightPath;
            mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
        }
        if (!excludeIngress) {
            for (let i = 0; i < legCalc.ingress.length; i++) {
                this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
            }
            if (excludeEgress && !excludeBase) {
                mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
                const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
                const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
                if (lastIngressVector && ingressJoinVector) {
                    const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
                    const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
                    if (!ingressEnd.equals(vectorEnd)) {
                        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                    mainVectorStartIndex++;
                }
            }
        }
        if (!excludeBase) {
            const len = Math.min(mainVectorEndIndex, mainVectors.length);
            for (let i = mainVectorStartIndex; i < len; i++) {
                this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
            }
        }
        if (!excludeEgress) {
            if (excludeIngress && !excludeBase) {
                const firstEgressVector = legCalc.egress[0];
                const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
                if (firstEgressVector && egressJoinVector) {
                    const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                    const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                    if (!egressStart.equals(egressJoinVectorStart)) {
                        const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                }
            }
            for (let i = 0; i < legCalc.egress.length; i++) {
                this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
            }
        }
    }
}
AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Renders flight plan leg paths as lines, with support for different styles for each flight path vector in the leg.
 */
class FlightPathLegLineRenderer extends AbstractFlightPathLegRenderer {
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector) {
        super();
        this.styleSelector = styleSelector;
        this.pathRenderer = new GeoCirclePathRenderer();
        this.styleBuffer = [
            {
                strokeWidth: 1,
                strokeStyle: 'white',
                strokeDash: null,
                outlineWidth: 0,
                outlineStyle: 'black',
                outlineDash: null,
                isContinuous: false
            },
            {
                strokeWidth: 1,
                strokeStyle: 'white',
                strokeDash: null,
                outlineWidth: 0,
                outlineStyle: 'black',
                outlineDash: null,
                isContinuous: false
            }
        ];
        this.activeStyleIndex = 0;
        this.isAtLegStart = false;
        this.needStrokeLineAtLegEnd = false;
    }
    /** @inheritdoc */
    render(leg, context, streamStack, partsToRender, ...args) {
        this.isAtLegStart = true;
        this.needStrokeLineAtLegEnd = false;
        super.render(leg, context, streamStack, partsToRender, ...args);
        if (this.needStrokeLineAtLegEnd) {
            this.strokeLine(context, this.styleBuffer[(this.activeStyleIndex + 1) % 2]);
            this.needStrokeLineAtLegEnd = false;
        }
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
        const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.styleBuffer[this.activeStyleIndex], ...args);
        const previousStyle = this.styleBuffer[(this.activeStyleIndex + 1) % 2];
        const didStyleChange = !this.isAtLegStart && !FlightPathLegLineRenderer.areStylesEqual(style, previousStyle);
        const continuePath = !this.isAtLegStart && style.isContinuous && !didStyleChange;
        if (didStyleChange) {
            this.strokeLine(context, previousStyle);
            this.needStrokeLineAtLegEnd = false;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathLegLineRenderer.geoCircleCache[1]);
        this.pathRenderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, streamStack, continuePath);
        this.activeStyleIndex = (this.activeStyleIndex + 1) % 2;
        this.isAtLegStart = false;
        this.needStrokeLineAtLegEnd = true;
    }
    /**
     * Applies a stroke to a canvas context.
     * @param context A canvas 2D rendering context.
     * @param style The style of the line to stroke.
     */
    strokeLine(context, style) {
        var _a, _b;
        if (style.outlineWidth > 0) {
            const outlineWidth = style.strokeWidth + 2 * style.outlineWidth;
            context.lineWidth = outlineWidth;
            context.strokeStyle = style.outlineStyle;
            context.setLineDash((_a = style.outlineDash) !== null && _a !== void 0 ? _a : FlightPathLegLineRenderer.EMPTY_DASH);
            context.stroke();
        }
        if (style.strokeWidth > 0) {
            context.lineWidth = style.strokeWidth;
            context.strokeStyle = style.strokeStyle;
            context.setLineDash((_b = style.strokeDash) !== null && _b !== void 0 ? _b : FlightPathLegLineRenderer.EMPTY_DASH);
            context.stroke();
        }
    }
    /**
     * Checks if two line styles are equal. Styles are considered equal if and only if their stroke and outline widths
     * are zero, or their stroke and outline widths, styles, and dash arrays are the same.
     * @param style1 The first style.
     * @param style2 The second style.
     * @returns Whether the two line styles are equal.
     */
    static areStylesEqual(style1, style2) {
        return (((style1.strokeWidth === 0 && style2.strokeWidth === 0)
            || (style1.strokeWidth === style2.strokeWidth
                && style1.strokeStyle === style2.strokeStyle
                && style1.strokeDash === style2.strokeDash)) && ((style1.outlineWidth === 0 && style2.outlineWidth === 0)
            || (style1.outlineWidth === style2.outlineWidth
                && style1.outlineStyle === style2.outlineStyle
                && style1.outlineDash === style2.outlineDash)));
    }
}
FlightPathLegLineRenderer.EMPTY_DASH = [];
FlightPathLegLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

[new GeoCircle(new Float64Array(3), 0)];

/**
 * Renders flight path vectors as a curved line.
 */
class FlightPathVectorLineRenderer {
    constructor() {
        this.renderer = new GeoCircleLineRenderer();
    }
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     */
    render(vector, context, streamStack, width, style, dash) {
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
        this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash);
    }
}
FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

[new GeoPoint(0, 0)];

[new GeoPoint(0, 0)];
[new Transform2D(), new Transform2D()];

/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplaneIconModule {
    constructor() {
        /** Whether to show the airplane icon. */
        this.show = Subject.create(true);
    }
}

/**
 * A module describing the state of the own airplane.
 */
class MapOwnAirplanePropsModule {
    constructor() {
        /** The airplane's position. */
        this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
        /** The airplane's true heading, in degrees. */
        this.hdgTrue = Subject.create(0);
        /** The airplane's turn rate, in degrees per second. */
        this.turnRate = Subject.create(0);
        /** The airplane's indicated altitude. */
        this.altitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
        /** The airplane's vertical speed. */
        this.verticalSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
        /** The airplane's true ground track, in degrees. */
        this.trackTrue = Subject.create(0);
        /** The airplane's ground speed. */
        this.groundSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0));
        /** Whether the airplane is on the ground. */
        this.isOnGround = Subject.create(true);
        /** The magnetic variation at the airplane's position. */
        this.magVar = Subject.create(0);
    }
}

/**
 * A module describing the state of the autopilot.
 */
class MapAutopilotPropsModule {
    constructor() {
        /** The altitude preselector setting. */
        this.selectedAltitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
        this.apSelectedAltitudeHandler = (alt) => {
            this.selectedAltitude.set(alt);
        };
    }
}

/**
 * A module describing the display of airspaces.
 */
class MapAirspaceModule {
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes) {
        this.showTypes = showTypes;
        this.show = {};
        for (const type in showTypes) {
            this.show[type] = Subject.create(false);
        }
    }
}

/// <reference types="msfstypes/JS/common" />
/**8
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
class BingComponent extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
        this.isListenerRegistered = false;
        this.imgRef = FSComponent.createRef();
        this.uid = 0;
        this._isBound = false;
        this._isAwake = true;
        this.isDestroyed = false;
        this.pos = null;
        this.radius = 0;
        this.resolution = Vec2Subject.createFromVector(new Float64Array([BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION]));
        this.earthColors = ArraySubject.create(BingComponent.createEarthColorsArray('#000000', [{ elev: 0, color: '#000000' }, { elev: 60000, color: '#000000' }]));
        this.skyColor = Subject.create(BingComponent.hexaToRGBColor('#000000'));
        this.reference = Subject.create(EBingReference.SEA);
        this.wxrMode = Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 }, (cur, prev) => cur.mode === prev.mode && cur.arcRadians === prev.arcRadians, (ref, val) => Object.assign(ref, val));
        this.resolutionPropHandler = (resolution) => {
            this.resolution.set(resolution);
        };
        this.earthColorsPropHandler = (index, type, item, array) => {
            if (array.length !== 61) {
                return;
            }
            this.earthColors.set(array);
        };
        this.skyColorPropHandler = (color) => {
            this.skyColor.set(color);
        };
        this.referencePropHandler = (reference) => {
            this.reference.set(reference);
        };
        this.wxrModePropHandler = (wxrMode) => {
            this.wxrMode.set(wxrMode);
        };
        this.resolutionHandler = (resolution) => {
            Coherent.call('SET_MAP_RESOLUTION', this.uid, resolution[0], resolution[1]);
        };
        this.earthColorsHandler = (index, type, item, array) => {
            if (type !== SubscribableArrayEventType.Cleared) {
                if (array.length !== 61) {
                    throw new Error(`Incorrect number of colors provided: was ${array.length} but should be 61`);
                }
                Coherent.call('SET_MAP_HEIGHT_COLORS', this.uid, array);
            }
        };
        this.skyColorHandler = (color) => {
            Coherent.call('SET_MAP_CLEAR_COLOR', this.uid, color);
        };
        this.referenceHandler = (reference) => {
            const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, flags);
        };
        this.wxrModeHandler = (wxrMode) => {
            Coherent.call('SHOW_MAP_WEATHER', this.uid, wxrMode.mode, wxrMode.arcRadians);
        };
        /**
         * A callback called when the listener is fully bound.
         * @param binder The binder from the listener.
         * @param uid The unique ID of the bound map.
         */
        this.onListenerBound = (binder, uid) => {
            if (this.isDestroyed) {
                return;
            }
            if (binder.friendlyName === this.props.id) {
                // console.log('Bing map listener bound.');
                this.binder = binder;
                this.uid = uid;
                if (this._isBound) {
                    return;
                }
                this._isBound = true;
                Coherent.call('SHOW_MAP', uid, true);
                if (this._isAwake) {
                    Coherent.call('SET_MAP_RESOLUTION', uid, BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION);
                    this.earthColorsSub = this.earthColors.sub(this.earthColorsHandler, true);
                    this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true);
                    this.referenceSub = this.reference.sub(this.referenceHandler, true);
                    this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true);
                    this.resolutionSub = this.resolution.sub(this.resolutionHandler, true);
                }
                this.props.onBoundCallback(this);
            }
        };
        /**
         * A callback called when the map image is updated.
         * @param uid The unique ID of the bound map.
         * @param imgSrc The img tag src attribute to assign to the bing map image.
         */
        this.onMapUpdate = (uid, imgSrc) => {
            if (this.binder !== undefined && this.uid === uid && this.imgRef.instance !== null) {
                if (this.imgRef.instance.src !== imgSrc) {
                    this.imgRef.instance.src = imgSrc;
                }
            }
        };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
        return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
        return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a, _b, _c, _d, _e;
        if (window['IsDestroying']) {
            this.destroy();
            return;
        }
        this.resolutionPropSub = (_a = this.props.resolution) === null || _a === void 0 ? void 0 : _a.sub(this.resolutionPropHandler, true);
        this.earthColorsPropSub = (_b = this.props.earthColors) === null || _b === void 0 ? void 0 : _b.sub(this.earthColorsPropHandler, true);
        this.skyColorPropSub = (_c = this.props.skyColor) === null || _c === void 0 ? void 0 : _c.sub(this.skyColorPropHandler, true);
        this.referencePropSub = (_d = this.props.reference) === null || _d === void 0 ? void 0 : _d.sub(this.referencePropHandler, true);
        this.wxrModePropSub = (_e = this.props.wxrMode) === null || _e === void 0 ? void 0 : _e.sub(this.wxrModePropHandler, true);
        const gameStateSubscribable = GameStateProvider.get();
        const gameState = gameStateSubscribable.get();
        if (gameState === GameState.briefing || gameState === GameState.ingame) {
            this.registerListener();
        }
        else {
            this.gameStateSub = gameStateSubscribable.sub(state => {
                var _a;
                if (this.isDestroyed) {
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.registerListener();
                }
            });
        }
        window.addEventListener('OnDestroy', this.destroy.bind(this));
    }
    /**
     * Registers this component's Bing map listener.
     */
    registerListener() {
        var _a;
        if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
            setTimeout(() => {
                if (this.isDestroyed) {
                    return;
                }
                this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
            }, this.props.delay);
        }
        else {
            this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
        }
    }
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    onListenerRegistered() {
        if (this.isDestroyed || this.isListenerRegistered) {
            return;
        }
        this.mapListener.on('MapBinded', this.onListenerBound);
        this.mapListener.on('MapUpdated', this.onMapUpdate);
        this.isListenerRegistered = true;
        this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, this.modeFlags);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
        var _a, _b, _c, _d, _e;
        this._isAwake = true;
        if (!this._isBound) {
            return;
        }
        Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.skyColorSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.referenceSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.wxrModeSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.resolutionSub) === null || _e === void 0 ? void 0 : _e.resume(true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
        var _a, _b, _c, _d, _e;
        this._isAwake = false;
        if (!this._isBound) {
            return;
        }
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.skyColorSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.referenceSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.wxrModeSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.resolutionSub) === null || _e === void 0 ? void 0 : _e.pause();
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
        this.pos = pos;
        this.radius = radius;
        if (this._isBound && this._isAwake) {
            Coherent.call('SET_MAP_PARAMS', this.uid, pos, radius, 1);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, src: '', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;', class: `${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.isDestroyed = true;
        this._isBound = false;
        (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.resolutionPropSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.earthColorsPropSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.skyColorPropSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.referencePropSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.wxrModePropSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.mapListener) === null || _g === void 0 ? void 0 : _g.off('MapBinded', this.onListenerBound);
        (_h = this.mapListener) === null || _h === void 0 ? void 0 : _h.off('MapUpdated', this.onMapUpdate);
        (_j = this.mapListener) === null || _j === void 0 ? void 0 : _j.trigger('JS_UNBIND_BINGMAP', this.props.id);
        this.isListenerRegistered = false;
        this.imgRef.instance.src = '';
        (_k = this.imgRef.instance.parentNode) === null || _k === void 0 ? void 0 : _k.removeChild(this.imgRef.instance);
    }
    /**
     * Converts an HTML hex color string to a numerical map RGB value.
     * @param hexColor The hex color string to convert.
     * @returns A numerical map RGB value.
     */
    static hexaToRGBColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Converts RGB color components to a numerical map RGB value.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns A numerical map RGB value.
     */
    static rgbColor(r, g, b) {
        const rgb = 256 * 256 * b + 256 * g + r;
        return rgb;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors) {
        const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
        const curve = new Avionics.Curve();
        curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
        for (let i = 0; i < terrainColors.length; i++) {
            curve.add(terrainColors[i].elev, terrainColors[i].color);
        }
        for (let i = 0; i < 60; i++) {
            const color = curve.evaluate(i * 30000 / 60);
            earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
        }
        return earthColors;
    }
}
BingComponent.DEFAULT_RESOLUTION = 1024;

/// <reference types="msfstypes/JS/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class MapBingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.wrapperRef = FSComponent.createRef();
        this.bingRef = FSComponent.createRef();
        this.resolutionSub = Vec2Subject.createFromVector(new Float64Array([1024, 1024]));
        this.size = 0;
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        if (this.props.wxrMode !== undefined) {
            this.props.wxrMode.sub(() => {
                this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
                this.needUpdate = true;
            });
        }
    }
    /** @inheritdoc */
    onWake() {
        this.bingRef.instance.wake();
    }
    /** @inheritdoc */
    onSleep() {
        this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
            const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
            const offset = this.props.mapProjection.getTargetProjectedOffset();
            offsetSize[0] += offset[0];
            offsetSize[1] += offset[1];
            this.size = this.getSize(offsetSize);
            const offsetX = ((projectedSize[0] - this.size) / 2) + offset[0];
            const offsetY = ((projectedSize[1] - this.size) / 2) + offset[1];
            this.wrapperRef.instance.style.left = `${offsetX}px`;
            this.wrapperRef.instance.style.top = `${offsetY}px`;
            this.wrapperRef.instance.style.width = `${this.size}px`;
            this.wrapperRef.instance.style.height = `${this.size}px`;
        }
        else {
            this.size = this.getSize(projectedSize);
            const offsetX = (projectedSize[0] - this.size) / 2;
            const offsetY = (projectedSize[1] - this.size) / 2;
            this.wrapperRef.instance.style.left = `${offsetX}px`;
            this.wrapperRef.instance.style.top = `${offsetY}px`;
            this.wrapperRef.instance.style.width = `${this.size}px`;
            this.wrapperRef.instance.style.height = `${this.size}px`;
        }
        this.resolutionSub.set(this.size, this.size);
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
        return Vec2Math.abs(projectedSize);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
        if (this.bingRef.instance.isBound()) {
            this.needUpdate = true;
        }
    }
    /**
     * A callback which is called when the Bing component is bound.
     */
    onBingBound() {
        this.needUpdate = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updatePositionRadius();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    setVisible(val) {
        this.wrapperRef.instance.style.display = val ? '' : 'none';
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
        const center = this.props.mapProjection.getCenter();
        const radius = this.calculateDesiredRadius(this.props.mapProjection);
        this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
        if (!this.props.wxrMode || (this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL)) {
            this.wrapperRef.instance.style.transform = `rotate(${this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG}deg)`;
        }
        else {
            this.wrapperRef.instance.style.transform = '';
        }
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
        const scaleFactor = mapProjection.getScaleFactor();
        const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
        const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
        return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.wrapperRef, style: 'position: absolute;', class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolutionSub, mode: EBingMode.PLANE, earthColors: this.props.earthColors, reference: this.props.reference, wxrMode: this.props.wxrMode, delay: this.props.delay })));
    }
}
MapBingLayer.OVERDRAW_FACTOR = Math.SQRT2;

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class MapCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
        if (!this._display) {
            throw new Error('MapCanvasLayer: attempted to access display before it was initialized');
        }
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
        if (!this._buffer) {
            throw new Error('MapCanvasLayer: attempted to access buffer before it was initialized');
        }
        return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
        return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        if (this.isInit) {
            this.updateCanvasVisibility();
        }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.initCanvasInstances();
        this.isInit = true;
        this.updateCanvasVisibility();
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this.display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }));
    }
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
class MapSyncedCanvasLayer extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
    }
}

/**
 * Implementation of MapCachedCanvasLayerReference.
 */
class MapCachedCanvasLayerReferenceClass {
    constructor() {
        this._center = new GeoPoint(0, 0);
        this._scaleFactor = 1;
        this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
        return this._center.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
        return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
        this._center.set(mapProjection.getCenter());
        this._scaleFactor = mapProjection.getScaleFactor();
        this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
        this._center.set(reference.center);
        this._scaleFactor = reference.scaleFactor;
        this._rotation = reference.rotation;
    }
}
/**
 * Implementation of MapCachedCanvasLayerTransform.
 */
class MapCachedCanvasLayerTransformClass {
    constructor() {
        this._scale = 0;
        this._rotation = 0;
        this._translation = new Float64Array(2);
        this._margin = 0;
        this._marginRemaining = 0;
    }
    /** @inheritdoc */
    get scale() {
        return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
        return this._translation;
    }
    /** @inheritdoc */
    get margin() {
        return this._margin;
    }
    /** @inheritdoc */
    get marginRemaining() {
        return this._marginRemaining;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
        this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
        this._rotation = mapProjection.getRotation() - reference.rotation;
        mapProjection.project(reference.center, this._translation);
        Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
        this._margin = referenceMargin * this._scale;
        this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
        this._scale = other.scale;
        this._rotation = other.rotation;
        this._translation.set(other.translation);
        this._margin = other.margin;
    }
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
        super(canvas, context, isDisplayed);
        this.getReferenceMargin = getReferenceMargin;
        this._reference = new MapCachedCanvasLayerReferenceClass();
        this._transform = new MapCachedCanvasLayerTransformClass();
        this._isInvalid = false;
        this._geoProjection = new MercatorProjection();
    }
    /** @inheritdoc */
    get reference() {
        return this._reference;
    }
    /** @inheritdoc */
    get transform() {
        return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
        return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
        return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection) {
        const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
        this._reference.syncWithMapProjection(mapProjection);
        this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        this._isInvalid = false;
        if (this.isDisplayed) {
            this.transformCanvasElement();
        }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
        this._reference.syncWithReference(other.reference);
        this._geoProjection.copyParametersFrom(other.geoProjection);
        this._transform.copyFrom(other.transform);
        this._isInvalid = other.isInvalid;
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection) {
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        if (!this._isInvalid) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
            this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || this._transform.marginRemaining < 0;
        }
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
        const transform = this.transform;
        const offsetX = transform.translation[0] / transform.scale;
        const offsetY = transform.translation[1] / transform.scale;
        this.canvas.style.transform = `scale(${transform.scale.toFixed(3)}) translate(${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px) rotate(${(transform.rotation * Avionics.Utils.RAD2DEG).toFixed(2)}deg)`;
    }
    /** @inheritdoc */
    invalidate() {
        this._isInvalid = true;
        this.clear();
    }
}
MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
class MapCachedCanvasLayer extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.size = 0;
        this.referenceMargin = 0;
        this.needUpdateTransforms = false;
        this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
        return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
        return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        const projectedWidth = projectedSize[0];
        const projectedHeight = projectedSize[1];
        const diag = Math.hypot(projectedWidth, projectedHeight);
        this.size = diag * this.props.overdrawFactor;
        this.referenceMargin = (this.size - diag) / 2;
        this.setWidth(this.size);
        this.setHeight(this.size);
        const posX = (projectedWidth - this.size) / 2;
        const posY = (projectedHeight - this.size) / 2;
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = `${posX}px`;
        displayCanvas.style.top = `${posY}px`;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
            this.display.invalidate();
            this.buffer.invalidate();
        }
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (!this.needUpdateTransforms) {
            return;
        }
        this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
        const mapProjection = this.props.mapProjection;
        const display = this.display;
        const buffer = this.buffer;
        display.updateTransform(mapProjection);
        buffer.updateTransform(mapProjection);
        this.needUpdateTransforms = false;
    }
}

/**
 * A layer which draws an own airplane icon.
 */
class MapOwnAirplaneLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.iconImgRef = FSComponent.createRef();
        this.iconOffset = new Float64Array(2);
        this.updateFlags = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /** @inheritdoc */
    onAttached() {
        const ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        ownAirplaneIconModule.show.sub(this.onIconShowChanged.bind(this));
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        ownAirplanePropsModule.position.sub(this.onAirplanePositionChanged.bind(this));
        ownAirplanePropsModule.hdgTrue.sub(this.onAirplaneHeadingChanged.bind(this));
        this.props.iconAnchor.sub(anchor => {
            this.iconOffset.set(anchor);
            Vec2Math.multScalar(this.iconOffset, -this.props.iconSize, this.iconOffset);
            const img = this.iconImgRef.instance;
            img.style.left = `${this.iconOffset[0]}px`;
            img.style.top = `${this.iconOffset[1]}px`;
            img.style.transformOrigin = `${anchor[0] * 100}% ${anchor[1] * 100}%`;
            this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
        }, true);
        this.props.imageFilePath.sub(path => {
            this.iconImgRef.instance.src = path;
            this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
        }, true);
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Schedules an update.
     * @param updateFlags The types of updates to schedule.
     */
    scheduleUpdate(updateFlags) {
        this.updateFlags = BitFlags.union(this.updateFlags, updateFlags);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.updateFlags === 0) {
            return;
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY)) {
            this.updateIconVisibility();
        }
        if (BitFlags.isAll(this.updateFlags, MapOwnAirplaneLayer.UPDATE_TRANSFORM)) {
            this.updateIconTransform();
        }
        this.updateFlags = BitFlags.not(this.updateFlags, MapOwnAirplaneLayer.UPDATE_VISIBILITY | MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        const show = this.isVisible() && this.props.model.getModule('ownAirplaneIcon').show.get();
        this.iconImgRef.instance.style.display = show ? 'block' : 'none';
    }
    /**
     * Updates the airplane icon's display transformation.
     */
    updateIconTransform() {
        const ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        const projected = this.props.mapProjection.project(ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.tempVec2_1);
        const rotation = ownAirplanePropsModule.hdgTrue.get() + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
        this.iconImgRef.instance.style.transform = `translate(${projected[0].toFixed(1)}px, ${projected[1].toFixed(1)}px) rotate(${rotation.toFixed(1)}deg) rotateX(0deg)`;
    }
    /**
     * A callback which is called when the show airplane icon property changes.
     * @param show The new value of the show airplane icon property.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onIconShowChanged(show) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_VISIBILITY);
    }
    /**
     * A callback which is called when the airplane's position changes.
     * @param pos The new position of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplanePositionChanged(pos) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /**
     * A callback which is called when the airplane's true heading changes.
     * @param hdgTrue - the new true heading of the airplane.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAirplaneHeadingChanged(hdgTrue) {
        this.scheduleUpdate(MapOwnAirplaneLayer.UPDATE_TRANSFORM);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.iconImgRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', src: this.props.imageFilePath, style: `position: absolute; width: ${this.props.iconSize}px; height: ${this.props.iconSize}px; transform: rotateX(0deg);` }));
    }
}
MapOwnAirplaneLayer.UPDATE_VISIBILITY = 1;
MapOwnAirplaneLayer.UPDATE_TRANSFORM = 1 << 1;
MapOwnAirplaneLayer.tempVec2_1 = new Float64Array(2);

/**
 * A layer which displays text which can be culled to avoid overlap.
 */
class MapCullableTextLayer extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.props.manager.update(this.props.mapProjection);
        this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
        const labels = this.props.manager.visibleLabels;
        const display = this.display;
        display.clear();
        for (let i = labels.length - 1; i >= 0; i--) {
            labels[i].draw(display.context, this.props.mapProjection);
        }
    }
}

/**
 * A layer which draws airspaces.
 */
class MapAirspaceLayer extends MapLayer {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
            this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
            this.isAttached && this.scheduleSearch(0, true);
        });
        this.searchedAirspaces = new Map();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
        this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
        this.activeRenderProcess = null;
        this.renderTaskQueueHandler = {
            renderTimeBudget: this.renderTimeBudget,
            // eslint-disable-next-line jsdoc/require-jsdoc
            onStarted() {
                // noop
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
                return timeElapsed < this.renderTimeBudget;
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            onPaused: this.onRenderPaused.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onFinished: this.onRenderFinished.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onAborted: this.onRenderAborted.bind(this)
        };
        this.searchDebounceTimer = 0;
        this.isSearchScheduled = false;
        this.needRefilter = false;
        this.isSearchBusy = false;
        this.lastDesiredSearchRadius = 0; // meters
        this.lastSearchRadius = 0; // meters
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
        this.isDisplayInvalidated = true;
        this.isAttached = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        this.updateClipBounds();
        this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
        this.props.maxSearchRadius.sub(radius => {
            const radiusMeters = radius.asUnit(UnitType.METER);
            if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
                this.scheduleSearch(0, false);
            }
        });
        this.props.maxSearchItemCount.sub(() => { this.scheduleSearch(0, false); });
        this.initModuleListeners();
        this.isAttached = true;
        this.searchSession && this.scheduleSearch(0, true);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
        const airspaceModule = this.props.model.getModule('airspace');
        for (const type of Object.values(airspaceModule.show)) {
            type.sub(this.onAirspaceTypeShowChanged.bind(this));
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateClipBounds();
        }
    }
    /**
     * Updates this layer's canvas clipping bounds.
     */
    updateClipBounds() {
        const size = this.canvasLayerRef.instance.getSize();
        this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    scheduleSearch(delay, refilter) {
        if (!this.searchSession) {
            return;
        }
        this.searchDebounceTimer = delay;
        this.isSearchScheduled = true;
        this.needRefilter || (this.needRefilter = refilter);
    }
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    scheduleRender() {
        this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    async searchAirspaces(refilter) {
        this.isSearchBusy = true;
        const center = this.props.mapProjection.getCenter();
        const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
        this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
        this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const session = this.searchSession;
        refilter && session.setFilter(this.getBoundaryFilter());
        const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
        for (let i = 0; i < results.added.length; i++) {
            const airspace = results.added[i];
            this.searchedAirspaces.set(airspace.facility.id, airspace);
        }
        for (let i = 0; i < results.removed.length; i++) {
            this.searchedAirspaces.delete(results.removed[i]);
        }
        this.isSearchBusy = false;
        this.scheduleRender();
    }
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    getBoundaryFilter() {
        const module = this.props.model.getModule('airspace');
        const show = module.show;
        let filter = 0;
        for (const type in show) {
            if (show[type].get()) {
                filter |= module.showTypes[type];
            }
        }
        return filter;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        this.updateFromInvalidation();
        this.updateScheduledRender();
        this.updateScheduledSearch(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
        const canvasLayer = this.canvasLayerRef.instance;
        const display = canvasLayer.display;
        const buffer = canvasLayer.buffer;
        const needBackgroundRender = !this.isBackgroundRenderScheduled
            && !this.activeRenderProcess
            && (display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD);
        const shouldScheduleSearch = needBackgroundRender
            || display.isInvalid
            || (buffer.isInvalid && this.activeRenderProcess);
        this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
        if (display.isInvalid) {
            this.isDisplayInvalidated = true;
            this.isBackgroundRenderScheduled = false;
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection);
        }
        if (buffer.isInvalid) {
            if (this.activeRenderProcess) {
                this.activeRenderProcess.abort();
                this.cleanUpRender();
            }
            buffer.clear();
            buffer.syncWithMapProjection(this.props.mapProjection);
        }
        if (shouldScheduleSearch) {
            this.scheduleSearch(this.searchDebounceDelay, false);
        }
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(elapsed) {
        if (!this.isSearchScheduled) {
            return;
        }
        this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
        if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
            this.searchAirspaces(this.needRefilter);
            this.isSearchScheduled = false;
            this.needRefilter = false;
        }
    }
    /**
     * Executes a render if one is scheduled.
     */
    updateScheduledRender() {
        if (!this.isRenderScheduled) {
            return;
        }
        this.startRenderProcess();
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    startRenderProcess() {
        const canvasLayer = this.canvasLayerRef.instance;
        if (this.activeRenderProcess) {
            this.activeRenderProcess.abort();
        }
        const buffer = canvasLayer.buffer;
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
        this.props.airspaceRenderManager.clearRegisteredAirspaces();
        for (const airspace of this.searchedAirspaces.values()) {
            if (this.isAirspaceInBounds(airspace, buffer)) {
                this.props.airspaceRenderManager.registerAirspace(airspace);
            }
        }
        const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
        this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
        this.activeRenderProcess.start();
    }
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    isAirspaceInBounds(airspace, canvas) {
        const corner = MapAirspaceLayer.geoPointCache[0];
        const cornerProjected = MapAirspaceLayer.vec2Cache[0];
        let minX, maxX, minY, maxY;
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = maxX = cornerProjected[0];
        minY = maxY = cornerProjected[1];
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        const width = canvas.canvas.width;
        const height = canvas.canvas.height;
        return minX < width
            && maxX > 0
            && minY < height
            && maxY > 0;
    }
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    selectLod(resolution) {
        const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
        let i = thresholds.length - 1;
        while (i >= 0) {
            if (resolution * 2 >= thresholds[i]) {
                break;
            }
            i--;
        }
        return i;
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
        this.canvasLayerRef.instance.buffer.reset();
        this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
        const display = this.canvasLayerRef.instance.display;
        const buffer = this.canvasLayerRef.instance.buffer;
        display.clear();
        display.syncWithCanvasInstance(buffer);
        this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
        if (this.isDisplayInvalidated) {
            this.renderAirspacesToDisplay();
        }
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
        this.renderAirspacesToDisplay();
        this.cleanUpRender();
        this.isDisplayInvalidated = false;
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
        this.cleanUpRender();
    }
    /**
     * This method is called when an airspace show property changes.
     */
    onAirspaceTypeShowChanged() {
        this.scheduleSearch(0, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }));
    }
}
MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2; // milliseconds per frame
MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1; // relative to total margin
MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10; // number of pixels from edge of canvas to extend the clipping bounds, in pixels
MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
MapAirspaceLayer.vec2Cache = [new Float64Array(2)];

/**
 * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
 * search radius.
 */
class MapNearestWaypointsLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
        this.searchRadius = 0;
        this.searchMargin = 0;
        this.icaosToShow = new Set();
        this.isInit = false;
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
        Promise.all([
            this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection)
        ]).then((value) => {
            const [airportSession, vorSession, ndbSession, intSession] = value;
            const callback = this.processSearchResults.bind(this);
            this.facilitySearches = {
                [FacilitySearchType.Airport]: new MapAbstractNearestWaypointsLayerSearch(airportSession, callback),
                [FacilitySearchType.Vor]: new MapAbstractNearestWaypointsLayerSearch(vorSession, callback),
                [FacilitySearchType.Ndb]: new MapAbstractNearestWaypointsLayerSearch(ndbSession, callback),
                [FacilitySearchType.Intersection]: new MapAbstractNearestWaypointsLayerSearch(intSession, callback)
            };
            if (this.isInit) {
                this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
            }
        });
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.doInit();
        this.isInit = true;
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    /**
     * Initializes this layer.
     */
    doInit() {
        this.initWaypointRenderer();
        this.updateSearchRadius();
    }
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    getSearchCenter() {
        return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    /**
     * Initializes this layer's waypoint renderer.
     */
    initWaypointRenderer() {
        this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
            this.updateSearchRadius();
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
        else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
        const mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
        this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
        this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
        if (!this.facilitySearches) {
            return;
        }
        this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
        this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
        this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
        this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     */
    tryRefreshAllSearches(center, radius) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshAllSearches(center, radius);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     */
    tryRefreshSearch(type, center, radius) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshSearch(type, center, radius);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    _tryRefreshAllSearches(center, radius) {
        this._tryRefreshSearch(FacilitySearchType.Airport, center, radius);
        this._tryRefreshSearch(FacilitySearchType.Vor, center, radius);
        this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius);
        this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    _tryRefreshSearch(type, center, radius) {
        const search = this.facilitySearches && this.facilitySearches[type];
        if (!search || !this.shouldRefreshSearch(type, center, radius)) {
            return;
        }
        if (search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            this.scheduleSearchRefresh(type, search, center, radius);
        }
    }
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    shouldRefreshSearch(type, center, radius) {
        return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    scheduleSearchRefresh(type, search, center, radius) {
        const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
        const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : undefined;
        if (radiusLimit !== undefined && isFinite(radiusLimit)) {
            radius = Math.min(radius, Math.max(0, radiusLimit));
        }
        search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
        if (!results) {
            return;
        }
        const numAdded = results.added.length;
        for (let i = 0; i < numAdded; i++) {
            const icao = results.added[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.registerIcao(icao);
        }
        const numRemoved = results.removed.length;
        for (let i = 0; i < numRemoved; i++) {
            const icao = results.removed[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.deregisterIcao(icao);
        }
    }
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    registerIcao(icao) {
        this.icaosToShow.add(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (!this.icaosToShow.has(icao)) {
                return;
            }
            this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
        });
    }
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    registerWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.props.registerWaypoint(waypoint, renderer);
    }
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    deregisterIcao(icao) {
        this.icaosToShow.delete(icao);
        this.facLoader.getFacility(ICAO.getFacilityType(icao), icao).then(facility => {
            if (this.icaosToShow.has(icao)) {
                return;
            }
            this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
        });
    }
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    deregisterWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.props.deregisterWaypoint(waypoint, renderer);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
/**
 * A nearest facility search for MapAbstractNearestWaypointsLayer.
 */
class MapAbstractNearestWaypointsLayerSearch {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, refreshCallback) {
        this.session = session;
        this.refreshCallback = refreshCallback;
        this._lastCenter = new GeoPoint(0, 0);
        this._lastRadius = 0;
        this.maxItemCount = 0;
        this.refreshDebounceTimer = 0;
        this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
        return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
        return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, maxItemCount, delay) {
        this._lastCenter.set(center);
        this._lastRadius = radius;
        this.maxItemCount = maxItemCount;
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
        if (!this.isRefreshScheduled) {
            return;
        }
        this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
        if (this.refreshDebounceTimer === 0) {
            this.refresh();
            this.isRefreshScheduled = false;
        }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    async refresh() {
        const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
        this.refreshCallback(results);
    }
}

/**
 * A map layer that draws a line between two points. The line is drawn in projected coordinate space, so it will always
 * be straight on the projected map.
 */
class MapLineLayer extends MapSyncedCanvasLayer {
    constructor() {
        var _a, _b, _c, _d, _e, _f;
        super(...arguments);
        this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapLineLayer.DEFAULT_STROKE_WIDTH;
        this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapLineLayer.DEFAULT_STROKE_STYLE;
        this.strokeDash = (_c = this.props.strokeDash) !== null && _c !== void 0 ? _c : MapLineLayer.DEFAULT_STROKE_DASH;
        this.outlineWidth = (_d = this.props.outlineWidth) !== null && _d !== void 0 ? _d : MapLineLayer.DEFAULT_OUTLINE_WIDTH;
        this.outlineStyle = (_e = this.props.outlineStyle) !== null && _e !== void 0 ? _e : MapLineLayer.DEFAULT_OUTLINE_STYLE;
        this.outlineDash = (_f = this.props.outlineDash) !== null && _f !== void 0 ? _f : MapLineLayer.DEFAULT_OUTLINE_DASH;
        this.vec = new Float64Array([0, 0]);
        this.isUpdateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.props.start.sub(() => { this.scheduleUpdate(); });
        this.props.end.sub(() => { this.scheduleUpdate(); });
        this.scheduleUpdate();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.scheduleUpdate();
    }
    /**
     * Schedules the layer for a draw update.
     */
    scheduleUpdate() {
        this.isUpdateScheduled = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (this.isUpdateScheduled) {
            this.display.clear();
            const start = this.props.start.get();
            const end = this.props.end.get();
            if (start !== null && end !== null) {
                const [x1, y1] = start instanceof Float64Array ? start : this.props.mapProjection.project(start, this.vec);
                const [x2, y2] = end instanceof Float64Array ? end : this.props.mapProjection.project(end, this.vec);
                this.drawLine(x1, y1, x2, y2);
            }
            this.isUpdateScheduled = false;
        }
    }
    /**
     * Draws this layer's line.
     * @param x1 The x coordinate of the start of the line.
     * @param y1 The y coordinate of the start of the line.
     * @param x2 The x coordinate of the end of the line.
     * @param y2 The y coordinate of the end of the line.
     */
    drawLine(x1, y1, x2, y2) {
        const context = this.display.context;
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        if (this.outlineWidth > 0) {
            this.stroke(context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
        }
        if (this.strokeWidth > 0) {
            this.stroke(context, this.strokeWidth, this.strokeStyle, this.strokeDash);
        }
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param width The width of the stroke, in pixels.
     * @param style The style of the stroke.
     * @param dash The dash array of the stroke.
     */
    stroke(context, width, style, dash) {
        context.lineWidth = width;
        context.strokeStyle = style;
        context.setLineDash(dash);
        context.stroke();
    }
}
MapLineLayer.DEFAULT_STROKE_WIDTH = 2; // px
MapLineLayer.DEFAULT_STROKE_STYLE = 'white';
MapLineLayer.DEFAULT_STROKE_DASH = [];
MapLineLayer.DEFAULT_OUTLINE_WIDTH = 0; // px
MapLineLayer.DEFAULT_OUTLINE_STYLE = 'black';
MapLineLayer.DEFAULT_OUTLINE_DASH = [];

/**
 * A map controller.
 */
class MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context) {
        this._isAlive = true;
        this.context = context;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this controller is alive. */
    get isAlive() {
        return this._isAlive;
    }
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterMapRender(ref) {
        // noop
    }
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDeadZoneChanged(deadZone) {
        // noop
    }
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onBeforeUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed() {
        // noop
    }
    /**
     * Destroys this controller.
     */
    destroy() {
        this._isAlive = false;
    }
}

/**
 * A controller which maintains an arbitrary number of bindings.
 */
class MapBindingsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     */
    constructor(context, bindings) {
        super(context);
        this.bindings = bindings;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const bindings = Array.from(this.bindings);
        if (bindings.length === 0) {
            this.destroy();
        }
        this.pipes = bindings.map(binding => {
            if ('map' in binding) {
                return binding.source.pipe(binding.target, binding.map);
            }
            else {
                return binding.source.pipe(binding.target);
            }
        });
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    onWake() {
        var _a;
        (_a = this.pipes) === null || _a === void 0 ? void 0 : _a.forEach(pipe => { pipe.resume(true); });
    }
    /** @inheritdoc */
    onSleep() {
        var _a;
        (_a = this.pipes) === null || _a === void 0 ? void 0 : _a.forEach(pipe => { pipe.pause(); });
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.pipes) === null || _a === void 0 ? void 0 : _a.forEach(pipe => { pipe.destroy(); });
    }
}

/**
 * Updates a map at regular intervals based on event bus clock events.
 */
class MapClockUpdateController extends MapSystemController {
    /** @inheritdoc */
    onAfterMapRender(ref) {
        this.freqSub = this.context.updateFreq.sub(freq => {
            var _a;
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.clockSub = this.context.bus.getSubscriber().on('realTime').atFrequency(freq).handle(realTime => {
                ref.update(realTime);
            });
        }, true);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/**
 * A collection of common keys used by the MapSystem API.
 */
class MapSystemKeys {
}
MapSystemKeys.TargetControl = 'targetControlModerator';
MapSystemKeys.RotationControl = 'rotationControlModerator';
MapSystemKeys.RangeControl = 'rangeControlModerator';
MapSystemKeys.ClockUpdate = 'clockUpdate';
MapSystemKeys.OwnAirplaneProps = 'ownAirplaneProps';
MapSystemKeys.AutopilotProps = 'autopilotProps';
MapSystemKeys.TerrainColors = 'terrainColors';
MapSystemKeys.Weather = 'weather';
MapSystemKeys.FollowAirplane = 'followAirplane';
MapSystemKeys.Rotation = 'rotation';
MapSystemKeys.OwnAirplaneIcon = 'ownAirplaneIcon';
MapSystemKeys.TextLayer = 'text';
MapSystemKeys.TextManager = 'textManager';
MapSystemKeys.Bing = 'bing';
MapSystemKeys.WaypointRenderer = 'waypointRenderer';
MapSystemKeys.IconFactory = 'iconFactory';
MapSystemKeys.LabelFactory = 'labelFactory';
MapSystemKeys.NearestWaypoints = 'nearestWaypoints';
MapSystemKeys.FlightPlan = 'flightPlan';
MapSystemKeys.FlightPlanner = 'flightPlanner';
MapSystemKeys.FlightPathRenderer = 'flightPathRenderer';
MapSystemKeys.Airspace = 'airspace';
MapSystemKeys.AirspaceManager = 'airspaceRenderManager';
MapSystemKeys.Traffic = 'traffic';
MapSystemKeys.DataIntegrity = 'dataIntegrity';

/**
 * Controls the map system's flight plan module.
 */
class MapFlightPlanController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.planCopiedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
        };
        this.planCreatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
        };
        this.planDeletedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(undefined);
        };
        this.planChangeHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
        };
        this.planCalculatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
        };
        this.activeLegChangedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.legIndex);
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.fplCopiedSub = sub.on('fplCopied').handle(this.planCopiedHandler);
        this.fplCreatedSub = sub.on('fplCreated').handle(this.planCreatedHandler);
        this.fplDeletedSub = sub.on('fplDeleted').handle(this.planDeletedHandler);
        this.fplDirectToDataChangedSub = sub.on('fplDirectToDataChanged').handle(this.planChangeHandler);
        this.fplLoadedSub = sub.on('fplLoaded').handle(this.planCreatedHandler);
        this.fplOriginDestChangedSub = sub.on('fplOriginDestChanged').handle(this.planChangeHandler);
        this.fplProcDetailsChangedSub = sub.on('fplProcDetailsChanged').handle(this.planChangeHandler);
        this.fplSegmentChangeSub = sub.on('fplSegmentChange').handle(this.planChangeHandler);
        this.fplUserDataDeleteSub = sub.on('fplUserDataDelete').handle(this.planChangeHandler);
        this.fplUserDataSetSub = sub.on('fplUserDataSet').handle(this.planChangeHandler);
        this.fplActiveLegChangeSub = sub.on('fplActiveLegChange').handle(this.activeLegChangedHandler);
        this.fplCalculatedSub = sub.on('fplCalculated').handle(this.planCalculatedHandler);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super.destroy();
        (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
        (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
        (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
}

/**
 * Controls the target position of a map to follow the player airplane.
 */
class MapFollowAirplaneController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
        this.mapProjectionParams = {
            target: new GeoPoint(0, 0)
        };
        this.targetControl = this.context[MapSystemKeys.TargetControl];
        this.targetControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.isFollowingAirplane.set(true);
            },
            onCeded: () => {
                this.isFollowingAirplane.set(false);
            }
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.targetControl.claim(this.targetControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.isFollowingAirplane.get()) {
            this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
            this.context.projection.setQueued(this.mapProjectionParams);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.targetControl.forfeit(this.targetControlConsumer);
    }
}

/**
 * Updates the properties in a {@link MapOwnAirplanePropsModule}.
 */
class MapOwnAirplanePropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.updateFreqSub = this.updateFreq.sub(freq => {
            var _a;
            for (const property of this.properties) {
                (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                this.subs[property] = this.bindProperty(sub, property, freq);
            }
        }, true);
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'position':
                return sub.on('gps-position').atFrequency(updateFreq).handle(lla => { this.module.position.set(lla.lat, lla.long); });
            case 'altitude':
                return sub.on('alt').atFrequency(updateFreq).handle(alt => { this.module.altitude.set(alt, UnitType.FOOT); });
            case 'groundSpeed':
                return sub.on('ground_speed').atFrequency(updateFreq).handle(gs => { this.module.groundSpeed.set(gs, UnitType.KNOT); });
            case 'hdgTrue':
                return sub.on('hdg_deg_true').atFrequency(updateFreq).handle(hdg => { this.module.hdgTrue.set(hdg); });
            case 'trackTrue':
                return sub.on('track_deg_true').atFrequency(updateFreq).handle(track => { this.module.trackTrue.set(track); });
            case 'verticalSpeed':
                return sub.on('vs').atFrequency(updateFreq).handle(vs => { this.module.verticalSpeed.set(vs, UnitType.FPM); });
            case 'turnRate':
                return sub.on('delta_heading_rate').atFrequency(updateFreq).handle(turnRate => { this.module.turnRate.set(turnRate); });
            case 'isOnGround':
                return sub.on('on_ground').atFrequency(updateFreq).handle(isOnGround => { this.module.isOnGround.set(isOnGround); });
            case 'magVar':
                return sub.on('magvar').atFrequency(updateFreq).handle(magVar => { this.module.magVar.set(magVar); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/**
 * An enumeration of possible map rotation types.
 */
var MapRotation;
(function (MapRotation) {
    /** Map rotation points towards north up. */
    MapRotation["NorthUp"] = "NorthUp";
    /** Map up position points towards the current airplane track. */
    MapRotation["TrackUp"] = "TrackUp";
    /** Map up position points towards the current airplane heading. */
    MapRotation["HeadingUp"] = "HeadingUp";
    /** Map up position points towards the current nav desired track. */
    MapRotation["DtkUp"] = "DtkUp";
})(MapRotation || (MapRotation = {}));
/**
 * A module describing the rotation behavior of the map.
 */
class MapRotationModule {
    constructor() {
        /** The type of map rotation to use. */
        this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
}

/// <reference types="msfstypes/JS/Avionics" />
/**
 * Controls the rotation of a map based on the behavior defined in {@link MapRotationModule}.
 */
class MapRotationController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.rotationParam = {
            rotation: 0
        };
        this.hasRotationControl = false;
        this.rotationControl = this.context[MapSystemKeys.RotationControl];
        this.rotationControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.hasRotationControl = true;
            },
            onCeded: () => {
                this.hasRotationControl = false;
            }
        };
        this.rotationFuncs = {
            [MapRotation.NorthUp]: () => 0,
            [MapRotation.HeadingUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.TrackUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.DtkUp]: () => 0 // TODO
        };
        this.rotationFunc = this.rotationFuncs[MapRotation.HeadingUp];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.rotationSub = this.rotationModule.rotationType.sub(type => {
            this.rotationFunc = this.rotationFuncs[type];
        }, true);
        this.rotationControl.claim(this.rotationControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.hasRotationControl) {
            this.rotationParam.rotation = this.rotationFunc();
            this.context.projection.setQueued(this.rotationParam);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        super.onMapDestroyed();
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.rotationControl.forfeit(this.rotationControlConsumer);
    }
}

/**
 * Waypoint roles used by the map system waypoint display system.
 */
var MapSystemWaypointRoles;
(function (MapSystemWaypointRoles) {
    /** The normal waypoint display role. */
    MapSystemWaypointRoles["Normal"] = "Normal";
    /** The waypoint role for displaying waypoints along the flight plan. */
    MapSystemWaypointRoles["FlightPlan"] = "FlightPlan";
})(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));

/**
 * A map system layer that draws the flight plan.
 */
class MapSystemFlightPlanLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.flightPathLayerRef = FSComponent.createRef();
        this.waypointLayerRef = FSComponent.createRef();
        this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
        this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
        this.legWaypoints = new Map();
        this.waypointsUpdating = false;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
        this.facWaypointCache = DefaultFacilityWaypointCache.getCache();
        this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
        this.updateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.flightPathLayerRef.instance.onAttached();
        this.waypointLayerRef.instance.onAttached();
        this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
        this.initWaypointRenderer();
        this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
        this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
        super.onAttached();
    }
    /**
     * Initializes the waypoint renderer for this layer.
     */
    initWaypointRenderer() {
        let hasDefaultRole = false;
        const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
        for (let i = 0; i < flightPlanRoles.length; i++) {
            const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
            if (roleId !== undefined) {
                this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
                this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
                this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
                if (!hasDefaultRole) {
                    this.props.flightPathRenderer.defaultRoleId = roleId;
                    hasDefaultRole = true;
                }
            }
        }
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.flightPathLayerRef.instance.onUpdated(time, elapsed);
        this.waypointLayerRef.instance.onUpdated(time, elapsed);
        if (this.isVisible()) {
            const display = this.flightPathLayerRef.instance.display;
            if (display.isInvalid) {
                display.clear();
                display.syncWithMapProjection(this.props.mapProjection);
                this.updateScheduled = true;
            }
            if (this.updateScheduled) {
                if (!this.waypointsUpdating) {
                    this.updateWaypoints();
                }
                const context = display.context;
                display.clear();
                const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
                if (plan !== undefined) {
                    this.pathStreamStack.setProjection(display.geoProjection);
                    this.props.flightPathRenderer.render(plan, undefined, undefined, context, this.pathStreamStack);
                }
            }
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointLayerRef.instance.setVisible(val);
        this.flightPathLayerRef.instance.setVisible(val);
    }
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    async updateWaypoints() {
        if (this.waypointsUpdating) {
            throw new Error('A flight plan waypoint update is already in progress.');
        }
        this.waypointsUpdating = true;
        const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
        const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
        if (flightPlan === undefined) {
            for (const legWaypoint of this.legWaypoints.values()) {
                const [waypoint, roleId] = legWaypoint;
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
            this.legWaypoints.clear();
            this.waypointsUpdating = false;
            return;
        }
        const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
        const legsToDisplay = new Map();
        let legIndex = 0;
        for (const leg of flightPlan.legs()) {
            let roleId = this.defaultRoleId;
            const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
            if (handler !== undefined) {
                roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
            }
            if (roleId !== 0) {
                legsToDisplay.set(leg, roleId);
            }
            legIndex++;
        }
        // Remove records of legs that are no longer in the set of legs to display.
        for (const leg of this.legWaypoints) {
            const [legDefinition, legWaypoint] = leg;
            const [waypoint, roleId] = legWaypoint;
            if (!legsToDisplay.has(legDefinition)) {
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.delete(legDefinition);
            }
        }
        const waypointRefreshes = [];
        // Create or refresh waypoints to display
        for (const leg of legsToDisplay) {
            waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
        }
        await Promise.all(waypointRefreshes);
        this.waypointsUpdating = false;
    }
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildPlanWaypoint(leg, roleId) {
        switch (leg.leg.type) {
            case LegType.CD:
            case LegType.VD:
            case LegType.CR:
            case LegType.VR:
            case LegType.FC:
            case LegType.FD:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.CI:
            case LegType.VI:
                await this.buildTerminatorWaypoint(leg, roleId);
                break;
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                break;
            default:
                await this.buildFixWaypoint(leg, roleId);
                break;
        }
    }
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildTerminatorWaypoint(leg, roleId) {
        var _a, _b, _c, _d, _e, _f;
        const currentLeg = this.legWaypoints.get(leg);
        if (currentLeg !== undefined) {
            const [waypoint, currentRoleId] = currentLeg;
            const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
            if (lastVector !== undefined) {
                if (!waypoint.location.equals(lastVector.endLat, lastVector.endLon)) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, (_c = leg.name) !== null && _c !== void 0 ? _c : '');
                    this.legWaypoints.set(leg, [newWaypoint, roleId]);
                    this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                }
                else if (currentRoleId !== roleId) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                    this.legWaypoints.set(leg, [waypoint, roleId]);
                }
            }
            else {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
        else {
            const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
            if (lastVector !== undefined) {
                const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, (_f = leg.name) !== null && _f !== void 0 ? _f : '');
                this.legWaypoints.set(leg, [newWaypoint, roleId]);
                this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
    }
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildFixWaypoint(leg, roleId) {
        const legWaypoint = this.legWaypoints.get(leg);
        if (legWaypoint === undefined) {
            const facIcao = leg.leg.fixIcao;
            let facility;
            try {
                facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
            }
            catch (err) {
                /* continue */
            }
            if (facility !== undefined) {
                const waypoint = this.facWaypointCache.get(facility);
                this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [waypoint, roleId]);
            }
        }
        else {
            const [waypoint, currentRoleId] = legWaypoint;
            if (currentRoleId !== roleId) {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [waypoint, roleId]);
            }
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }),
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection })));
    }
}

/**
 * TCAS operating modes.
 */
var TCASOperatingMode;
(function (TCASOperatingMode) {
    TCASOperatingMode[TCASOperatingMode["Standby"] = 0] = "Standby";
    TCASOperatingMode[TCASOperatingMode["TAOnly"] = 1] = "TAOnly";
    TCASOperatingMode[TCASOperatingMode["TA_RA"] = 2] = "TA_RA";
})(TCASOperatingMode || (TCASOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TCASAlertLevel;
(function (TCASAlertLevel) {
    TCASAlertLevel[TCASAlertLevel["None"] = 0] = "None";
    TCASAlertLevel[TCASAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TCASAlertLevel[TCASAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TCASAlertLevel[TCASAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TCASAlertLevel || (TCASAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TCASResolutionAdvisoryFlags;
(function (TCASResolutionAdvisoryFlags) {
    /** An initial resolution advisory. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Initial"] = 1] = "Initial";
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Corrective"] = 2] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["UpSense"] = 4] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["DownSense"] = 8] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Crossing"] = 16] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Climb"] = 32] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Descend"] = 64] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["Increase"] = 128] = "Increase";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TCASResolutionAdvisoryFlags[TCASResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TCASResolutionAdvisoryFlags || (TCASResolutionAdvisoryFlags = {}));
({
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
});
UnitType.KNOT.createNumber(30);
UnitType.FPM.convertTo(1500, UnitType.MPS);
UnitType.FPM.convertTo(2500, UnitType.MPS);
UnitType.FPM.convertTo(2000, UnitType.MPS);
UnitType.FPM.convertTo(500, UnitType.MPS);

/**
 * Traffic alert level modes.
 */
var MapTrafficAlertLevelVisibility;
(function (MapTrafficAlertLevelVisibility) {
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["All"] = 15] = "All";
})(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
/**
 * A module describing the display of traffic.
 */
class MapTrafficModule {
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
        this.tcas = tcas;
        /** Whether to show traffic information. */
        this.show = Subject.create(true);
        /** The TCAS operating mode. */
        this.operatingMode = Subject.create(TCASOperatingMode.Standby);
        /**
         * The distance from the own airplane beyond which intruders are considered off-scale. If the value is `NaN`,
         * intruders are never considered off-scale.
         */
        this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        /** Alert level visibility flags. */
        this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
        /** The difference in altitude above the own airplane above which intruders will not be displayed. */
        this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** The difference in altitude below the own airplane below which intruders will not be displayed. */
        this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** Whether displayed intruder altitude is relative. */
        this.isAltitudeRelative = Subject.create(true);
        this.tcas.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
            this.operatingMode.set(mode);
        });
    }
}

/**
 * A map layer which displays traffic intruders.
 */
class MapSystemTrafficLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.iconLayerRef = FSComponent.createRef();
        this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
        this.intruderIcons = {
            [TCASAlertLevel.None]: new Map(),
            [TCASAlertLevel.ProximityAdvisory]: new Map(),
            [TCASAlertLevel.TrafficAdvisory]: new Map(),
            [TCASAlertLevel.ResolutionAdvisory]: new Map()
        };
        this.needHandleOffscaleOob = this.props.offScaleIntruders !== undefined || this.props.oobIntruders !== undefined;
        this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
        this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
        this.isInit = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (!isVisible) {
            if (this.isInit) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.iconLayerRef.instance.display.clear();
            }
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.iconLayerRef.instance.onAttached();
        this.oobOffset.sub(this.updateOobBounds.bind(this), true);
        this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
        this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initCanvasStyles();
        this.initIntruders();
        this.initTCASHandlers();
        this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
        this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
        const intruders = this.trafficModule.tcas.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
        const tcasSub = this.props.context.bus.getSubscriber();
        tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));
        tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.initCanvasStyles();
            this.updateOobBounds();
        }
    }
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    updateOobBounds() {
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const oobOffset = this.oobOffset.get();
        this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
        const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
        const offScaleRange = this.trafficModule.offScaleRange.get();
        const oobBounds = this.oobBounds.get();
        const iconDisplay = this.iconLayerRef.instance.display;
        iconDisplay.clear();
        for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
            const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
            if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b, _c, _d, _e, _f;
                    icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
                    if (this.needHandleOffscaleOob) {
                        if (icon.isOffScale) {
                            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.add(icon.intruder);
                            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
                        }
                        else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                            (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                            (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
                        }
                        else {
                            (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                            (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
                        }
                    }
                });
            }
            else if (this.needHandleOffscaleOob) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b;
                    (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                    (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
                });
            }
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        this.setVisible(this.trafficModule.tcas.getOperatingMode() !== TCASOperatingMode.Standby && this.trafficModule.show.get());
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
        const icon = this.props.iconFactory(intruder, this.props.context);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
        var _a, _b;
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderIcons[oldAlertLevel = TCASAlertLevel.None].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TCASAlertLevel.ProximityAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TCASAlertLevel.TrafficAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TCASAlertLevel.ResolutionAdvisory].get(intruder));
        if (view) {
            this.intruderIcons[oldAlertLevel].delete(intruder);
            this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TCASAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TCASAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TCASAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TCASAlertLevel.ResolutionAdvisory },
];
[new GeoPoint(0, 0)];

/**
 * A class that renders waypoints into a layer.
 */
class MapSystemWaypointsLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.waypointsLayer = FSComponent.createRef();
        this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
        this.waypointCache = DefaultFacilityWaypointCache.getCache();
        this.searchItemLimits = {
            [FacilitySearchType.Airport]: 500,
            [FacilitySearchType.Vor]: 250,
            [FacilitySearchType.Ndb]: 250,
            [FacilitySearchType.Intersection]: 500
        };
        this.searchRadiusLimits = {
            [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY
        };
        this.renderRole = 1;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.waypointsLayer.instance.onAttached();
        this.initEventHandlers();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (this.isVisible()) {
            this.waypointsLayer.instance.onUpdated(time, elapsed);
        }
    }
    /** @inheritdoc */
    initEventHandlers() {
        this.displayModule.numAirports.sub(num => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
        this.displayModule.numIntersections.sub(num => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
        this.displayModule.numVors.sub(num => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
        this.displayModule.numNdbs.sub(num => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
        this.displayModule.airportsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.intersectionsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.vorsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.ndbsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
    }
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    initWaypointRenderer(renderer, canvasLayer) {
        this.defineRenderRole(renderer, canvasLayer);
        renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    defineRenderRole(renderer, canvasLayer) {
        let hasDefaultId = false;
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach(id => {
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.setCanvasContext(roleId, canvasLayer.display.context);
                renderer.setIconFactory(roleId, this.props.iconFactory);
                renderer.setLabelFactory(roleId, this.props.labelFactory);
                renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
                if (!hasDefaultId) {
                    this.renderRole = roleId;
                    hasDefaultId = true;
                }
            }
        });
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointsLayer.instance.setVisible(val);
    }
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    isWaypointVisible(waypoint) {
        if (waypoint instanceof FacilityWaypoint) {
            switch (waypoint.type) {
                case WaypointTypes.Airport:
                    return this.displayModule.showAirports.get()(waypoint);
                case WaypointTypes.Intersection:
                    return this.displayModule.showIntersections.get()(waypoint);
                case WaypointTypes.VOR:
                    return this.displayModule.showVors.get()(waypoint);
                case WaypointTypes.NDB:
                    return this.displayModule.showNdbs.get()(waypoint);
            }
        }
        return false;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: (waypoint, renderer) => { renderer.register(waypoint, this.renderRole, 'waypoints-layer'); }, deregisterWaypoint: (waypoint, renderer) => { renderer.deregister(waypoint, this.renderRole, 'waypoints-layer'); }, searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : undefined }));
    }
}

/**
 * A map data module that controls the terrain color reference point.
 */
class MapTerrainColorsModule {
    constructor() {
        /** The terrain colors reference point. */
        this.reference = Subject.create(EBingReference.SEA);
        /** The terrain colors array. */
        this.colors = ArraySubject.create(BingComponent.createEarthColorsArray('#0000FF', [
            {
                elev: 0,
                color: '#000000'
            },
            {
                elev: 60000,
                color: '#000000'
            }
        ]));
    }
}

/**
 * A map data module that handles the display of flight plan data.
 */
class MapFlightPlanModule {
    constructor() {
        this.plans = [];
    }
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index) {
        let planSubject = this.plans[index];
        if (planSubject === undefined) {
            planSubject = new PlanSubjects();
            this.plans[index] = planSubject;
        }
        return planSubject;
    }
}
/**
 * A collection of subjects for consuming flight plan data in the flight plan module.
 */
class PlanSubjects {
    constructor() {
        /** The current flight plan to display, if any. */
        this.flightPlan = Subject.create(undefined);
        /** An event that fires when the plan is changed. */
        this.planChanged = new SubEvent();
        /** An event that fired when the flight path of the plan is recalculated. */
        this.planCalculated = new SubEvent();
        /** The active leg index currently being navigated to. */
        this.activeLeg = Subject.create(0);
    }
}

/**
 * A module which describes whether the map is following the player airplane.
 */
class MapFollowAirplaneModule {
    constructor() {
        /** Whether the map is following the player airplane. */
        this.isFollowing = Subject.create(false);
    }
}

/**
 * A map data module that controls waypoint display options.
 */
class MapWaypointDisplayModule {
    constructor() {
        /** A handler that dictates airport waypoint visibility. */
        this.showAirports = Subject.create(() => true);
        /** A handler that dictates intersection waypoint visibility. */
        this.showIntersections = Subject.create(() => false);
        /** A handler that dictates NDB waypoint visibility. */
        this.showNdbs = Subject.create(() => true);
        /** A handler that dictates VOR waypoint visibility. */
        this.showVors = Subject.create(() => true);
        /** The maximum range at which airport waypoints should be searched for. */
        this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which intersection waypoints should be searched for. */
        this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which NDB waypoints should be searched for. */
        this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum range at which VOR waypoints should be searched for. */
        this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum number of airports that should be displayed. */
        this.numAirports = Subject.create(40);
        /** The maximum number of intersections that should be displayed. */
        this.numIntersections = Subject.create(40);
        /** The maximum number of NDBs that should be displayed. */
        this.numNdbs = Subject.create(40);
        /** The maximum number of VORs that should be displayed. */
        this.numVors = Subject.create(40);
    }
}

/**
 * A module that describes the display of weather on a Bing Map instance.
 */
class MapWxrModule {
    /**
     * Constructor.
     */
    constructor() {
        /** Whether the weather radar is enabled. */
        this.isEnabled = Subject.create(false);
        /** The current map weather radar arc sweep angle in degrees. */
        this.weatherRadarArc = NumberUnitSubject.createFromNumberUnit(UnitType.DEGREE.createNumber(90));
        /** The current weather radar mode. */
        this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
        this._wxrMode = Subject.create({
            mode: this.isEnabled.get() ? this.weatherRadarMode.get() : EWeatherRadar.OFF,
            arcRadians: this.weatherRadarArc.get().asUnit(UnitType.RADIAN),
        });
        this.isEnabled.sub(v => {
            this._wxrMode.get().mode = v ? this.weatherRadarMode.get() : EWeatherRadar.OFF;
            this._wxrMode.notify();
        });
        this.weatherRadarArc.sub(v => {
            this._wxrMode.get().arcRadians = v.asUnit(UnitType.RADIAN);
            this._wxrMode.notify();
        });
        this.weatherRadarMode.sub(v => {
            this._wxrMode.get().mode = this.isEnabled.get() ? v : EWeatherRadar.OFF;
            this._wxrMode.notify();
        });
    }
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode() {
        return this._wxrMode;
    }
}

/**
 * A class that builds a configuration for the waypoint display.
 */
class WaypointDisplayBuilder {
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory, labelFactory, waypointRenderer) {
        this.iconFactory = iconFactory;
        this.labelFactory = labelFactory;
        this.waypointRenderer = waypointRenderer;
        this.roleGroup = MapSystemWaypointRoles.Normal;
        this.isCenterTarget = false;
    }
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon(role, type, config) {
        this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon(role, config) {
        this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel(role, type, config) {
        this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel(role, config) {
        this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    determineRoleId(role) {
        let roleId = 0;
        if (typeof role === 'string') {
            const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
            if (roleIdFromName !== undefined) {
                roleId = roleIdFromName;
            }
        }
        else {
            roleId = role;
        }
        return roleId;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.addRenderRole(name, undefined, this.roleGroup);
        return this;
    }
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role) {
        const roleId = this.waypointRenderer.getRoleFromName(role);
        if (roleId === undefined) {
            throw new Error(`The role with name ${role} was not defined and could not be found.`);
        }
        return roleId;
    }
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center) {
        if (center === 'center') {
            this.isCenterTarget = false;
        }
        else {
            this.isCenterTarget = true;
        }
        return this;
    }
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget() {
        return this.isCenterTarget;
    }
}

/**
 * A class that builds the configuration for the flight plan display.
 */
class FlightPlanDisplayBuilder extends WaypointDisplayBuilder {
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
        super(iconFactory, labelFactory, waypointRenderer);
        this.flightPlanRenderer = flightPlanRenderer;
        this.planIndex = planIndex;
        this.roleGroup = MapSystemWaypointRoles.FlightPlan;
        this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
        flightPlanRenderer.legStyleHandlers;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, undefined, this.roleGroup);
        return this;
    }
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler) {
        this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
        return this;
    }
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler) {
        this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
        return this;
    }
}

/**
 * Moderates access to a resource.
 */
class ResourceModerator {
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource) {
        this.resource = resource;
        this.pendingConsumer = null;
        this.assignedConsumer = null;
        this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer) {
        var _a;
        const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
        if (consumerToDisplace === consumer) {
            return;
        }
        if (this.queuedConsumers.has(consumer)) {
            return;
        }
        if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
            if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
                if (consumerToDisplace) {
                    this.queuedConsumers.insert(consumerToDisplace);
                    this.pendingConsumer = null;
                }
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            this.assignedConsumer = null;
            this.pendingConsumer = consumer;
            this.queuedConsumers.insert(consumerToDisplace);
            consumerToDisplace.onCeded(this.resource);
            if (this.pendingConsumer === consumer) {
                this.pendingConsumer = null;
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            else {
                // Something has displaced the new pending consumer. Either something pre-empted it, in which case it is
                // now in the queue, or it forfeited its claim. In either case, there is nothing to do.
                return;
            }
        }
        this.queuedConsumers.insert(consumer);
    }
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer) {
        var _a;
        if (this.pendingConsumer === consumer) {
            this.pendingConsumer = null;
            return;
        }
        if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
            this.queuedConsumers.remove(consumer);
            return;
        }
        const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
        this.pendingConsumer = next;
        this.assignedConsumer = null;
        consumer.onCeded(this.resource);
        if (next !== null && this.pendingConsumer === next) {
            this.pendingConsumer = null;
            this.assignedConsumer = next;
            this.assignedConsumer.onAcquired(this.resource);
        }
    }
}

/**
 * An generic implementation of {@link MapAirspaceRenderManager}.
 */
class GenericAirspaceRenderManager {
    /**
     * Constructor.
     * @param renderOrder A function which determines the order in which this manager renders airspaces. The function
     * should return a negative number when airspace `a` should be rendered before (below) airspace `b`, a positive
     * number when airspace `a` should be rendered after (above) airspace `b`, and `0` when the relative render order
     * of the two airspaces does not matter.
     * @param selectRenderer A function which selects airspace renderers for individual airspaces.
     */
    constructor(renderOrder, selectRenderer) {
        this.renderOrder = renderOrder;
        this.selectRenderer = selectRenderer;
        this.airspaces = new Map();
    }
    /** @inheritdoc */
    getRegisteredAirspaces() {
        return Array.from(this.airspaces.values());
    }
    /** @inheritdoc */
    registerAirspace(airspace) {
        if (this.airspaces.has(airspace.facility.id)) {
            return false;
        }
        this.airspaces.set(airspace.facility.id, airspace);
        return true;
    }
    /** @inheritdoc */
    deregisterAirspace(airspace) {
        return this.airspaces.delete(airspace.facility.id);
    }
    /** @inheritdoc */
    replaceRegisteredAirspaces(airspaces) {
        let changed = false;
        let numMatched = 0;
        for (const airspace of airspaces) {
            changed || (changed = !this.airspaces.has(airspace.facility.id));
            if (changed) {
                break;
            }
            else {
                numMatched++;
            }
        }
        changed || (changed = numMatched !== this.airspaces.size);
        if (!changed) {
            return false;
        }
        this.airspaces.clear();
        for (const airspace of airspaces) {
            this.registerAirspace(airspace);
        }
        return true;
    }
    /** @inheritdoc */
    clearRegisteredAirspaces() {
        if (this.airspaces.size === 0) {
            return false;
        }
        this.airspaces.clear();
        return true;
    }
    /** @inheritdoc */
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
        const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
        const tasks = sorted.map(airspace => {
            const renderer = this.selectRenderer(airspace);
            // The explicit cast is to avoid a bogus typescript error
            return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
        });
        return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
}

/**
 * Updates the properties in a {@link MapAutopilotPropsModule}.
 */
class MapAutopilotPropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz. If not defined, the properties
     * will be updated every frame.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        if (this.updateFreq) {
            this.updateFreqSub = this.updateFreq.sub(freq => {
                var _a;
                for (const property of this.properties) {
                    (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.subs[property] = this.bindProperty(sub, property, freq);
                }
            }, true);
        }
        else {
            for (const property of this.properties) {
                this.subs[property] = this.bindProperty(sub, property);
            }
        }
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'selectedAltitude':
                return (updateFreq === undefined ? sub.on('ap_altitude_selected') : sub.on('ap_altitude_selected').atFrequency(updateFreq))
                    .handle(alt => { this.module.selectedAltitude.set(alt, UnitType.FOOT); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/**
 * A component that encompasses the compiled map system.
 */
class MapSystemComponent extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.rootStyles = ObjectSubject.create({
            width: '0px',
            height: '0px'
        });
        this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
        this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        super.onAfterRender(thisNode);
        this.onProjectedSizeChanged();
        this.props.onAfterRender();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    onDeadZoneChanged(deadZone) {
        this.props.onDeadZoneChanged(deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootStyles.set('width', `${size[0]}px`);
        this.rootStyles.set('height', `${size[1]}px`);
    }
    /** @inheritdoc */
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.props.onBeforeUpdated(time, elapsed);
        super.onUpdated(time, elapsed);
        this.props.onAfterUpdated(time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        super.onWake();
        this.props.onWake();
    }
    /** @inheritdoc */
    onSleep() {
        super.onSleep();
        this.props.onSleep();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.props.onDestroy();
    }
}

/**
 * An implementation of the base properties in {@link MapSystemContext}.
 */
class DefaultMapSystemContext {
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus, projection, projectedSize, deadZone) {
        this.bus = bus;
        this.projection = projection;
        this.projectedSize = projectedSize;
        this.deadZone = deadZone;
        /** This context's map model. */
        this.model = new MapModel();
        this.layers = new Map();
        this.controllers = new Map();
    }
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer(key) {
        return this.layers.get(key);
    }
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController(key) {
        return this.controllers.get(key);
    }
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer(key, layer) {
        this.layers.set(key, layer);
    }
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController(key, controller) {
        this.controllers.set(key, controller);
    }
}

/**
 * A map controller which delegates its behavior to injected callback functions.
 */
class MapSystemGenericController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context, callbacks) {
        super(context);
        this.callbacks = callbacks;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    /** @inheritdoc */
    onDeadZoneChanged(deadZone) {
        this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onBeforeUpdated(time, elapsed) {
        this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onAfterUpdated(time, elapsed) {
        this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    /** @inheritdoc */
    onSleep() {
        this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
}

/**
 * A map flight plan renderer that can be supplied styling from the outside.
 */
class MapSystemPlanRenderer extends AbstractFlightPathPlanRenderer {
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
        super(renderOrder, renderActiveLegLast);
        this.defaultRoleId = defaultRoleId;
        this.legRenderer = new MapSystemLegRenderer();
        /**
         * A handler that returns a leg rendering style for a given set of leg data.
         * @returns A leg rendering style.
         */
        this.legStyleHandlers = new Map();
        /**
         * A handler that returns whether or not a leg waypoint should be displayed.
         * @returns Whether or not the leg should be displayed.
         */
        this.legWaypointHandlers = new Map();
        /** Whether or not to render flight path ingress turns. */
        this.renderIngress = false;
        /** Whether or not to render flight path egress turns. */
        this.renderEgress = false;
    }
    /** @inheritdoc */
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
        this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
        const handler = this.legStyleHandlers.get(plan.planIndex);
        if (handler !== undefined) {
            this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
        }
        const partsToRender = FlightPathLegRenderPart.Base
            | (this.renderIngress ? FlightPathLegRenderPart.Ingress : 0)
            | (this.renderEgress ? FlightPathLegRenderPart.Egress : 0);
        this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
}
/**
 * A map system flight plan leg renderer that uses a swappable style.
 */
class MapSystemLegRenderer extends AbstractFlightPathLegRenderer {
    constructor() {
        super(...arguments);
        this.vectorRenderer = new FlightPathVectorLineRenderer();
        this.currentRenderStyle = new FlightPathRenderStyle();
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
        if (this.currentRenderStyle.isDisplayed) {
            this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash);
        }
    }
}
/**
 * A vector line rendering style to apply to a flight path display on the map.
 */
class FlightPathRenderStyle {
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed = true) {
        this.isDisplayed = isDisplayed;
        /** The pixel width of the path line. */
        this.width = 3;
        /** The style string for the line. */
        this.style = '';
    }
}
/** The default rendering style. */
FlightPathRenderStyle.Default = new FlightPathRenderStyle();
/** A style that does not display the path. */
FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);

/**
 * Utility methods related to MapSystem.
 */
class MapSystemUtils {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
        return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
        return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
        return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
}

/**
 * A waypoint renderer for the MapSystem API. Supports addition of string-keyed render roles. Each render role is
 * assigned a position in an ordered list that determines the priority of being chosen when roles are selected for
 * rendering waypoints. For each waypoint, the renderer iterates through all render roles in the priority order list
 * and selects the first role under which the waypoint is registered and is visible.
 */
class MapSystemWaypointsRenderer extends MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
        super(textManager, (entry, roleDefinitions) => {
            var _a;
            for (let i = 0; i < this.rolePriorityOrder.length; i++) {
                const role = this.rolePriorityOrder[i];
                if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
                    return role;
                }
            }
            return 0;
        });
        this.rolePriorityOrder = [];
        this.rolesByGroup = new Map();
        this.roleIdMap = new Map();
        this.currentBit = 1;
        /** An event that fires when any roles are added. */
        this.onRolesAdded = new SubEvent();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        if (typeof arg1 === 'number') {
            return false;
        }
        this.roleIdMap.set(arg1, this.currentBit);
        super.addRenderRole(this.currentBit, def);
        this.rolePriorityOrder.push(this.currentBit);
        let roleGroup = this.rolesByGroup.get(group);
        if (roleGroup === undefined) {
            roleGroup = [];
            this.rolesByGroup.set(group, roleGroup);
        }
        roleGroup.push(arg1);
        this.currentBit *= 2;
        this.onRolesAdded.notify(this);
        return true;
    }
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        const role = this.currentBit;
        this.addRenderRole(name, def, group);
        const roleToInsertBefore = this.roleIdMap.get(insertBefore);
        if (roleToInsertBefore !== undefined) {
            const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
            if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
                this.rolePriorityOrder.pop();
                this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
            }
        }
        return true;
    }
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name) {
        return this.roleIdMap.get(name);
    }
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group) {
        const roleNames = this.rolesByGroup.get(group);
        if (roleNames !== undefined) {
            return roleNames;
        }
        return [];
    }
}
/** The default render role group. */
MapSystemWaypointsRenderer.DefaultGroup = 'DEFAULT_GROUP';
/**
 * A class that creates icons for the map system waypoint renderer.
 */
class MapSystemIconFactory {
    constructor() {
        this.cache = new Map();
        this.iconFactories = new Map();
        this.defaultIconFactories = new Map();
    }
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory(role, iconType, factory) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory(role, factory) {
        this.defaultIconFactories.set(role, factory);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let icon = roleCache.get(waypoint.uid);
        if (icon === undefined) {
            icon = this.createIcon(role, waypoint);
            roleCache.set(waypoint.uid, icon);
        }
        return icon;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(role, waypoint) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultIconFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        const imageEl = document.createElement('img');
        imageEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC';
        return new MapWaypointImageIcon(waypoint, 0, imageEl, 24, 24);
    }
}
/**
 * A class that create labels for the map system waypoint renderer.
 */
class MapSystemLabelFactory {
    constructor() {
        this.cache = new Map();
        this.labelFactories = new Map();
        this.defaultLabelFactories = new Map();
    }
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory(role, iconType, factory) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory(role, factory) {
        this.defaultLabelFactories.set(role, factory);
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let label = roleCache.get(waypoint.uid);
        if (label === undefined) {
            label = this.createLabel(role, waypoint);
            roleCache.set(waypoint.uid, label);
        }
        return label;
    }
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role, waypoint) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultLabelFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        if (waypoint instanceof FacilityWaypoint) {
            const facility = waypoint.facility;
            return new MapCullableLocationTextLabel(ICAO.getIdent(waypoint.facility.icao), 0, new GeoPoint(facility.lat, facility.lon), false, { fontSize: 22, font: 'monospace', anchor: new Float64Array([-0.25, 0.4]) });
        }
        return new MapCullableLocationTextLabel('', 0, new GeoPoint(0, 0), false);
    }
}

/**
 * Builds maps. Each builder is configured with a series of build steps which collectively define how the builder
 * compiles finished maps. In addition to defining basic map properties such as size and range, build steps can also
 * customize map behavior and appearance through adding map model modules, layers, and controllers.
 *
 * Each map compiled by the builder is associated with a {@link MapSystemContext}, which holds references to the map
 * projection, map model, all layers and controllers, and other data associated with the map. Layers and controllers
 * have access to the context when they are created during compilation, and a reference to the context is stored with
 * the compiled map.
 *
 * A single builder can compile multiple maps. Each compiled map is a separate entity, with its own model, layers,
 * controllers, and context.
 */
class MapSystemBuilder {
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.moduleFactories = new Map();
        this.layerFactories = new Map();
        this.controllerFactories = new Map();
        this.contextFactories = new Map();
        this.initCallbacks = new Map();
        this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map model modules added to this builder. */
    get moduleCount() {
        return this.moduleFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map layers added to this builder. */
    get layerCount() {
        return this.layerFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map controllers added to this builder. */
    get controllerCount() {
        return this.controllerFactories.size;
    }
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus) {
        return new MapSystemBuilder(bus);
    }
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size) {
        this.projectedSize = 'isSubscribable' in size ? size : Subject.create(size);
        return this;
    }
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone) {
        this.deadZone = 'isSubscribable' in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
        return this;
    }
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset) {
        this.targetOffset = offset;
        return this;
    }
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints) {
        this.nominalRangeEndpoints = endpoints;
        return this;
    }
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range) {
        this.range = range.asUnit(UnitType.GA_RADIAN);
        return this;
    }
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key, factory) {
        this.moduleFactories.set(key, { key, factory });
        return this;
    }
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer(key, factory, order) {
        // Delete the key to ensure a consistent layer order.
        const wasDeleted = this.layerFactories.delete(key);
        this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : (this.layerFactories.size + (wasDeleted ? 1 : 0)) });
        return this;
    }
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController(key, factory) {
        this.controllerFactories.set(key, { factory });
        return this;
    }
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext(key, factory) {
        var _a;
        if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
            const existing = this.contextFactories.get(key);
            const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
            this.contextFactories.set(key, { key, factory, order });
        }
        return this;
    }
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit(key, callback) {
        this.initCallbacks.set(key, callback);
        return this;
    }
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key, order) {
        const factory = this.layerFactories.get(key);
        if (factory) {
            // Delete the key to ensure a consistent layer order.
            this.layerFactories.delete(key);
            factory.order = order;
            this.layerFactories.set(key, factory);
        }
        return this;
    }
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @returns This builder, after it has been configured.
     */
    withBindings(key, bindings) {
        return this.withController(key, context => new MapBindingsController(context, bindings(context)));
    }
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq) {
        return this
            .withContext('updateFreq', () => typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq)
            .withController(MapSystemKeys.ClockUpdate, context => new MapClockUpdateController(context));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator() {
        return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator() {
        return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator() {
        return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane() {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule)
            .withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule())
            .withTargetControlModerator()
            .withController(MapSystemKeys.FollowAirplane, context => new MapFollowAirplaneController(context));
    }
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation() {
        return this
            .withModule(MapSystemKeys.Rotation, () => new MapRotationModule())
            .withRotationControlModerator()
            .withController(MapSystemKeys.Rotation, context => new MapRotationController(context));
    }
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule())
            .withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
            return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: typeof iconFilePath === 'string' ? Subject.create(iconFilePath) : iconFilePath, iconSize: iconSize, iconAnchor: 'isSubscribable' in iconAnchor ? iconAnchor : Subject.create(iconAnchor), class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings(properties, updateFreq) {
        return this.withController(MapSystemKeys.OwnAirplaneProps, context => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
    }
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind, updateFreq) {
        this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
        if (propertiesToBind !== undefined) {
            this.withController(MapSystemKeys.AutopilotProps, context => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
        }
        return this;
    }
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling, order) {
        return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling))
            .withLayer(MapSystemKeys.TextLayer, (context) => {
            return (FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId, delay = 0, order) {
        return this
            .withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule())
            .withModule(MapSystemKeys.Weather, () => new MapWxrModule())
            .withLayer(MapSystemKeys.Bing, context => {
            const terrainColors = context.model.getModule('terrainColors');
            const weather = context.model.getModule('weather');
            return (FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId: bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, wxrMode: weather.wxrMode, delay: delay }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints() {
        return this
            .withContext(MapSystemKeys.WaypointRenderer, context => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager]))
            .withController('waypointRendererUpdate', context => new MapSystemGenericController(context, {
            onAfterUpdated: (contextArg) => { contextArg[MapSystemKeys.WaypointRenderer].update(context.projection); }
        }));
    }
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure, enableTextCulling = false, order) {
        this
            .withTextLayer(enableTextCulling)
            .withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule())
            .withWaypoints()
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory())
            .withContext('useTargetAsWaypointSearchCenter', context => {
            context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, undefined, MapSystemWaypointRoles.Normal);
            const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
            configure(builder);
            return builder.getIsCenterTarget();
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(MapSystemKeys.NearestWaypoints, context => {
            return (FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order) {
        this
            .withTextLayer(enableTextCulling)
            .withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule())
            .withWaypoints()
            .withContext(MapSystemKeys.FlightPlanner, () => flightPlanner)
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory())
            .withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1))
            .withController(MapSystemKeys.FlightPlan, context => new MapFlightPlanController(context))
            .withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, context => {
            const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
            configure(builder);
            const flightPlanRoles = context[MapSystemKeys.WaypointRenderer].getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
            if (flightPlanRoles.length === 0) {
                context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, undefined, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
            }
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
            return (FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex: planIndex }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
        return this
            .withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes))
            .withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer))
            .withLayer(MapSystemKeys.Airspace, context => {
            var _a, _b;
            const optionsToUse = Object.assign({}, options);
            (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : (optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10)));
            (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : (optionsToUse.maxSearchItemCount = Subject.create(100));
            return (FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse)));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas))
            .withLayer('traffic', context => {
            const options = offScaleOobOptions !== undefined ? Object.assign({}, offScaleOobOptions(context)) : {};
            if (options.oobOffset !== undefined && !('isSubscribable' in options.oobOffset)) {
                options.oobOffset = Subject.create(options.oobOffset);
            }
            return (FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context: context, model: context.model, mapProjection: context.projection, iconFactory: iconFactory, initCanvasStyles: initCanvasStyles }, options)));
        }, order);
    }
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with(builder, ...args) {
        return builder(this, ...args);
    }
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build(cssClass) {
        const context = this.buildContext();
        const controllers = [];
        const ref = FSComponent.createRef();
        const onAfterRender = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterMapRender(ref.instance);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDeadZoneChanged = (deadZone) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onDeadZoneChanged(deadZone);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onMapProjectionChanged = (mapProjection, changeFlags) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onBeforeUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onBeforeUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
            context.projection.applyQueued();
        };
        const onAfterUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onWake = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onWake();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onSleep = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onSleep();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDestroy = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapDestroyed();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const map = (FSComponent.buildComponent(MapSystemComponent, { ref: ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender: onAfterRender, onDeadZoneChanged: onDeadZoneChanged, onMapProjectionChanged: onMapProjectionChanged, onBeforeUpdated: onBeforeUpdated, onAfterUpdated: onAfterUpdated, onWake: onWake, onSleep: onSleep, onDestroy: onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map(factory => {
            const node = factory.factory(context);
            context.setLayer(factory.key, node.instance);
            return node;
        })));
        const controllerEntries = Array.from(this.controllerFactories)
            .map(([key, factory]) => [key, factory.factory(context)]);
        for (const [key, controller] of controllerEntries) {
            context.setController(key, controller);
        }
        controllers.push(...controllerEntries.map(([, controller]) => controller));
        for (const callback of this.initCallbacks.values()) {
            callback(context);
        }
        return { context, map, ref };
    }
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    buildContext() {
        var _a;
        const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
        context.projection.set({
            targetProjectedOffset: this.targetOffset,
            rangeEndpoints: this.nominalRangeEndpoints !== undefined
                ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create())
                : undefined,
            range: this.range
        });
        for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
            context[factory.key] = factory.factory(context);
        }
        for (const factory of this.moduleFactories.values()) {
            context.model.addModule(factory.key, factory.factory());
        }
        return context;
    }
}
MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = new Set([
    'bus',
    'model',
    'projection',
    'projectedSize',
    'deadZone',
    'getLayer',
    'setLayer',
    'getController',
    'setController'
]);

var MapFLARMTrafficAlertLevelVisibility;
(function (MapFLARMTrafficAlertLevelVisibility) {
    MapFLARMTrafficAlertLevelVisibility[MapFLARMTrafficAlertLevelVisibility["Other"] = 1] = "Other";
    MapFLARMTrafficAlertLevelVisibility[MapFLARMTrafficAlertLevelVisibility["SmallRisk"] = 2] = "SmallRisk";
    MapFLARMTrafficAlertLevelVisibility[MapFLARMTrafficAlertLevelVisibility["MediumRisk"] = 4] = "MediumRisk";
    MapFLARMTrafficAlertLevelVisibility[MapFLARMTrafficAlertLevelVisibility["HeavyRisk"] = 8] = "HeavyRisk";
    MapFLARMTrafficAlertLevelVisibility[MapFLARMTrafficAlertLevelVisibility["All"] = 15] = "All";
})(MapFLARMTrafficAlertLevelVisibility || (MapFLARMTrafficAlertLevelVisibility = {}));
class MapFLARMTrafficModule {
    constructor(flarm) {
        this.flarm = flarm;
        this.show = Subject.create(true);
        this.operatingMode = Subject.create(FLARMOperatingMode.Off);
        this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        this.alertLevelVisibility = Subject.create(MapFLARMTrafficAlertLevelVisibility.All);
        this.flarm
            .getEventSubscriber()
            .on('flarm_operating_mode')
            .whenChanged()
            .handle((mode) => this.operatingMode.set(mode));
    }
}

class MapSystemFLARMTrafficLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.iconLayersRef = FSComponent.createRef();
        this.FLARMtrafficModule = this.props.model.getModule('FLARM');
        this.intruderIcons = {
            [FLARMAlertLevel.None]: new Map(),
            [FLARMAlertLevel.Small]: new Map(),
            [FLARMAlertLevel.Medium]: new Map(),
            [FLARMAlertLevel.Heavy]: new Map(),
        };
        this.isInit = false;
    }
    onVisibilityChanged(isVisible) {
        if (!isVisible) {
            if (!this.isInit) {
                this.iconLayersRef.instance.display.clear();
            }
        }
    }
    onAttached() {
        this.iconLayersRef.instance.onAttached();
        this.FLARMtrafficModule.operatingMode.sub(this.updateVisibility.bind(this), true);
        this.FLARMtrafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initIntruders();
        this.initFLARMHandlers();
        this.isInit = true;
    }
    updateVisibility() {
        this.setVisible(true);
    }
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    redrawIntruders() {
        const alertLevelVisFlags = this.FLARMtrafficModule.alertLevelVisibility.get();
        const offScaleRange = this.FLARMtrafficModule.offScaleRange.get();
        const iconDisplay = this.iconLayersRef.instance.display;
        iconDisplay.clear();
        for (let i = 0; i < MapSystemFLARMTrafficLayer.DRAW_GROUPS.length; i++) {
            const group = MapSystemFLARMTrafficLayer.DRAW_GROUPS[i];
            if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
                this.intruderIcons[group.alertLevel].forEach((icon) => {
                    icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
                });
            }
        }
    }
    initIntruders() {
        const intruders = this.FLARMtrafficModule.flarm.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    initFLARMHandlers() {
        const flarmSub = this.props.context.bus.getSubscriber();
        flarmSub.on('flarm_intruder_added').handle(this.onIntruderAdded.bind(this));
        flarmSub.on('flarm_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        flarmSub.on('flarm_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    onIntruderAdded(intruder) {
        const icon = this.props.iconFactory(intruder, this.props.context);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    onIntruderRemoved(intruder) {
        this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderIcons[(oldAlertLevel = FLARMAlertLevel.None)].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[(oldAlertLevel = FLARMAlertLevel.Small)].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[(oldAlertLevel = FLARMAlertLevel.Medium)].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[(oldAlertLevel = FLARMAlertLevel.Heavy)].get(intruder));
        if (view) {
            this.intruderIcons[oldAlertLevel].delete(intruder);
            this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayersRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) ;
    }
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayersRef, model: this.props.model, mapProjection: this.props.mapProjection }));
    }
}
MapSystemFLARMTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapFLARMTrafficAlertLevelVisibility.Other, alertLevel: FLARMAlertLevel.None },
    { alertLevelVisFlag: MapFLARMTrafficAlertLevelVisibility.SmallRisk, alertLevel: FLARMAlertLevel.Small },
    { alertLevelVisFlag: MapFLARMTrafficAlertLevelVisibility.MediumRisk, alertLevel: FLARMAlertLevel.Medium },
    { alertLevelVisFlag: MapFLARMTrafficAlertLevelVisibility.HeavyRisk, alertLevel: FLARMAlertLevel.Heavy },
];

class PageViewService extends ViewService {
    constructor(elementID) {
        super(elementID);
        this.currentPageIndex = 0;
    }
    onInteractionEvent(event) {
        switch (event) {
            case ASEvents.BOTTOM_RIGHT_INC:
                this.currentPageIndex = Math.max(0, this.currentPageIndex - 1);
                this.openByIndex(this.currentPageIndex);
                return true;
            case ASEvents.BOTTOM_RIGHT_DEC:
                this.currentPageIndex = Math.min(this.registeredViews.size - 1, this.currentPageIndex + 1);
                this.openByIndex(this.currentPageIndex);
                return true;
        }
        return false;
    }
}

class PopUpViewService extends ViewService {
    constructor(elementID) {
        super(elementID);
    }
    open(viewEntry) {
        this.currentPopUp = super.open(viewEntry);
        this.currentPopUp.onClose.on(() => (this.currentPopUp = undefined));
        return this.currentPopUp;
    }
    get hasPopUpOpen() {
        return this.currentPopUp !== undefined;
    }
    onInteractionEvent(event) {
        if (this.currentPopUp)
            return this.currentPopUp.onInteractionEvent(event);
        return false;
    }
}

class MapFormatController extends MapSystemController {
    constructor(context) {
        super(context);
        this.terrain = this.context.model.getModule(MapSystemKeys.TerrainColors);
        this.ownship = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
        this.rotation = this.context.model.getModule(MapSystemKeys.Rotation);
        this.bingLayer = this.context.getLayer(MapSystemKeys.Bing);
        this.flightplan1Layer = this.context.getLayer('flightPlan1');
        this.waypointLayer = this.context.getLayer(MapSystemKeys.NearestWaypoints);
        this.textLayer = this.context.getLayer(MapSystemKeys.TextLayer);
    }
    onAfterMapRender() {
        this.wireSettings();
    }
    wireSettings() {
        this.setTerrain();
        this.setBing();
        this.setRotationType();
        this.setWaypointVisible();
        this.setOwnshipVisible();
    }
    setTerrain() {
        this.terrain.reference.set(EBingReference.SEA);
        this.terrain.colors.set(BingComponent.createEarthColorsArray('#0101cd', [
            { elev: 0, color: '#f7f1e3' },
            { elev: 1, color: '#b0c59a' },
            { elev: 500, color: '#89a86b' },
            { elev: 1000, color: '#d3de8c' },
            { elev: 2000, color: '#cbaf70' },
            { elev: 4000, color: '#aa7c4f' },
            { elev: 6000, color: '#aa9485' },
            { elev: 8000, color: '#bbbabb' },
            { elev: 15000, color: '#dededd' },
        ]));
    }
    setBing() {
        this.bingLayer.setVisible(true);
    }
    setRotationType() {
        this.rotation.rotationType.set(MapRotation.NorthUp);
    }
    setWaypointVisible() {
        this.flightplan1Layer.setVisible(true);
        this.waypointLayer.setVisible(true);
        this.textLayer.setVisible(true);
    }
    setOwnshipVisible() {
        this.ownship.show.set(true);
    }
}

class MapRangeController extends MapSystemController {
    constructor(context) {
        super(context);
        this.settings = MapUserSettings.getManager(this.context.bus);
    }
    onAfterMapRender() {
        this.wireSettings();
    }
    wireSettings() {
        this.settings.whenSettingChanged('mapRange').handle(this.handleRangeChanged.bind(this));
    }
    handleRangeChanged(range) {
        SimVar.SetSimVarValue('L:XMLVAR_ASNAV_ZOOM', 'number', range);
        this.context.projection.setQueued({
            range: UnitType.KILOMETER.convertTo(range, UnitType.GA_RADIAN),
        });
    }
}

class AbstractMapFLARMTrafficIntruderIcon {
    constructor(intruder, trafficModule, ownshipModule) {
        this.intruder = intruder;
        this.trafficModule = trafficModule;
        this.ownshipModule = ownshipModule;
        this.projectedPos = new Float64Array(2);
        this.isOffScale = false;
    }
    draw(projection, context, offScaleRange) {
        this.updatePosition(projection, offScaleRange);
        this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    updatePosition(projection, offScaleRange) {
        const ownAirplanePos = this.ownshipModule.position.get();
        if (offScaleRange.isNaN()) {
            projection.project(this.intruder.position, this.projectedPos);
            this.isOffScale = false;
        }
        else {
            this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
        }
    }
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
        const intruderPos = this.intruder.position;
        const horizontalSeparation = intruderPos.distance(ownAirplanePos);
        const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
        if (horizontalSeparation > offscaleRangeRad) {
            this.isOffScale = true;
            projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapFLARMTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
        }
        else {
            this.isOffScale = false;
            projection.project(intruderPos, this.projectedPos);
        }
    }
}
AbstractMapFLARMTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];
class MapFLARMTrafficIntruderIcon extends AbstractMapFLARMTrafficIntruderIcon {
    drawIcon(projection, context, projectedPos, isOffScale) {
        const alertLevel = this.intruder.alertLevel.get();
        const heading = this.intruder.heading.get();
        if (!projection.isInProjectedBounds(projectedPos)) {
            return;
        }
        context.translate(projectedPos[0], projectedPos[1]);
        this.drawIconSymbol(context, projection, heading, alertLevel, isOffScale);
        context.resetTransform();
    }
    drawIconSymbol(context, projection, heading, alertLevel, isOffScale) {
        let needRestoreContextState = false;
        if (isOffScale) {
            context.save();
            needRestoreContextState = true;
        }
        context.rotate(heading * Avionics.Utils.DEG2RAD + projection.getRotation());
        switch (alertLevel) {
            case FLARMAlertLevel.None:
                context.drawImage(MapIconImageCache.getGliderFLARMLevelIcon(FLARMAlertLevel.None), -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, MapFLARMTrafficIntruderIcon.ICON_SIZE, MapFLARMTrafficIntruderIcon.ICON_SIZE);
                break;
            case FLARMAlertLevel.Small:
                context.drawImage(MapIconImageCache.getGliderFLARMLevelIcon(FLARMAlertLevel.Small), -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, MapFLARMTrafficIntruderIcon.ICON_SIZE, MapFLARMTrafficIntruderIcon.ICON_SIZE);
                break;
            case FLARMAlertLevel.Medium:
                context.drawImage(MapIconImageCache.getGliderFLARMLevelIcon(FLARMAlertLevel.Medium), -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, MapFLARMTrafficIntruderIcon.ICON_SIZE, MapFLARMTrafficIntruderIcon.ICON_SIZE);
                break;
            case FLARMAlertLevel.Heavy:
                context.drawImage(MapIconImageCache.getGliderFLARMLevelIcon(FLARMAlertLevel.Heavy), -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, -MapFLARMTrafficIntruderIcon.ICON_SIZE / 2, MapFLARMTrafficIntruderIcon.ICON_SIZE, MapFLARMTrafficIntruderIcon.ICON_SIZE);
                break;
        }
        if (needRestoreContextState) {
            context.restore();
        }
    }
}
MapFLARMTrafficIntruderIcon.ICON_SIZE = 40;

class MapSystemConfig {
    static getOwnAirplanePropsToBind() {
        return ['position', 'hdgTrue', 'trackTrue'];
    }
    static buildFacilityLabel() {
        return (w) => {
            if (w.type === 'Airport') {
                return new MapCullableLocationTextLabel(ICAO.getIdent(w.facility.icao), 0, new GeoPoint(w.facility.lat, w.facility.lon), false, {
                    fontColor: 'white',
                    fontSize: 20,
                    fontOutlineColor: 'black',
                    fontOutlineWidth: 3,
                    font: 'Roboto',
                    anchor: new Float64Array([-0.25, 1.25]),
                });
            }
            else {
                return new MapCullableLocationTextLabel('', 0, new GeoPoint(w.facility.lat, w.facility.lon), false);
            }
        };
    }
    static buildIcon() {
        return (w) => {
            if (w.type === 'Airport') {
                return new MapWaypointImageIcon(w, 1, MapIconImageCache.getAirportIcon(), 24, 24);
            }
            else {
                return new MapWaypointImageIcon(w, 0, MapIconImageCache.getAirportIcon(), 0, 0);
            }
        };
    }
    static configureMapWaypoints(builder) {
        builder
            .withSearchCenter('center')
            .addDefaultIcon(MapSystemWaypointRoles.Normal, MapSystemConfig.buildIcon())
            .addDefaultLabel(MapSystemWaypointRoles.Normal, MapSystemConfig.buildFacilityLabel());
    }
    static createFLARMTrafficIntruderIcon(intruder, context) {
        return new MapFLARMTrafficIntruderIcon(intruder, context.model.getModule('FLARM'), context.model.getModule(MapSystemKeys.OwnAirplaneProps));
    }
    static configureDirectToFlightPlan(bus) {
        return (builder) => {
            const activeLegStyle = new FlightPathRenderStyle();
            activeLegStyle.style = 'magenta';
            builder
                .registerRole(PlanWaypointRoles.Active)
                .addDefaultIcon(PlanWaypointRoles.Active, (w) => {
                return new MapWaypointImageIcon(w, 1, MapIconImageCache.getAirportIcon(), 24, 24);
            })
                .addDefaultLabel(PlanWaypointRoles.Active, (w) => {
                return new MapCullableLocationTextLabel(ICAO.getIdent(w.facility.icao), 0, new GeoPoint(w.facility.lat, w.facility.lon), false, {
                    fontColor: 'white',
                    fontSize: 20,
                    fontOutlineColor: 'black',
                    fontOutlineWidth: 3,
                    font: 'Roboto',
                    anchor: new Float64Array([-0.25, 1.25]),
                });
            });
            builder.withLegPathStyles((plan, leg, activeLeg, legIndex) => {
                return activeLegStyle;
            });
            builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex) => {
                return builder.getRoleId(PlanWaypointRoles.Active);
            });
        };
    }
}
var PlanWaypointRoles;
(function (PlanWaypointRoles) {
    PlanWaypointRoles["Ahead"] = "FlightPlan_Ahead";
    PlanWaypointRoles["Active"] = "FlightPlan_Active";
    PlanWaypointRoles["From"] = "From";
    PlanWaypointRoles["Mod"] = "FlightPlan_Mod";
})(PlanWaypointRoles || (PlanWaypointRoles = {}));

class AirportPage1 extends GuiDialog {
    constructor() {
        super(...arguments);
        this.differentialBearing = Subject.create('---');
        this.bearing = Subject.create('---');
        this.distance = Subject.create('---');
        this.airportName = Subject.create('');
        this.winddirection = Subject.create('---');
        this.windspeed = Subject.create('--');
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.bus.on('direct_to_target_updated', () => {
            const DTOicao = this.props.fms.getDirectToTargetIcao();
            if (DTOicao) {
                this.props.loader.getFacility(FacilityType.Airport, DTOicao).then((facility) => {
                    this.airportName.set(Utils.Translate(facility.name).slice(0, 11));
                    const facilityGeoPoint = new GeoPointReadOnly(new GeoPoint(facility.lat, facility.lon));
                    if (this.gpsPositionSubscription) {
                        this.gpsPositionSubscription.destroy();
                    }
                    this.gpsPositionSubscription = this.props.bus
                        .getSubscriber()
                        .on('gps-position')
                        .atFrequency(1)
                        .handle((gpsPosition) => this.updateDirecToData(gpsPosition, facilityGeoPoint));
                });
            }
        });
        const windSub = this.props.bus.getSubscriber();
        windSub.on('ambient_wind_velocity').atFrequency(1).handle((v) => {
            let speed = UnitType.KNOT.convertTo(v, UnitType.MPS);
            this.windspeed.set(speed.toFixed(1));
        });

        LX.builddatafields();
    }
    updateDirecToData(gpsPosition, newFacility) {
        const newDistance = UnitType.GA_RADIAN.convertTo(newFacility.distance(gpsPosition.lat, gpsPosition.long), UnitType.KILOMETER);
        this.distance.set(newDistance.toFixed(1));
        const newBearing = newFacility.bearingFrom(gpsPosition.lat, gpsPosition.long);
        this.bearing.set(newBearing.toFixed(0));
        const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
        const difference = UnitType.RADIAN.convertTo(MathUtils.diffAngle(UnitType.DEGREE.convertTo(headingTrue, UnitType.RADIAN), UnitType.DEGREE.convertTo(newBearing, UnitType.RADIAN)), UnitType.DEGREE);
        let newDifferentialBearing = '';
        if (difference % 180 === 0) {
            newDifferentialBearing = `${(difference % 360).toFixed(0)}°`;
        }
        else if (difference > 180) {
            newDifferentialBearing = `<<${(360 - difference).toFixed(0)}°`;
        }
        else if (difference < 180) {
            newDifferentialBearing = `${difference.toFixed(0)}°>>`;
        }
        this.differentialBearing.set(newDifferentialBearing);

    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'subpage' },
            FSComponent.buildComponent("div", { class: 'subpage-top' },
                FSComponent.buildComponent("div", { class: 'subpage-row taskinfo' },
                    FSComponent.buildComponent("div", { id: 'task-wpt-name' }),
                    FSComponent.buildComponent("div", { id: 'course-pointer'}, ),
                    FSComponent.buildComponent("div", { id: 'task-timer' })),
                FSComponent.buildComponent("div", { class: 'subpage-row' },
                    "Apt: ",
                    this.airportName),
                FSComponent.buildComponent("div", { class: 'datafields', id: 'data-apt-top'},
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_1'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_2'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_3'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_4'}),
                    )),
            FSComponent.buildComponent("div", { class: 'subpage-bottom' },
                FSComponent.buildComponent("div", { class: 'datafields', id: 'data-apt-bottom'},
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_5'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_6'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_7'}),
                    FSComponent.buildComponent("div", { class: 'datafield', id: 'cell_0_8'}),
                    ),
                FSComponent.buildComponent("div", { class: 'subpage-row' },
                    FSComponent.buildComponent("div", null, "Wind"),
                    FSComponent.buildComponent("div", null, "Dis"),
                    FSComponent.buildComponent("div", null, "Brg")),
                FSComponent.buildComponent("div", { class: 'subpage-row' },
                    FSComponent.buildComponent("div", null,
                        this.windspeed,
                        "m/s"),
                    FSComponent.buildComponent("div", null,
                        this.distance,
                        "km"),
                    FSComponent.buildComponent("div", null,
                        this.bearing,
                        "\u00B0")))));
    }
}

class PopUpDialog extends GuiDialog {
    constructor(props) {
        var _a;
        super(props);
        this._isOpen = false;
        this.autoCloseDelay = (_a = this.props.autoCloseDelay) !== null && _a !== void 0 ? _a : NaN;
        this.onOpen.on(() => {
            this._isOpen = true;
            this.resetAutoCloseTimeout();
        });
        this.onClose.on(() => (this._isOpen = false));
    }
    get isOpen() {
        return this._isOpen;
    }
    resetAutoCloseTimeout() {
        if (!isNaN(this.autoCloseDelay)) {
            clearTimeout(this.autoCloseHandler);
            this.autoCloseHandler = setTimeout(() => {
                if (this.isOpen)
                    this.close();
            }, this.autoCloseDelay);
        }
    }
}

class McBalPopUp extends PopUpDialog {
    constructor() {
        super(...arguments);
        this.mcSetting = ComputedSubject.create(0, (v) => `${v >= 0 ? '+' : ''}${v.toFixed(1)}`);
        this.wingLoad = ComputedSubject.create(0, (v) => `Load: ${v.toFixed()}kg/m2`);
        this.speedToFlyInfos = Subject.create('');
        this.speedToFly = Subject.create(0);
        this.speedToFlyGlideRatio = Subject.create(0);
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('McBalPopUpMenu'));
        this.onClose.on(() => this.props.menuSystem.pushMenu('AirportModeMenu'));
        const varioSub = this.props.bus.getSubscriber();
        varioSub.on('mac_cready_setting').handle((v) => this.mcSetting.set(v));
        varioSub.on('speed_to_fly').handle((v) => this.speedToFly.set(v));
        varioSub.on('speed_to_fly_glide_ratio').handle((v) => this.speedToFlyGlideRatio.set(v));
        this.props.bus
            .getSubscriber()
            .on('wing_loading')
            .handle((v) => this.wingLoad.set(v));
        this.speedToFly.sub(this.updateSpeedToFlyInfos.bind(this));
        this.speedToFlyGlideRatio.sub(this.updateSpeedToFlyInfos.bind(this));
        this.props.bus
            .getSubscriber()
            .on('McBalPopUpMenuEvent')
            .handle((event) => {
            switch (event) {
                case McBalPopUpActionEvent.CLOSE:
                    this.close();
                    break;
                case McBalPopUpActionEvent.RESET:
                    if (this.mcSetting.getRaw() !== 0)
                        SimVar.SetSimVarValue('VARIOMETER MAC CREADY SETTING:1', SimVarValueType.MetersPerSecond, 0);
                    this.resetAutoCloseTimeout();
                    break;
            }
        });
    }
    onInteractionEvent(event) {
        switch (event) {
            case ASEvents.BOTTOM_RIGHT_INC:
            case ASEvents.BOTTOM_RIGHT_DEC:
                const newValue = Utils.Clamp(this.mcSetting.getRaw() + (event === ASEvents.BOTTOM_RIGHT_DEC ? -0.1 : 0.1), 0, 5);
                if (newValue !== this.mcSetting.getRaw())
                    SimVar.SetSimVarValue('VARIOMETER MAC CREADY SETTING:1', SimVarValueType.MetersPerSecond, newValue);
                this.resetAutoCloseTimeout();
                return true;
        }
        return false;
    }
    updateSpeedToFlyInfos() {
        this.speedToFlyInfos.set(`E: ${this.speedToFlyGlideRatio.get().toFixed()} at ${this.speedToFly.get().toFixed()}kmh`);
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'mc-bal-pop-up' },
            FSComponent.buildComponent("div", { class: 'left col' },
                FSComponent.buildComponent("div", null, this.speedToFlyInfos),
                FSComponent.buildComponent("div", null, this.wingLoad)),
            FSComponent.buildComponent("div", { class: 'right col' },
                FSComponent.buildComponent("div", { class: 'title' }, "MacCready"),
                FSComponent.buildComponent("div", { class: 'value-container' },
                    FSComponent.buildComponent("div", { class: 'value' }, this.mcSetting),
                    FSComponent.buildComponent("div", { class: 'unit' }, "m/s")))));
    }
}

class AirportMode extends GuiDialog {
    constructor(props) {
        super(props);
        this.mapRange = Subject.create('');
        this.UPDATE_FREQUENCY = 30;
        this.mcSetting = ComputedSubject.create(0, (v) => v.toFixed(1));
        /*
        this.mapSystem = MapSystemBuilder.create(this.props.bus)
            .withBing(`as8030-map-airport`)
            .withOwnAirplaneIcon(75, '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/glider/glider.svg', new Float64Array([0.5, 0.5]), 'hsi-map-ownship-icon', 10)
            .withNearestWaypoints(MapSystemConfig.configureMapWaypoints, true, 8)
            .withFlightPlan(MapSystemConfig.configureDirectToFlightPlan(this.props.bus), this.props.flightPlanner, 1, true, 9)
            .withModule('FLARM', () => new MapFLARMTrafficModule(this.props.flarm))
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withLayer('FLARM', (context) => {
            return (FSComponent.buildComponent(MapSystemFLARMTrafficLayer, { context: context, model: context.model, mapProjection: context.projection, iconFactory: MapSystemConfig.createFLARMTrafficIntruderIcon }));
        }, 1000)
            .withOwnAirplanePropBindings(MapSystemConfig.getOwnAirplanePropsToBind(), this.UPDATE_FREQUENCY)
            .withFollowAirplane()
            .withRotation()
            .withController('format', (context) => new MapFormatController(context))
            .withController('range', (context) => new MapRangeController(context))
            .withTargetOffset(new Float64Array([0, 0]))
            .withProjectedSize(this.props.mapSize)
            .withClockUpdate(this.UPDATE_FREQUENCY)
            .build();
            */
        this.handleMapRange = (newRange) => {
            this.mapRange.set(newRange.toFixed(1));
        };
        this.pageViewService = new PageViewService('airport-subpages');
        this.pageViewService.registerView('0', () => (FSComponent.buildComponent(AirportPage1, { title: 'subpage-1', bus: this.props.bus, loader: this.props.loader, fms: this.props.fms })));
        this.popUpViewService = new PopUpViewService('airport-pop-ups');
        this.popUpViewService.registerView('MC_Bal_Popup', () => (FSComponent.buildComponent(McBalPopUp, { title: 'mc-bal-pop-up', bus: this.props.bus, menuSystem: this.props.menuSystem, autoCloseDelay: 10000 })));
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        const mapSettingsManager = MapUserSettings.getManager(this.props.bus);
        mapSettingsManager.whenSettingChanged('mapRange').handle(this.handleMapRange);
        this.onOpen.on(() => {
            this.pageViewService.openByIndex(0);
            this.props.menuSystem.pushMenu('AirportModeMenu');
        });
        this.onClose.on(() => {
            this.pageViewService.clearStack(true);
            this.popUpViewService.clearStack(true);
        });
        this.props.bus
            .getSubscriber()
            .on('AirportModeMenuEvent')
            .handle((event) => {
            if (event == AirportModeActionEvent.MC_BAL)
                this.popUpViewService.openByName('MC_Bal_Popup');
        });
        this.props.bus
            .getSubscriber()
            .on('mac_cready_setting')
            .withPrecision(1)
            .handle((v) => this.mcSetting.set(v));
    }
    onInteractionEvent(event) {
        if (this.popUpViewService.hasPopUpOpen)
            return this.popUpViewService.onInteractionEvent(event);
        return this.pageViewService.onInteractionEvent(event);
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page airportmode' },
            FSComponent.buildComponent("div", { id: 'airport-subpages', class: 'page-subpage' }),
            FSComponent.buildComponent("div", { id: 'airport-pop-ups', class: 'page-pop-up' }),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("img", { class: 'map-north-icon', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/map/ICON_MAP_NORTH.svg' }),
                FSComponent.buildComponent("div", { class: 'mac-cready-setting' }, this.mcSetting),
                FSComponent.buildComponent("div", { class: 'map-range' },
                    this.mapRange,
                    "km"),
                /* FSComponent.buildComponent("div", { class: 'map' }, this.mapSystem.map) */ )));
    }
}

var DmsDirection;
(function (DmsDirection) {
    DmsDirection["NORTH"] = "N";
    DmsDirection["SOUTH"] = "S";
    DmsDirection["WEST"] = "W";
    DmsDirection["EAST"] = "E";
})(DmsDirection || (DmsDirection = {}));

/* eslint-disable jsdoc/check-indentation */
/**
 * A utility class for creating duration formatters.
 *
 * Each duration formatter is a function which generates output strings from input duration values. The formatting
 * behavior of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+'], ('-' | '–')`. Each sign fragment is replaced with
 * a character representing the sign of the input. The negative sign character is defined by the last character of
 * the fragment definition. The positive sign character (`+`) is included in the replacement if and only if it
 * appears in the fragment definition.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`
 * where `x = 'H' | 'M' | 'S' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with the numeric value of the
 * duration in hours, minutes, or seconds, depending on which character is used for `x`. With uppercase letters, the
 * entire portion of the input value is used. With lowercase letters, only the portion of the input value that does not
 * divide evenly into the next smallest unit is used (for hours, which is the largest unit, there is no difference
 * between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to hours-minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss}');
 * console.log(formatter(3616000));  // 1:00:16
 * console.log(formatter(36016900)); // 10:00:16
 *
 * @example <caption>Formatting to hours-minutes-seconds with decimal precision</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss.s(s)}');
 * console.log(formatter(3600000)); // 1:00:00.0
 * console.log(formatter(3600550)); // 1:00:00.55
 *
 * @example <caption>Formatting to minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{MM}:{ss}');
 * console.log(formatter(600000));  // 10:00
 * console.log(formatter(4200000)); // 70:00.
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DurationFormatter.create('{-}{h}:{mm}');
 * console.log(formatter(3600000));  // 1:00
 * console.log(formatter(-3600000)); // -1:00
 *
 * const formatterWithPositiveSign = DurationFormatter.create('{+-}{h}:{mm}');
 * console.log(formatterWithPositiveSign(3600000));  // +1:00
 */
class DurationFormatter {
    /**
     * Creates a function which formats durations, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param unit The unit type in which the input duration values are expressed.
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as numeric values, to strings.
     */
    static create(format, unit, nanString = 'NaN') {
        const builder = DurationFormatter.createBuilder(format);
        return (duration) => {
            if (isNaN(duration)) {
                return nanString;
            }
            return builder.reduce((string, part) => string + part(duration, unit), '');
        };
    }
    /**
     * Creates a function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format, nanString = 'NaN') {
        const builder = DurationFormatter.createBuilder(format);
        return (duration) => {
            if (duration.isNaN()) {
                return nanString;
            }
            return builder.reduce((string, part) => string + part(duration.number, duration.unit), '');
        };
    }
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @returns An output string builder which conforms to the specified format template.
     */
    static createBuilder(format) {
        const split = format.split(DurationFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DurationFormatter.FORMAT_REGEXP)) {
                return DurationFormatter.parseFragment(string.substring(1, string.length - 1));
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    static parseFragment(fragment) {
        var _a, _b, _c, _d;
        const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
        if (signMatch) {
            const negSign = signMatch[0][signMatch[0].length - 1];
            const posSign = signMatch[0].length === 2 ? '+' : '';
            return (duration) => {
                return duration < 0 ? negSign : posSign;
            };
        }
        const numMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
        if (!numMatch) {
            return () => '';
        }
        const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[numMatch[2]];
        const pad = numMatch[1].length;
        const dropZero = !!numMatch[3];
        const formatLeftFunc = dropZero
            ? ((input) => {
                const rounded = Math.floor(input);
                return rounded === 0 ? '' : rounded.toString().padStart(pad, '0');
            })
            : ((input) => Math.floor(input).toString().padStart(pad, '0'));
        if (numMatch[4]) {
            if (numMatch[4].length === 1) {
                return (duration, unit) => {
                    const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
                    const decimal = converted % 1;
                    return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_b = (_a = numMatch[5]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            const unforcedDecimalPlaces = (_d = (_c = numMatch[6]) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            return (duration, unit) => {
                const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
                const decimal = converted % 1;
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            return (duration, unit) => {
                return formatLeftFunc(unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod);
            };
        }
    }
}
DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DurationFormatter.SIGN_FRAGMENT_REGEX = /^\+?[-–]$/;
DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ['h']: { unit: UnitType.HOUR, mod: Infinity },
    ['m']: { unit: UnitType.MINUTE, mod: 60 },
    ['s']: { unit: UnitType.SECOND, mod: 60 },
    ['H']: { unit: UnitType.HOUR, mod: Infinity },
    ['M']: { unit: UnitType.MINUTE, mod: Infinity },
    ['S']: { unit: UnitType.SECOND, mod: Infinity }
};
DurationFormatter.NUM_FRAGMENT_ROUND_FUNCS = {
    ['+']: Math.ceil,
    ['-']: Math.floor,
    ['~']: Math.round
};

/* eslint-disable max-len */
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Numeric fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w' | 'H' | 'h' | 'm' | 's'`.
 * Each numeric fragment is replaced with a numeric representation of the month (`M`), day of month (`d`), day of week
 * (`w`), hour-24 (`H`), hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x`
 * characters in the definition controls the number of leading zeroes with which the output will be padded.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 */
class DateTimeFormatter {
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format, options) {
        const optsToUse = Object.assign({}, DateTimeFormatter.DEFAULT_OPTIONS, options);
        const builder = DateTimeFormatter.createBuilder(format, optsToUse);
        const date = new Date();
        return (time) => {
            if (isNaN(time)) {
                return optsToUse.nanString;
            }
            date.setTime(time);
            return builder.reduce((string, part) => string + part(date), '');
        };
    }
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    static createBuilder(format, options) {
        const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
                return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    static parseFragment(fragment, options) {
        const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
        if (match) {
            if (match[1]) {
                return DateTimeFormatter.parseNumFragment(match);
            }
            else if (match[4]) {
                return DateTimeFormatter.parseYearFragment(match);
            }
            else if (match[5]) {
                return DateTimeFormatter.parseMonthFragment(match, options);
            }
            else if (match[6]) {
                return DateTimeFormatter.parseDayFragment(match, options);
            }
            else if (match[7]) {
                return DateTimeFormatter.parseAMPMFragment(match);
            }
        }
        return () => '';
    }
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    static parseNumFragment(match) {
        const numGetter = DateTimeFormatter.NUM_GETTERS[match[3]];
        const pad = match[2].length;
        return (date) => {
            return numGetter(date).toString().padStart(pad, '0');
        };
    }
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    static parseYearFragment(match) {
        if (match[4].length === 2) {
            // YY
            return (date) => (date.getUTCFullYear() % 100).toString();
        }
        else {
            // YYYY
            return (date) => date.getUTCFullYear().toString();
        }
    }
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    static parseMonthFragment(match, options) {
        const isUpperCase = match[5][0] === 'M';
        if (match[5].length === 3) {
            // mon
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => text[date.getUTCMonth()];
        }
        else if (match[5].length === 4) {
            // mon.
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => {
                const month = date.getUTCMonth();
                return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? '' : '.'}`;
            };
        }
        else {
            // month
            const text = isUpperCase ? options.monthNames.map(str => str.toUpperCase()) : options.monthNames;
            return (date) => text[date.getUTCMonth()];
        }
    }
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    static parseDayFragment(match, options) {
        const isUpperCase = match[6][0] === 'D';
        if (match[6] === 'dy') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => text[date.getUTCDay()];
        }
        else if (match[6] === 'dy.') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => {
                const day = date.getUTCDay();
                return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? '' : '.'}`;
            };
        }
        else {
            // day
            const text = isUpperCase ? options.dayNames.map(str => str.toUpperCase()) : options.dayNames;
            return (date) => text[date.getUTCDay()];
        }
    }
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    static parseAMPMFragment(match) {
        const isUpperCase = match[7][0] === 'A';
        const usePeriod = match[7].length > 2;
        let text = usePeriod ? ['a.m.', 'p.m.'] : ['am', 'pm'];
        if (isUpperCase) {
            text = text.map(str => str.toUpperCase());
        }
        return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
}
DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DateTimeFormatter.FRAGMENT_REGEXP = /^(?:((([MdwHhms])+))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
DateTimeFormatter.NUM_GETTERS = {
    ['s']: (date) => date.getUTCSeconds(),
    ['m']: (date) => date.getUTCMinutes(),
    ['h']: (date) => date.getUTCHours() % 12,
    ['H']: (date) => date.getUTCHours(),
    ['w']: (date) => date.getUTCDay() + 1,
    ['d']: (date) => date.getUTCDate(),
    ['M']: (date) => date.getUTCMonth() + 1
};
DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    nanString: 'NaN'
};

var TimerModes;
(function (TimerModes) {
    TimerModes[TimerModes["UNDEFINED"] = 0] = "UNDEFINED";
    TimerModes[TimerModes["START"] = 1] = "START";
    TimerModes[TimerModes["STOP"] = 2] = "STOP";
    TimerModes[TimerModes["RESET"] = 3] = "RESET";
    TimerModes[TimerModes["PAUSE"] = 4] = "PAUSE";
})(TimerModes || (TimerModes = {}));
class Timer {
    constructor() {
        this.initTimer = 0;
        this.currentTimer = Subject.create(0);
        this.onPause = false;
        this._timerMode = TimerModes.UNDEFINED;
    }
    get timerMode() {
        return this._timerMode;
    }
    start(initialValue = 0) {
        if (!this.onPause) {
            this.initTimer = SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds') + initialValue;
        }
        this.intervalObj = setInterval(this.callback.bind(this), 500);
        this.onPause = false;
        this._timerMode = TimerModes.START;
    }
    stop() {
        clearInterval(this.intervalObj);
        this._timerMode = TimerModes.STOP;
    }
    pause() {
        clearInterval(this.intervalObj);
        this._timerMode = TimerModes.PAUSE;
        this.onPause = true;
    }
    reset() {
        this.initTimer = 0;
        this.currentTimer.set(0);
        this._timerMode = TimerModes.RESET;
    }
    callback() {
        this.currentTimer.set(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'number') - this.initTimer);
    }
    get() {
        return this.currentTimer;
    }
    set(timer) {
        this.currentTimer.set(timer);
    }
}

function degreeToCardinal(coordinate, degree, precision) {
    if (coordinate === 'lat') {
        return `${Math.sign(degree) ? 'N' : 'S'}${Math.abs(degree).toFixed(precision)}`;
    }
    else {
        return `${Math.sign(degree) ? 'E' : 'W'}${Math.abs(degree).toFixed(precision)}`;
    }
}
function altitudeToFL(altitude) {
    return (altitude / 100).toFixed(0).padStart(3, '0');
}

class InfoMode extends GuiDialog {
    constructor(props) {
        super(props);
        this.DURATION_FORMATTER = DurationFormatter.create('{HH}:{mm}:{ss}', UnitType.SECOND, '--:--:--');
        this.DATE_FORMATTER = DateTimeFormatter.create('{HH}:{mm}:{ss} - {dd}.{MM}.{YY}', {
            nanString: '--:--:-- - --.--.--',
        });
        this.displayedTime = Subject.create('');
        this.displayedGPSLatitude = Subject.create('');
        this.displayedGPSLongitude = Subject.create('');
        this.displayedIndicatedAltitude = Subject.create('');
        this.displayedPressureAltitude = Subject.create('');
        this.displayedHeightDifference = Subject.create('0m 0ft');
        this.displayedSunriseTime = Subject.create('');
        this.displayedSunsetTime = Subject.create('');
        this.timer = new Timer();
        this.clockEventsSub = this.props.bus
            .getSubscriber()
            .on('simTime')
            .atFrequency(2, true)
            .handle((time) => {
            this.displayedTime.set(this.DATE_FORMATTER(time));
        });
        this.props.bus
            .getSubscriber()
            .on('gps-position')
            .atFrequency(1)
            .handle((lla) => {
            this.displayedGPSLatitude.set(degreeToCardinal('lat', lla.lat, 6));
            this.displayedGPSLongitude.set(degreeToCardinal('lon', lla.long, 6));
        });
        this.props.bus
            .getSubscriber()
            .on('alt')
            .atFrequency(1)
            .handle((altitude) => this.displayedIndicatedAltitude.set(`${UnitType.FOOT.convertTo(altitude, UnitType.METER).toFixed(0)}m  ${altitude.toFixed(0)}ft`));
        this.props.bus
            .getSubscriber()
            .on('pressure_alt')
            .atFrequency(1)
            .handle((altitude) => {
            this.displayedPressureAltitude.set(`${UnitType.FOOT.convertTo(altitude, UnitType.METER).toFixed(0)}m  FL${altitudeToFL(altitude)}`);
        });
        this.props.bus
            .getSubscriber()
            .on('WatchActionEvent')
            .handle((event) => this.handleWatchEvent(event));
        this.props.bus
            .getSubscriber()
            .on('zulu_sunrise_time')
            .whenChanged()
            .handle((sunriseTime) => {
            this.displayedSunriseTime.set(this.DURATION_FORMATTER(sunriseTime));
        });
        this.props.bus
            .getSubscriber()
            .on('zulu_sunset_time')
            .whenChanged()
            .handle((sunsetTime) => {
            this.displayedSunsetTime.set(this.DURATION_FORMATTER(sunsetTime));
        });
        this.props.bus
            .getSubscriber()
            .on('heightDifference')
            .withPrecision(0)
            .handle((heightDifference) => this.displayedHeightDifference.set(`${UnitType.FOOT.convertTo(heightDifference, UnitType.METER).toFixed(0)}m  ${heightDifference.toFixed(0)}ft`));
        this.updateTimeLine();
        this.onOpen.on(() => this.props.menuSystem.pushMenu('infoMenu'));
    }
    onAfterRender(node) {
        super.onAfterRender(node);
    }
    handleWatchEvent(event) {
        switch (event) {
            case WatchActionEvent.START:
                this.timer.start();
                break;
            case WatchActionEvent.STOP:
                this.timer.stop();
                break;
            case WatchActionEvent.RESET:
                this.timer.reset();
                break;
        }
        this.updateTimeLine();
    }
    updateTimeLine() {
        if (this.timer.timerMode == TimerModes.START || this.timer.timerMode == TimerModes.STOP) {
            this.clockEventsSub.pause();
            this.timer.get().sub((value) => this.displayedTime.set(this.timerFormatter(value)));
        }
        else {
            this.clockEventsSub.resume();
            this.timer.get().unsub((value) => this.displayedTime.set(this.timerFormatter(value)));
        }
    }
    timerFormatter(value) {
        const date = new Date(0);
        date.setSeconds(value);
        return `Stopwatch: ${date.toISOString().substring(11, 19)}`;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'page-info' },
                    "FILE: OK/7",
                    FSComponent.buildComponent("br", null),
                    FSComponent.buildComponent("div", { class: 'space' }),
                    this.displayedTime,
                    FSComponent.buildComponent("br", null),
                    this.displayedGPSLatitude,
                    "\u00B0 - ",
                    this.displayedGPSLongitude,
                    "\u00B0",
                    FSComponent.buildComponent("br", null),
                    FSComponent.buildComponent("div", { class: 'space' }),
                    "Altitude: ",
                    this.displayedIndicatedAltitude,
                    FSComponent.buildComponent("br", null),
                    "Fl.Level: ",
                    this.displayedPressureAltitude,
                    FSComponent.buildComponent("br", null),
                    "Height: ",
                    this.displayedHeightDifference,
                    FSComponent.buildComponent("br", null),
                    "Sun: ",
                    this.displayedSunriseTime,
                    " - ",
                    this.displayedSunsetTime))));
    }
}

class NearestAirportPageController {
    constructor(loader, store, NB_OF_NEAREST_ITEMS, onNearestSearchInit) {
        this.loader = loader;
        this.store = store;
        this.NB_OF_NEAREST_ITEMS = NB_OF_NEAREST_ITEMS;
        this.isSearchQueued = false;
        this.latestPPos = new GeoPoint(0, 0);
        this.nearestAirports = [];
        this.isSearchBusy = false;
        this.loader.startNearestSearchSession(FacilitySearchType.Airport).then((session) => {
            this.nrstSearchSession = session;
            onNearestSearchInit && onNearestSearchInit();
        });
    }
    enqueueUpdate() {
        this.isSearchQueued = true;
    }
    dequeueUpdate() {
        if (!this.nrstSearchSession || !this.isSearchQueued || this.isSearchBusy) {
            return;
        }
        this.isSearchQueued = false;
        this.doUpdate();
    }
    async doUpdate() {
        if (!this.nrstSearchSession) {
            return;
        }
        this.isSearchBusy = true;
        const ppos = this.store.ppos.get();
        const results = await this.nrstSearchSession.searchNearest(ppos.lat, ppos.long, NearestAirportPageController.SEARCH_RADIUS, this.NB_OF_NEAREST_ITEMS);
        this.nearestAirports = this.nearestAirports.filter((airport) => !results.removed.includes(airport.icao));
        const newAirports = await Promise.all(results.added.map((icao) => this.loader.getFacility(FacilityType.Airport, icao)));
        this.latestPPos.set(ppos.lat, ppos.long);
        const course = this.store.course.get();
        const distances = this.nearestAirports.map((airport) => this.latestPPos.distance(airport));
        for (let i = 0; i < newAirports.length; i++) {
            let insert = false;
            const newAirport = newAirports[i];
            const dis = this.latestPPos.distance(newAirport);
            for (let j = 0; j < this.nearestAirports.length; j++) {
                if (dis < distances[j]) {
                    insert = true;
                }
                else if (dis === distances[j]) {
                    const courseDevToNewAirport = Math.abs(NavMath.diffAngle(this.latestPPos.bearingTo(newAirport), course));
                    const courseDevToExistingAirport = Math.abs(NavMath.diffAngle(this.latestPPos.bearingTo(this.nearestAirports[j]), course));
                    insert = courseDevToNewAirport < courseDevToExistingAirport;
                }
                if (insert) {
                    this.nearestAirports.splice(j, 0, newAirport);
                    distances.splice(j, 0, dis);
                    break;
                }
            }
            if (!insert) {
                this.nearestAirports.push(newAirport);
                distances.push(dis);
            }
        }
        if (this.isSearchQueued) {
            this.isSearchBusy = false;
            this.dequeueUpdate();
            return;
        }
        const gs = this.store.groundSpeed.get();
        this.store.displayedAirports.set(this.nearestAirports.map((airport) => {
            const bearing = MagVar.trueToMagnetic(this.latestPPos.bearingTo(airport), this.latestPPos);
            const distance = UnitType.GA_RADIAN.convertTo(this.latestPPos.distance(airport), UnitType.NMILE);
            const longestRunwayIndex = airport.runways.reduce((prevIndex, curr, index, arr) => {
                if (prevIndex === -1) {
                    return index;
                }
                const prev = arr[prevIndex];
                const currLength = curr.length - curr.primaryThresholdLength - curr.secondaryThresholdLength;
                const prevLength = prev.length - prev.primaryThresholdLength - prev.secondaryThresholdLength;
                if (currLength > prevLength) {
                    return index;
                }
                if (currLength === prevLength) {
                    const currPrimaryName = curr.designation.split('-')[0].padStart(2, '0') +
                        RunwayUtils.getDesignatorLetter(curr.designatorCharPrimary);
                    const prevPrimaryName = prev.designation.split('-')[0].padStart(2, '0') +
                        RunwayUtils.getDesignatorLetter(prev.designatorCharPrimary);
                    if (currPrimaryName.localeCompare(prevPrimaryName) < 0) {
                        return index;
                    }
                }
                return prevIndex;
            }, -1);
            const eteHours = distance / Math.max(150, gs);
            return {
                airport,
                runway: longestRunwayIndex >= 0
                    ? RunwayUtils.getOneWayRunways(airport.runways[longestRunwayIndex], longestRunwayIndex)[0]
                    : null,
                bearing,
                distance,
                ete: eteHours,
            };
        }));
        this.isSearchBusy = false;
    }
}
NearestAirportPageController.SEARCH_RADIUS = UnitType.NMILE.convertTo(50, UnitType.METER);

class NearestAirportStore {
    constructor(bus) {
        this.bus = bus;
        this.displayedAirports = ArraySubject.create([]);
        this.ppos = ConsumerSubject.create(this.bus.getSubscriber().on('gps-position'), new LatLongAlt());
        this.course = ConsumerSubject.create(this.bus.getSubscriber().on('track_deg_true'), 0);
        this.groundSpeed = ConsumerSubject.create(this.bus.getSubscriber().on('ground_speed'), 0);
    }
    destroy() {
        this.ppos.destroy();
        this.course.destroy();
        this.groundSpeed.destroy();
    }
}
const defaultNearestAirportData = {
    airport: null,
    bearing: 0,
    distance: 0,
    ete: 0,
    runway: null,
};

class NearItemList extends DisplayComponent {
    constructor(props) {
        super(props);
        this.nearItemArraySubject = [];
        for (let i = 0; i < this.props.nb_of_items; i++) {
            this.nearItemArraySubject.push(Subject.create(defaultNearestAirportData));
        }
    }
    onAfterRender() {
        this.props.dataref.sub((index, type, item) => {
            let maxIndex = -1;
            if (item !== undefined) {
                item.map((value, i) => {
                    this.nearItemArraySubject[i].set(value);
                    maxIndex = i;
                });
                for (let i = maxIndex + 1; i < this.props.nb_of_items; i++) {
                    this.nearItemArraySubject[i].set(defaultNearestAirportData);
                    this.nearItemArraySubject[i].notify();
                }
            }
        });
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'near list', ref: this.props.ref },
            FSComponent.buildComponent("div", { class: 'near-tab' },
                FSComponent.buildComponent("div", { class: 'name' }, "Name"),
                FSComponent.buildComponent("div", { class: 'altitude' }, "Alt"),
                FSComponent.buildComponent("div", { class: 'distance' }, "Dis."),
                FSComponent.buildComponent("div", { class: 'bearing' }, "Brg")),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[0] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[1] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[2] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[3] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[4] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[5] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[6] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[7] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[8] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[9] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[10] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[11] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[12] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[13] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[14] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[15] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[16] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[17] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[18] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[19] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[20] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[21] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[22] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[23] }),
            FSComponent.buildComponent(NearItem, { dataref: this.nearItemArraySubject[24] })));
    }
}
class NearItem extends ASUiControls {
    constructor(props) {
        super(props);
        this.ICAO_RGX = /\w{2,}/;
        this.nearItemRef = FSComponent.createRef();
        this.FOCUS_CLASS = 'highlight';
        this.icon = Subject.create('');
        this.icao = Subject.create('');
        this.altitude = Subject.create('');
        this.distance = Subject.create('');
        this.bearing = Subject.create('');
        this.formatNearAirportData = (item) => {
            var _a;
            if (item.airport !== null) {
                this.setDisabled(false);
                this.icon.set('/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/near/ICON_GLIDERS_AIRPORT.svg');
                const icao = this.ICAO_RGX[Symbol.match]((_a = item.airport) === null || _a === void 0 ? void 0 : _a.icao);
                if (icao !== null) {
                    this.icao.set(icao[0]);
                }
                else {
                    this.setDisabled(true);
                }
                this.altitude.set(UnitType.FOOT.convertTo(item.airport.altitude, UnitType.METER).toFixed(1));
                this.distance.set(UnitType.NMILE.convertTo(item.distance, UnitType.KILOMETER).toFixed(1));
                this.bearing.set(item.bearing.toFixed(0));
            }
            else {
                this.setDisabled(true);
            }
        };
        if (this.props.dataref !== undefined) {
            this.props.dataref.sub(this.formatNearAirportData);
        }
    }
    onAfterRender(node) {
        this.setDisabled(true);
    }
    onFocused() {
        this.nearItemRef.instance.classList.add(this.FOCUS_CLASS);
    }
    onBlurred() {
        this.nearItemRef.instance.classList.remove(this.FOCUS_CLASS);
    }
    setDisabled(isDisabled) {
        super.setDisabled(isDisabled);
        if (isDisabled) {
            this.nearItemRef.instance.classList.add('disabled');
        }
        else {
            this.nearItemRef.instance.classList.remove('disabled');
        }
    }
    render() {
        return (FSComponent.buildComponent("div", { ref: this.nearItemRef, class: 'near-item' },
            FSComponent.buildComponent("img", { src: this.icon }),
            FSComponent.buildComponent("p", { class: 'near-item-name' }, this.icao),
            FSComponent.buildComponent("p", { class: 'near-item-altitude' },
                this.altitude,
                "m"),
            FSComponent.buildComponent("p", { class: 'near-item-distance' },
                this.distance,
                "km"),
            FSComponent.buildComponent("p", { class: 'near-item-bearing' },
                this.bearing,
                "\u00B0")));
    }
}

class NearMode extends GuiDialog {
    constructor(props) {
        super(props);
        this.nearestListRef = FSComponent.createRef();
        this.NB_OF_NEAREST_ITEMS = 25;
        this.store = new NearestAirportStore(this.props.bus);
        this.controller = new NearestAirportPageController(this.props.loader, this.store, this.NB_OF_NEAREST_ITEMS, this.onNearestSearchInit.bind(this));
        this.isPaused = true;
        this.focusedIndex = 0;
    }
    onNearestSearchInit() {
        if (!this.isPaused) {
            this.controller.dequeueUpdate();
        }
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('NearMenu'));
        this.props.bus
            .getSubscriber()
            .on('NearMenuEvent')
            .handle((event) => {
            var _a;
            switch (event) {
                case NearActionsEvent.GOTO:
                    const icao = (_a = this.store.displayedAirports.getArray()[this.focusedIndex].airport) === null || _a === void 0 ? void 0 : _a.icao;
                    if (icao) {
                        this.props.fms.createDirectToRandom(icao);
                        this.props.viewService.openByName('AirportMode');
                        this.props.bus.pub('direct_to_target_updated', false, true);
                    }
                    break;
            }
        });
        setInterval(() => this.updateAirports(), 100);
    }
    updateAirports() {
        this.controller.enqueueUpdate();
        this.controller.dequeueUpdate();
    }
    onScroll(direction) {
        super.onScroll(direction);
        this.nearestListRef.instance.children[this.focusedIndex].scrollIntoView();
        return true;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent(NearItemList, { dataref: this.store.displayedAirports, nb_of_items: this.NB_OF_NEAREST_ITEMS, ref: this.nearestListRef }))));
    }
}

class ListItem extends ASUiControls {
    constructor(props) {
        var _a;
        super(props);
        this.itemRef = FSComponent.createRef();
        this.FOCUS_CLASS = 'highlight';
        this.page = (_a = this.props.page) !== null && _a !== void 0 ? _a : '';
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        if (this.props.disabled) {
            this.itemRef.instance.classList.add('disabled');
        }
    }
    onFocused() {
        this.itemRef.instance.classList.add(this.FOCUS_CLASS);
    }
    onBlurred() {
        this.itemRef.instance.classList.remove(this.FOCUS_CLASS);
    }
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { ref: this.itemRef, class: 'list-item' },
            FSComponent.buildComponent("img", { src: (_a = this.props.icon) !== null && _a !== void 0 ? _a : '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/setup/ICON_GLIDERS_NOICON.svg' }),
            FSComponent.buildComponent("label", null, this.props.title)));
    }
}

class SetupMode extends GuiDialog {
    constructor() {
        super(...arguments);
        this.setupItemsElement = FSComponent.createRef();
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('setupMenu'));
        this.props.bus
            .getSubscriber()
            .on('SetupMenuEvent')
            .handle(() => {
            if (this.registeredControls !== undefined) {
                const item = this.registeredControls[this.focusedIndex];
                this.props.viewService.openByName(item.page);
            }
        });
    }
    onScroll(direction) {
        super.onScroll(direction);
        this.setupItemsElement.instance.children[this.focusedIndex].scrollIntoView();
        return true;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { ref: this.setupItemsElement, class: 'setup list' },
                    FSComponent.buildComponent(ListItem, { title: 'QNH and RES', icon: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/setup/ICON_GLIDERS_QNHANDRES.svg', page: 'QNHAndResPage' }),
                    FSComponent.buildComponent(ListItem, { title: 'Flight Recorder', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Weight and Balance', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Vario Parameters', page: 'VarioParametersPage', icon: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/setup/ICON_GLIDERS_VARIO_PARAMETERS.svg' }),
                    FSComponent.buildComponent(ListItem, { title: 'Display', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Flies And Transfer', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Graphics', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Sounds', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Observation Zones', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Optimization', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Warnings', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Units', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Hardware', page: 'HardwarePage' }),
                    FSComponent.buildComponent(ListItem, { title: 'Polar and Glider', disabled: false, page: 'PolarPage', icon: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/setup/ICON_GLIDERS_GLIDERANDTRACK.svg' }),
                    FSComponent.buildComponent(ListItem, { title: 'Profiles and Pilots', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'LXNAV Connect', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Language', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Password', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Admin mode', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'About', page: 'AboutPage', icon: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/setup/ICON_GLIDERS_ABOUT.svg' })))));
    }
}

class AboutPage extends GuiDialog {
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('AboutMenu'));
        this.props.bus
            .getSubscriber()
            .on('AboutMenuEvent')
            .handle((event) => {
            switch (event) {
                case ValidationActionsEvent.CLOSE:
                    this.props.viewService.openByName('SetupMode');
                    break;
            }
        });
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("img", { src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/logo/ICON_GLIDERS_LOGO.svg', class: 'img-about' }),
                FSComponent.buildComponent("div", { class: 'about-page' },
                    FSComponent.buildComponent("h1", null, "AS8030 Gen: 3"),
                    FSComponent.buildComponent("h1", null, "SN: 5IQD (108030)"),
                    FSComponent.buildComponent("h2", null, "Version 8.04b"),
                    FSComponent.buildComponent("p", null,
                        "Storage: ",
                        FSComponent.buildComponent("br", null),
                        "Internal: 174.0 GB free, 930.9 GB total",
                        FSComponent.buildComponent("br", null),
                        "SD: 174.0 GB free, 930.9 GB total",
                        FSComponent.buildComponent("br", null),
                        FSComponent.buildComponent("br", null),
                        "Installed Terrain:",
                        FSComponent.buildComponent("br", null),
                        "CIT V1, CIT V2 (used)",
                        FSComponent.buildComponent("br", null))))));
    }
}

class HardwarePage extends GuiDialog {
    constructor() {
        super(...arguments);
        this.itemsElement = FSComponent.createRef();
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('HardwareMenu'));
        this.props.bus
            .getSubscriber()
            .on('HardwareMenuEvent')
            .handle((event) => {
            switch (event) {
                case ValidationActionsEvent.CLOSE:
                    this.props.viewService.openByName('SetupMode');
                    break;
                case ValidationActionsEvent.SELECT:
                    if (this.registeredControls !== undefined) {
                        const item = this.registeredControls[this.focusedIndex];
                        if (item === null || item === void 0 ? void 0 : item.page)
                            this.props.viewService.openByName(item.page);
                    }
                    break;
            }
        });
    }
    onScroll(direction) {
        super.onScroll(direction);
        this.itemsElement.instance.children[this.focusedIndex].scrollIntoView();
        return true;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { ref: this.itemsElement, class: 'list' },
                    FSComponent.buildComponent(ListItem, { title: 'Variometer', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'AS8 indicator Sn:04269', page: 'VarioIndicatorPage' }),
                    FSComponent.buildComponent(ListItem, { title: 'Flarm & ADS-B', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Compass', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Rear Seat', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Remote stick', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'AHRS', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'NMEA Output', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Engine', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Network', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Flaps', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Battery Types', disabled: true }),
                    FSComponent.buildComponent(ListItem, { title: 'Analog Inputs', disabled: true })))));
    }
}

class Field extends ASUiControls {
    constructor(props) {
        var _a;
        super(props);
        this.elementRef = FSComponent.createRef();
        this.inputRef = FSComponent.createRef();
        this.FOCUS_CLASS = 'highlight';
        this.EDIT_CLASS = 'edit';
        this.props.orientation = (_a = this.props.orientation) !== null && _a !== void 0 ? _a : 'vertical';
    }
    onAfterRender(node) {
        var _a;
        super.onAfterRender(node);
        if ((_a = this.props.focused) !== null && _a !== void 0 ? _a : false) {
            this.onStartEdit();
        }
    }
    redrawCSSonEdit() {
        this.inputRef.instance.style.display = '';
        setTimeout(() => {
            this.inputRef.instance.style.display = 'inherit';
        }, 1);
    }
    onFocused() {
        this.inputRef.instance.classList.add(this.FOCUS_CLASS);
    }
    onBlurred() {
        this.inputRef.instance.classList.remove(this.FOCUS_CLASS);
    }
    onDisabled() {
        this.inputRef.instance.disabled = true;
    }
    onEnabled() {
        this.inputRef.instance.disabled = false;
    }
    onInteractionEvent(event) {
        switch (event) {
            case ASEvents.BOTTOM_RIGHT_INC:
                return this.onBottomRightInc();
            case ASEvents.BOTTOM_RIGHT_DEC:
                return this.onBottomRightDec();
            case ASEvents.BOTTOM_LEFT_INC:
                return this.onBottomLeftInc();
            case ASEvents.BOTTOM_LEFT_DEC:
                return this.onBottomLeftDec();
        }
        return true;
    }
}

class CheckBoxField extends Field {
    constructor() {
        super(...arguments);
        this.displayValue = Subject.create('');
        this.checkedRef = FSComponent.createRef();
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.props.checked.sub((v) => {
            this.checkedRef.instance.style.display = v ? 'inherit' : 'none';
        }, true);
    }
    onStartEdit() {
        this.props.checked.set(!this.props.checked.get());
        return false;
    }
    onCancelEdit() {
        this.props.checked.set(!this.props.checked.get());
        return false;
    }
    onValidateEdit() {
        return false;
    }
    onBottomRightInc() {
        return true;
    }
    onBottomRightDec() {
        return true;
    }
    onBottomLeftInc() {
        return true;
    }
    onBottomLeftDec() {
        return true;
    }
    onFocused() {
        this.elementRef.instance.classList.add(this.FOCUS_CLASS);
    }
    onBlurred() {
        this.elementRef.instance.classList.remove(this.FOCUS_CLASS);
    }
    onDisabled() {
        this.elementRef.instance.classList.add('disabled');
    }
    onEnabled() {
        this.elementRef.instance.classList.remove('disabled');
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'input-box-checkbox', ref: this.elementRef },
            FSComponent.buildComponent("svg", { height: '18px', width: '18px', viewBox: '0 0 20 20' },
                FSComponent.buildComponent("rect", { x: '2.5', y: '2.5', fill: 'transparent', stroke: 'white', width: '15', height: '15' }),
                FSComponent.buildComponent("g", { ref: this.checkedRef },
                    FSComponent.buildComponent("path", { d: 'M 4 10 C 5 11 7 13 8 15 C 10 10 12 7 16 2', stroke: 'white', fill: 'transparent', "stroke-width": '2.5px', "stroke-linecap": 'round' }))),
            FSComponent.buildComponent("div", { class: 'input-box-label' }, this.props.label)));
    }
}

class TextListField extends Field {
    constructor() {
        super(...arguments);
        this.selectedItem = Subject.create(0);
        this.displayValue = Subject.create('');
        this.beforeEditItem = this.selectedItem.get();
        this.updateDisplayValue = () => {
            var _a;
            this.displayValue.set((_a = this.props.data.tryGet(this.selectedItem.get())) !== null && _a !== void 0 ? _a : 'N/A');
        };
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.selectedItem.sub(this.updateDisplayValue, true);
        this.props.data.sub(this.updateDisplayValue, true);
        this.props.dataRef.sub((v) => {
            this.selectedItem.set(v);
        }, true);
    }
    onStartEdit() {
        if (!this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.add(this.EDIT_CLASS);
            this.redrawCSSonEdit();
            this.beforeEditItem = this.selectedItem.get();
        }
        return true;
    }
    onValidateEdit() {
        if (this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.remove(this.EDIT_CLASS);
            this.redrawCSSonEdit();
        }
        return false;
    }
    onCancelEdit() {
        if (this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.remove(this.EDIT_CLASS);
            this.redrawCSSonEdit();
            this.updateDataRef(0, this.beforeEditItem);
        }
        return false;
    }
    updateDataRef(increment, forcedValue) {
        const newValue = forcedValue !== null && forcedValue !== void 0 ? forcedValue : this.props.dataRef.get() + increment;
        this.props.dataRef.set(Utils.Clamp(newValue, 0, this.props.data.length - 1));
        return true;
    }
    onBottomRightInc() {
        return this.updateDataRef(-1);
    }
    onBottomRightDec() {
        return this.updateDataRef(1);
    }
    onBottomLeftInc() {
        return this.updateDataRef(-3);
    }
    onBottomLeftDec() {
        return this.updateDataRef(3);
    }
    render() {
        return (FSComponent.buildComponent("div", { class: `input-box ${this.props.orientation}`, ref: this.elementRef },
            this.props.label ? FSComponent.buildComponent("div", { class: 'input-box-label' }, this.props.label) : '',
            FSComponent.buildComponent("input", { type: 'text', class: 'input-box-text', name: this.props.name, ref: this.inputRef, value: this.displayValue })));
    }
}

class ValueField extends Field {
    constructor(props) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(props);
        this.displayValue = Subject.create('');
        this.beforeEditValue = this.props.data.get();
        this.decimals = (_a = props.decimals) !== null && _a !== void 0 ? _a : 0;
        this.min = (_b = props.min) !== null && _b !== void 0 ? _b : -Infinity;
        this.max = (_c = props.max) !== null && _c !== void 0 ? _c : +Infinity;
        this.unit = (_d = props.unit) !== null && _d !== void 0 ? _d : '';
        this.prefix = (_e = props.prefix) !== null && _e !== void 0 ? _e : '';
        this.smallStep = (_f = props.smallStep) !== null && _f !== void 0 ? _f : 1;
        this.bigStep = (_g = props.bigStep) !== null && _g !== void 0 ? _g : 10;
        this.updateDisplayValue(this.props.data.get());
        this.props.data.sub((value) => this.updateDisplayValue(value));
    }
    onAfterRender(node) {
        super.onAfterRender(node);
    }
    onStartEdit() {
        if (!this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.add(this.EDIT_CLASS);
            this.redrawCSSonEdit();
            this.beforeEditValue = this.props.data.get();
        }
        return true;
    }
    onValidateEdit() {
        if (this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.remove(this.EDIT_CLASS);
            this.redrawCSSonEdit();
        }
        return false;
    }
    onCancelEdit() {
        if (this.inputRef.instance.classList.contains(this.EDIT_CLASS)) {
            this.inputRef.instance.classList.remove(this.EDIT_CLASS);
            this.redrawCSSonEdit();
            this.props.data.set(this.beforeEditValue);
        }
        return false;
    }
    onBottomRightInc() {
        this.props.data.set(this.formatValue(this.props.data.get(), -this.smallStep));
        return true;
    }
    onBottomRightDec() {
        this.props.data.set(this.formatValue(this.props.data.get(), this.smallStep));
        return true;
    }
    onBottomLeftInc() {
        this.props.data.set(this.formatValue(this.props.data.get(), -this.bigStep));
        return true;
    }
    onBottomLeftDec() {
        this.props.data.set(this.formatValue(this.props.data.get(), this.bigStep));
        return true;
    }
    updateDisplayValue(value) {
        this.displayValue.set(`${this.prefix}${value.toFixed(this.decimals)}${this.unit}`);
    }
    formatValue(value, step = 0) {
        return Utils.Clamp(value + step, this.min, this.max);
    }
    render() {
        return (FSComponent.buildComponent("div", { class: `input-box ${this.props.orientation}`, ref: this.elementRef },
            this.props.label ? FSComponent.buildComponent("div", { class: 'input-box-label' }, this.props.label) : '',
            FSComponent.buildComponent("input", { type: 'text', class: 'input-box-text', name: this.props.name, ref: this.inputRef, value: this.displayValue })));
    }
}

class NavBoxSetting extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.dataRef = Subject.create(Object.values(VarioIndicatorNavBoxSettingMode).indexOf(this.props.VarioIndicatorUserSettings.getSetting(this.props.settingName).get()));
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.dataRef.sub((v) => {
            this.props.VarioIndicatorUserSettings.getSetting(this.props.settingName).set(Object.values(VarioIndicatorNavBoxSettingMode)[v]);
        });
    }
    render() {
        return (FSComponent.buildComponent(TextListField, { data: ArraySubject.create(Object.values(VarioIndicatorNavBoxSettingMode)), name: this.props.settingName + '_Setting', label: this.props.label.get(), dataRef: this.dataRef }));
    }
}

class VarioIndicatorPage extends GuiDialog {
    constructor() {
        super(...arguments);
        this.userSettings = VarioIndicatorUserSettings.getManager(this.props.bus);
        this.varioNeedle = Subject.create(Object.values(VarioIndicatorNeedleSettingMode).indexOf(this.userSettings.getSetting('varioNeedle').get()));
        this.navBoxesDisplayed = Subject.create(this.userSettings.getSetting('navBoxesDisplayed').get());
        this.yellowBar = Subject.create(Object.values(VarioIndicatorYellowBarSettingMode).indexOf(this.userSettings.getSetting('yellowBar').get()));
        this.redDiamond = Subject.create(Object.values(VarioIndicatorRedDiamondSettingMode).indexOf(this.userSettings.getSetting('redDiamond').get()));
        this.sideBar = Subject.create(Object.values(VarioIndicatorSideBarSettingMode).indexOf(this.userSettings.getSetting('sideBar').get()));
        this.isMcSettingVisible = Subject.create(this.userSettings.getSetting('isMcSettingVisible').get());
        this.isScaleLinear = Subject.create(this.userSettings.getSetting('isScaleLinear').get() ? 0 : 1);
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('VarioIndicatorMenu'));
        this.props.bus
            .getSubscriber()
            .on('VarioIndicatorMenuEvent')
            .handle((event) => {
            switch (event) {
                case VarioIndicatorActionEvent.CLOSE:
                    this.props.viewService.openByName('HardwarePage');
                    break;
                case VarioIndicatorActionEvent.EDIT:
                    this.startFieldEdit();
                    break;
                case VarioIndicatorActionEvent.CANCEL:
                    this.cancelFieldEdit();
                    break;
                case VarioIndicatorActionEvent.OK:
                    this.validateFieldEdit();
                    break;
                case VarioIndicatorActionEvent.RESET_G:
                    break;
            }
        });
        this.varioNeedle.sub((v) => this.userSettings.getSetting('varioNeedle').set(Object.values(VarioIndicatorNeedleSettingMode)[v]));
        this.navBoxesDisplayed.pipe(this.userSettings.getSetting('navBoxesDisplayed'));
        this.yellowBar.sub((v) => this.userSettings.getSetting('yellowBar').set(Object.values(VarioIndicatorYellowBarSettingMode)[v]));
        this.redDiamond.sub((v) => this.userSettings.getSetting('redDiamond').set(Object.values(VarioIndicatorRedDiamondSettingMode)[v]));
        this.sideBar.sub((v) => this.userSettings.getSetting('sideBar').set(Object.values(VarioIndicatorSideBarSettingMode)[v]));
        this.isMcSettingVisible.pipe(this.userSettings.getSetting('isMcSettingVisible'));
        this.isScaleLinear.sub((v) => this.userSettings.getSetting('isScaleLinear').set(v == 0));
    }
    onScroll(direction) {
        var _a, _b;
        super.onScroll(direction);
        (_b = (_a = this.getChild(this.focusedIndex).elementRef) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.scrollIntoView(direction == 'backward');
        return true;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'vario-indicator-inputs' },
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(TextListField, { name: 'Vario needle', label: 'Vario needle', dataRef: this.varioNeedle, data: ArraySubject.create(Object.values(VarioIndicatorNeedleSettingMode)) }),
                        FSComponent.buildComponent(TextListField, { name: 'SC needle', label: 'SC needle', dataRef: Subject.create(0), data: ArraySubject.create(Object.values(VarioIndicatorNeedleSettingMode)), disabled: true })),
                    FSComponent.buildComponent("div", { class: 'row half-end' },
                        FSComponent.buildComponent(ValueField, { name: 'Navboxes', label: 'Navboxes displayed', max: 4, min: 1, bigStep: 1, data: this.navBoxesDisplayed, disabled: true })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(NavBoxSetting, { settingName: 'navBox1', label: Subject.create('First line'), VarioIndicatorUserSettings: this.userSettings }),
                        FSComponent.buildComponent(NavBoxSetting, { settingName: 'navBox2', label: Subject.create('Second line'), VarioIndicatorUserSettings: this.userSettings })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(NavBoxSetting, { settingName: 'navBox3', label: Subject.create('Third line'), VarioIndicatorUserSettings: this.userSettings }),
                        FSComponent.buildComponent(NavBoxSetting, { settingName: 'navBox4', label: Subject.create('Fourth line'), VarioIndicatorUserSettings: this.userSettings })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(TextListField, { name: 'Yellow Bar', dataRef: this.yellowBar, data: ArraySubject.create(Object.values(VarioIndicatorYellowBarSettingMode)) }),
                        FSComponent.buildComponent(TextListField, { name: 'Red Diamond', dataRef: this.redDiamond, data: ArraySubject.create(Object.values(VarioIndicatorRedDiamondSettingMode)) })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(CheckBoxField, { name: 'MacCready', label: 'MacCready', orientation: 'horizontal', checked: this.isMcSettingVisible }),
                        FSComponent.buildComponent(CheckBoxField, { name: 'Thermal', label: 'Thermal', orientation: 'horizontal', disabled: true, checked: Subject.create(false) })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(TextListField, { name: 'SideBar', data: ArraySubject.create(Object.values(VarioIndicatorSideBarSettingMode)), dataRef: this.sideBar }),
                        FSComponent.buildComponent(CheckBoxField, { name: 'Flarm', label: 'Flarm', orientation: 'horizontal', disabled: true, checked: Subject.create(false) })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(TextListField, { name: 'Dial Style', label: 'Dial Style', data: ArraySubject.create(['Linear', 'Non-Linear']), dataRef: this.isScaleLinear }),
                        FSComponent.buildComponent(TextListField, { name: 'Needle Style', label: 'Needle Style', data: ArraySubject.create(['Thin', 'Medium', 'Thick']), dataRef: Subject.create(1), disabled: true })),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent(TextListField, { name: 'Background', label: 'Background', data: ArraySubject.create(['White:Black', 'Black:Black', 'Black:White', 'White:White']), dataRef: Subject.create(0), disabled: true }))))));
    }
}

class PolarPage extends GuiDialog {
    constructor() {
        super(...arguments);
        this.graphSize = { x: 300, y: 270 };
        this.gridOpacity = 0.4;
        this.fontSize = 17;
        this.speedRange = { min: 0, max: 250 };
        this.sinkRateRange = { min: 0, max: 10 };
        this.polarData = [];
        this.polarPolygonRef = FSComponent.createRef();
        this.speedToFlyPolygonRef = FSComponent.createRef();
        this.speedToFlyTextRef = FSComponent.createRef();
        this.updatePolarInterval = undefined;
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        RegisterViewListener('JS_LISTENER_GLIDER_DATA', () => this.updatePolarCurve());
        this.onOpen.on(() => {
            this.props.menuSystem.pushMenu('PolarMenu');
            this.updatePolarInterval = setInterval(() => this.updatePolarCurve(), 100);
        });
        this.onClose.on(() => {
            clearInterval(this.updatePolarInterval);
        });
        this.props.bus
            .getSubscriber()
            .on('PolarMenuEvent')
            .handle((event) => {
            switch (event) {
                case ValidationActionsEvent.CLOSE:
                    this.props.viewService.openByName('SetupMode');
                    break;
            }
        });
    }
    async updatePolarCurve() {
        this.polarData = (await Coherent.call('GET_POLAR'));
        this.updateSpeedToFlyLine();
        if (!this.polarData) {
            return;
        }
        let path = '';
        for (let i = 0; i < this.polarData.length; i++) {
            path += `${Utils.mapValue(this.polarData[i].speed, this.speedRange.min, this.speedRange.max, 0, this.graphSize.y)},${Utils.mapValue(this.polarData[i].sinkRate * Avionics.Utils.FEET2METER, this.sinkRateRange.min, this.sinkRateRange.max, 0, this.graphSize.y)} `;
        }
        diffAndSetAttribute(this.polarPolygonRef.instance, 'points', path);
    }
    updateSpeedToFlyLine() {
        const speedToFly = SimVar.GetSimVarValue('VARIOMETER SPEED TO FLY:1', 'kilometers per hour');
        if (this.polarData.length == 0) {
            return;
        }
        const x1 = Utils.mapValue(this.speedRange.max, this.speedRange.min, this.speedRange.max, 0, this.graphSize.x);
        const speedToFlyCoordinates = this.polarData.reduce(function (prev, curr) {
            return Math.abs(curr.speed - speedToFly) < Math.abs(prev.speed - speedToFly) ? curr : prev;
        });
        const y1 = Utils.mapValue((this.speedRange.max / (speedToFlyCoordinates.speed / speedToFlyCoordinates.sinkRate)) *
            Avionics.Utils.FEET2METER, this.sinkRateRange.min, this.sinkRateRange.max, 0, this.graphSize.y);
        diffAndSetAttribute(this.speedToFlyPolygonRef.instance, 'points', `0,0 ${x1}, ${y1}`);
        diffAndSetAttribute(this.speedToFlyTextRef.instance, 'x', Utils.mapValue(speedToFlyCoordinates.speed, this.speedRange.min, this.speedRange.max, 0, this.graphSize.x).toString());
        diffAndSetAttribute(this.speedToFlyTextRef.instance, 'y', Utils.mapValue(speedToFlyCoordinates.sinkRate, this.sinkRateRange.min, this.sinkRateRange.max, 0, this.graphSize.y).toString());
        diffAndSetText(this.speedToFlyTextRef.instance, `${speedToFly.toFixed()}km/h`);
    }
    buildGrid() {
        let gridElements = [];
        gridElements.push(FSComponent.buildComponent("line", { stroke: 'white', "stroke-width": '3', x1: '0', x2: this.graphSize.x, y1: '0', y2: '0' }));
        for (let i = 0; i <= this.graphSize.y; i = i + this.graphSize.y / 10) {
            gridElements.push(FSComponent.buildComponent("line", { stroke: 'grey', "stroke-width": '2', x1: '0', x2: this.graphSize.x, y1: i, y2: i, opacity: this.gridOpacity }));
        }
        gridElements.push(FSComponent.buildComponent("text", { x: 60, y: 290, "font-size": '17', fill: 'white', "text-anchor": 'end' }, "Ws[m/s]"));
        let horizontalLabelIndex = 0;
        for (let i = 0; i <= this.graphSize.y; i = i + (this.graphSize.y / 10) * 2) {
            gridElements.push(FSComponent.buildComponent("text", { x: -10, y: i + 17 / 2, "font-size": '17', fill: 'white', "text-anchor": 'end' }, horizontalLabelIndex.toFixed()));
            horizontalLabelIndex++;
        }
        gridElements.push(FSComponent.buildComponent("line", { stroke: 'white', "stroke-width": '3', x1: '0', x2: '0', y1: '0', y2: this.graphSize.y }));
        for (let i = 0; i <= this.graphSize.x; i = i + (this.graphSize.x / this.speedRange.max) * 10) {
            gridElements.push(FSComponent.buildComponent("line", { stroke: 'grey', "stroke-width": '2', x1: i, x2: i, y1: '0', y2: this.graphSize.y, opacity: i % (this.graphSize.x / (this.speedRange.max / 50)) == 0 ? this.gridOpacity * 2 : this.gridOpacity }));
        }
        gridElements.push(FSComponent.buildComponent("text", { x: -10, y: -10, "font-size": '17', fill: 'white' }, "V[kmh]"));
        let verticalLabelIndex = 50;
        for (let i = this.graphSize.x / (this.speedRange.max / 50); i <= this.graphSize.x; i = i + this.graphSize.x / (this.speedRange.max / 50)) {
            gridElements.push(FSComponent.buildComponent("text", { x: i, y: -10, "font-size": '17', fill: 'white', "text-anchor": 'middle' }, verticalLabelIndex.toFixed()));
            verticalLabelIndex += 50;
        }
        return gridElements;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content polar-page' },
                FSComponent.buildComponent("svg", { width: '400px', height: '400px' },
                    FSComponent.buildComponent("g", { transform: 'translate(50, 30)' },
                        FSComponent.buildComponent("g", null, this.buildGrid()),
                        FSComponent.buildComponent("polyline", { ref: this.speedToFlyPolygonRef, fill: 'none', stroke: 'yellow', "stroke-width": '3' }),
                        FSComponent.buildComponent("polyline", { ref: this.polarPolygonRef, fill: 'none', stroke: 'green', "stroke-width": '3' }),
                        FSComponent.buildComponent("polyline", { ref: this.polarPolygonRef, fill: 'none', stroke: 'green', "stroke-width": '3' }),
                        FSComponent.buildComponent("text", { ref: this.speedToFlyTextRef, fill: 'white', "font-size": '17', "text-anchor": 'middle' }))))));
    }
}

class QNHAndResPage extends GuiDialog {
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('QNHandRESMenu'));
        this.props.bus
            .getSubscriber()
            .on('QNHAndResMenuEvent')
            .handle((event) => {
            switch (event) {
                case FieldActionEvent.CLOSE:
                    this.props.viewService.openByName('SetupMode');
                    break;
                case FieldActionEvent.EDIT:
                    this.startFieldEdit();
                    break;
                case FieldActionEvent.CANCEL:
                    this.cancelFieldEdit();
                    break;
                case FieldActionEvent.OK:
                    this.validateFieldEdit();
                    break;
            }
        });
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'QNHlayout' },
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent("div", { class: 'left-column' }, "QNH:"),
                        FSComponent.buildComponent("div", { class: 'right-column' },
                            FSComponent.buildComponent(ValueField, { name: 'QNH', data: this.props.QNHAndResSettings.getSetting('qnh'), min: 900, max: 1100, unit: 'hPa', smallStep: 1, bigStep: 10, orientation: 'horizontal' }))),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent("div", { class: 'left-column' }, "Safety Altitude:"),
                        FSComponent.buildComponent("div", { class: 'right-column' },
                            FSComponent.buildComponent(ValueField, { name: 'elevation', data: this.props.QNHAndResSettings.getSetting('safetyAltitude'), max: 3281, min: 0, unit: 'ft', decimals: 0, smallStep: 5, bigStep: 100, orientation: 'horizontal' }))),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent("div", { class: 'left-column' }, "Altitude source:"),
                        FSComponent.buildComponent("div", { class: 'right-column' },
                            FSComponent.buildComponent(TextListField, { name: 'vario', dataRef: Subject.create(0), data: ArraySubject.create(['Vario']), disabled: true, orientation: 'horizontal' }))),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent("div", { class: 'left-column' },
                            FSComponent.buildComponent(CheckBoxField, { name: 'auto variation', disabled: true, label: 'auto variation:', checked: Subject.create(false) })),
                        FSComponent.buildComponent("div", { class: 'right-column' },
                            FSComponent.buildComponent(TextListField, { name: 'magnetic variation', dataRef: Subject.create(0), data: ArraySubject.create(['03°E']), disabled: true, label: 'Magnetic var.' }))),
                    FSComponent.buildComponent("div", { class: 'row' },
                        FSComponent.buildComponent("div", { class: 'left-column' },
                            FSComponent.buildComponent(TextListField, { name: 'ETA calculation', label: 'ETA calculation based on', dataRef: Subject.create(0), disabled: true, data: ArraySubject.create(['Avg.speed/Mc', 'Avg.speed/Vario', 'Average Vario', 'MacCready']) })),
                        FSComponent.buildComponent("div", { class: 'right-column' },
                            FSComponent.buildComponent(TextListField, { name: 'soaring start', label: 'Soaring start', dataRef: Subject.create(0), disabled: true, data: ArraySubject.create(['--:--:--']) })))))));
    }
}

class StartUpLogoPage extends GuiDialog {
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.clear());
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'startup-logo-top' },
                    FSComponent.buildComponent("h1", null, this.props.AS_name)),
                FSComponent.buildComponent("div", { class: 'startup-logo-bottom' },
                    FSComponent.buildComponent("h2", null, "Version 8.04b (Oct 26 2021)"),
                    FSComponent.buildComponent("h2", null, "Serial number: 2BCU"),
                    FSComponent.buildComponent("div", { class: 'startupImages' },
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_1.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_2.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_3.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_4.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_5.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_6.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_7.svg' }),
                        FSComponent.buildComponent("img", { class: 'startupImage', src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_STARTUP_8.svg' })),
                    FSComponent.buildComponent("p", { class: 'startup-text' },
                        "The ",
                        this.props.AS_name,
                        " system is designed for VFR use only as an aid to prudent navigation. All information is presented for reference only. Terrain, airports and airspace data are provided only as an aid to situation awareness"),
                    FSComponent.buildComponent("p", { class: 'subtext' }, "2022 ASNAV, All rights reserved")))));
    }
}

class StartUpProfilePage extends GuiDialog {
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('startUpProfileMenu'));
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'startup-profile' },
                    FSComponent.buildComponent("div", { class: 'left-column' },
                        FSComponent.buildComponent("img", { src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_PROFILE.svg' })),
                    FSComponent.buildComponent("div", { class: 'right-column' },
                        FSComponent.buildComponent("h2", null, "Select Profile:"),
                        FSComponent.buildComponent(TextListField, { name: 'profile', dataRef: Subject.create(0), data: ArraySubject.create(['default']), focused: true }),
                        FSComponent.buildComponent("p", null,
                            "Glider: ",
                            this.props.aircraftName,
                            FSComponent.buildComponent("br", null),
                            "CN: none, Reg. Nr.: none",
                            FSComponent.buildComponent("br", null),
                            "Pilot: ",
                            FSComponent.buildComponent("br", null),
                            "Safety Altitude: 656ft",
                            FSComponent.buildComponent("br", null),
                            "Safety Mc offset: +5.8kts",
                            FSComponent.buildComponent("br", null)))))));
    }
}

class StartUpQNHPage extends GuiDialog {
    constructor(props) {
        super(props);
        this.initElevation = this.props.QNHAndResSettings.getSetting('fieldElevation').get();
        this.initQNH = this.props.QNHAndResSettings.getSetting('qnh').get();
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('StartUpQNHMenu'));
        this.props.QNHAndResSettings.getSetting('fieldElevation').sub((elevation) => {
            this.props.QNHAndResSettings.getSetting('qnh').set(this.formatQNH(elevation));
        });
        this.props.bus
            .getSubscriber()
            .on('QNHAndResStartUpMenuEvent')
            .handle((event) => {
            switch (event) {
                case QNHAndResStartUpActionEvent.DEFAULT:
                    this.props.QNHAndResSettings.getSetting('fieldElevation').set(SimVar.GetSimVarValue('PLANE ALTITUDE', 'feet'));
                    break;
                case QNHAndResStartUpActionEvent.QNH_ELEV:
                    this.validateFieldEdit();
                    if (this.focusedIndex === 0) {
                        this.focus(FocusPosition.Last);
                    }
                    else {
                        this.focus(FocusPosition.First);
                    }
                    this.startFieldEdit();
                    break;
            }
        });
    }
    formatQNH(elevation) {
        const delta = Math.floor((this.initElevation - elevation) / 27);
        const QNH = this.initQNH - delta;
        return QNH;
    }
    onInteractionEvent(event) {
        if (this.registeredControls !== undefined) {
            this.registeredControls[this.focusedIndex].onInteractionEvent(event);
        }
        return false;
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'startup-qnh' },
                    FSComponent.buildComponent("div", { class: 'left-column' },
                        FSComponent.buildComponent("img", { src: '/Pages/VCockpit/Instruments/Gliders/ASNAV/Shared/Assets/startup/ICON_GLIDERS_QNHANDRES.svg' })),
                    FSComponent.buildComponent("div", { class: 'right-column' },
                        FSComponent.buildComponent(ValueField, { name: 'elevation', data: this.props.QNHAndResSettings.getSetting('fieldElevation'), unit: 'ft', label: 'Elevation:', bigStep: 100, smallStep: 5, min: -30000, max: 30000, focused: true }),
                        FSComponent.buildComponent(ValueField, { name: 'qnh', data: this.props.QNHAndResSettings.getSetting('qnh'), unit: 'hPa', label: 'QNH:' }))))));
    }
}

const NETTO_FILTER_DATA = [0.1, 0.2, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 20];
const RANGES = [2.5, 5, 10];
class VarioParametersPage extends GuiDialog {
    constructor(props) {
        super(props);
        this.userSettings = VarioIndicatorUserSettings.getManager(this.props.bus);
        this.selectedRange = Subject.create(0);
        this.varioNeedleFilter = Subject.create(this.userSettings.getSetting('varioNeedleFilter').get());
        this.nettoFilterData = ArraySubject.create();
        this.nettoFilter = Subject.create(0);
        this.integratorTime = Subject.create(this.userSettings.getSetting('integratorTime').get());
        this.nettoTime = Subject.create(this.userSettings.getSetting('nettoTime').get());
        const defaultSelectedRange = RANGES.indexOf(this.userSettings.getSetting('varioRange').get());
        if (defaultSelectedRange !== -1)
            this.selectedRange.set(defaultSelectedRange);
        const defaultNettoFilter = NETTO_FILTER_DATA.map((v) => v * this.varioNeedleFilter.get()).indexOf(this.userSettings.getSetting('nettoFilter').get());
        if (defaultNettoFilter !== -1)
            this.nettoFilter.set(defaultNettoFilter);
    }
    computeNettoFilterData() {
        this.nettoFilterData.set(NETTO_FILTER_DATA.map((v) => Math.max(v * this.varioNeedleFilter.get(), 0.1).toFixed(1) + 'sec'));
    }
    onAfterRender(node) {
        super.onAfterRender(node);
        this.onOpen.on(() => this.props.menuSystem.pushMenu('VarioParametersMenu'));
        this.props.bus
            .getSubscriber()
            .on('VarioParametersMenuEvent')
            .handle((event) => {
            switch (event) {
                case FieldActionEvent.CLOSE:
                    this.props.viewService.openByName('SetupMode');
                    break;
                case FieldActionEvent.EDIT:
                    this.startFieldEdit();
                    break;
                case FieldActionEvent.CANCEL:
                    this.cancelFieldEdit();
                    break;
                case FieldActionEvent.OK:
                    this.validateFieldEdit();
                    break;
            }
        });
        this.selectedRange.sub((i) => this.userSettings.getSetting('varioRange').set(RANGES[i]));
        this.varioNeedleFilter.pipe(this.userSettings.getSetting('varioNeedleFilter'));
        this.varioNeedleFilter.sub((v) => this.computeNettoFilterData(), true);
        this.nettoFilter.sub((v) => this.userSettings.getSetting('nettoFilter').set(Number(this.nettoFilterData.getArray()[v])));
        this.integratorTime.pipe(this.userSettings.getSetting('integratorTime'));
        this.nettoTime.pipe(this.userSettings.getSetting('nettoTime'));
    }
    render() {
        return (FSComponent.buildComponent("div", { class: 'page' },
            FSComponent.buildComponent("div", { class: 'page-title' }, this.props.title),
            FSComponent.buildComponent("div", { class: 'page-content' },
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(ValueField, { name: 'Vario needle filter', label: 'Vario needle filter', data: this.varioNeedleFilter, min: 0.1, max: 5, smallStep: 0.1, bigStep: 1, decimals: 1, unit: 'sec' }),
                    FSComponent.buildComponent(ValueField, { name: 'Vario sound filter', label: 'Vario sound filter', data: Subject.create(1.5), min: 0.1, max: 5, smallStep: 0.1, bigStep: 1, decimals: 1, unit: 'sec', disabled: true }),
                    FSComponent.buildComponent(TextListField, { name: 'Vario range', label: 'Vario range', dataRef: this.selectedRange, data: ArraySubject.create(RANGES.map((v) => `${v}kts`)) })),
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(ValueField, { name: 'SC tab', label: 'SC tab', data: Subject.create(2), min: 0, max: 5, smallStep: 0.1, bigStep: 1, decimals: 1, unit: 'kts', disabled: true }),
                    FSComponent.buildComponent(ValueField, { name: 'Integrator time', label: 'Integrator time', data: this.integratorTime, min: 5, max: 60, smallStep: 1, bigStep: 10, decimals: 0, unit: 'sec' }),
                    FSComponent.buildComponent(TextListField, { name: 'Auto SC', label: 'Auto SC', dataRef: Subject.create(0), data: ArraySubject.create([
                            'OFF',
                            'GPS',
                            'G-load',
                            '54kts',
                            '57kts',
                            '59kts',
                            '67kts',
                            '70kts',
                            '73kts',
                            '76kts',
                            '78kts',
                            '81kts',
                            '84kts',
                            '86kts',
                        ]), disabled: true })),
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(TextListField, { name: 'Smart vario filter', label: 'Smart vario filter', dataRef: Subject.create(0), data: ArraySubject.create(['OFF', '1', '2', '3', '4', '8']), disabled: true }),
                    FSComponent.buildComponent(TextListField, { name: 'Beep at max', label: 'Beep at max', dataRef: Subject.create(0), data: ArraySubject.create(['OFF', 'ON']), disabled: true }),
                    FSComponent.buildComponent(ValueField, { name: 'Beep before max', label: 'Beep before max', data: Subject.create(3), min: 0, max: 9.9, smallStep: 0.1, bigStep: 1, decimals: 1, unit: 's', disabled: true })),
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(CheckBoxField, { name: 'Auto reset integrator', label: 'Auto reset integrator', disabled: true, checked: Subject.create(false) })),
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(TextListField, { name: 'Netto filter', label: 'Netto filter', dataRef: this.nettoFilter, data: this.nettoFilterData }),
                    FSComponent.buildComponent(ValueField, { name: 'SC filter', label: 'SC filter', data: this.varioNeedleFilter, decimals: 1, unit: 'sec', disabled: true }),
                    FSComponent.buildComponent(ValueField, { name: 'Relative filter', label: 'Relative filter', data: this.varioNeedleFilter, decimals: 1, unit: 'sec', disabled: true })),
                FSComponent.buildComponent("div", { class: 'row' },
                    FSComponent.buildComponent(ValueField, { name: 'Netto time', label: 'Netto time', data: this.nettoTime, min: 5, max: 60, smallStep: 1, bigStep: 10, decimals: 0, unit: 'sec' })))));
    }
}


